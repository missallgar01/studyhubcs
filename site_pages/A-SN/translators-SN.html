<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Programming Languages and Translators</title>
  <link rel="stylesheet" href="../../css/main.css" />
</head>

<body>

<header>
   <h1>Types of programming languages and Translators– Study Notes</h1>

</header>
<main>

<div class="vertical-knowledge">

<h2>Software & Operating Systems – Notes</h2>

    <div class="knowledge-card">
 <img src="images/translators/translator-workflow-diagram.jpeg" width="70%"/>
 <table>
    <thead>
      <tr>
        <th>High-Level</th>
        <th>Low-Level</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <ul>
            <li>Uses English-like statements which can be easily read by programmers</li>
            <li>Designed for quick programming</li>
            <li>Can be translated for multiple machine architectures</li>
            <li>Need to rely on a compiler to optimise the code</li>
            <li>May produce multiple lines of machine code per line of code (one-to-many)</li>
          </ul>
        </td>
        <td>
          <ul>
            <li>Microprocessor/CPU/machine specific and can control the hardware directly</li>
            <li>Can be highly optimised to make efficient use of the hardware and execute more quickly</li>
            <li>Each line of code is one instruction only</li>
            <li>Hard to read and learn</li>
            <li>Only works for one type of machine architecture</li>
            <li>Uses mnemonics – sequences of letters easy for a person to remember (ADD, LOAD, SUB, INP etc.)</li>


          </ul>
        </td>
      </tr>
    </tbody>
  </table>

</div>

    <div class="knowledge-card">
<table>
  <thead>
    <tr>
      <th>Term</th>
      <th>Definition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Source Code</td>
      <td>A program written by the programmer in a high-level language. It is easy for humans to read but must be translated before execution.</td>
    </tr>
    <tr>
      <td>Object Code</td>
      <td>Low-level or machine code produced by a translator. It is understood by the computer.</td>
    </tr>
    <tr>
      <td>Executable Code</td>
      <td>A complete machine-code program that can be run directly by the computer.</td>
    </tr>
    <tr>
      <td>Intermediate Code</td>
      <td>Machine-independent code produced by a compiler that requires further translation by an interpreter or virtual machine.</td>
    </tr>
    <tr>
      <td>Translator</td>
      <td>Software that converts high-level or assembly code into machine code.</td>
    </tr>
    <tr>
      <td>Compiler</td>
      <td>Translates the entire source code at once and produces an executable file. Errors are reported after compilation.</td>
    </tr>
    <tr>
      <td>Interpreter</td>
      <td>Translates and executes source code line by line at runtime, reporting errors as they occur.</td>
    </tr>
    <tr>
      <td>Assembler</td>
      <td>Translates assembly language into machine code using mnemonics and symbolic addresses.</td>
    </tr>
    <tr>
      <td>High-Level Language (HLL)</td>
      <td>A programming language that uses English-like statements and is portable across different platforms.</td>
    </tr>
    <tr>
      <td>Low-Level Language</td>
      <td>A machine-specific language that uses mnemonics and opcodes and maps closely to hardware.</td>
    </tr>
    <tr>
      <td>Opcode</td>
      <td>The part of an instruction that tells the CPU what operation to perform.</td>
    </tr>
    <tr>
      <td>Operand</td>
      <td>The part of an instruction that specifies the data or memory location to be used.</td>
    </tr>
    <tr>
      <td>Mnemonic</td>
      <td>A short, human-readable instruction used in assembly language, such as ADD or SUB.</td>
    </tr>
    <tr>
      <td>Immediate Addressing</td>
      <td>The operand contains the actual value to be used.</td>
    </tr>
    <tr>
      <td>Direct Addressing</td>
      <td>The operand contains the memory address where the required data is stored.</td>
    </tr>
    <tr>
      <td>Indirect Addressing</td>
      <td>The operand contains the address of another memory location that holds the required address.</td>
    </tr>
    <tr>
      <td>Indexed Addressing</td>
      <td>The operand address is combined with an index register, commonly used for arrays.</td>
    </tr>
    <tr>
      <td>Lexical Analysis</td>
      <td>The first stage of compilation where comments and whitespace are removed and tokens are identified.</td>
    </tr>
    <tr>
      <td>Syntax Analysis</td>
      <td>Checks tokens against grammar rules, builds an abstract syntax tree, and reports syntax errors.</td>
    </tr>
    <tr>
      <td>Code Generation</td>
      <td>Produces object code from the analysed program.</td>
    </tr>
    <tr>
      <td>Code Optimisation</td>
      <td>Improves program efficiency by reducing execution time and memory usage.</td>
    </tr>
    <tr>
      <td>Symbol Table</td>
      <td>A data structure that stores information about identifiers, including type and memory address.</td>
    </tr>
    <tr>
      <td>Linker</td>
      <td>Combines object code files and libraries into a single executable file.</td>
    </tr>
    <tr>
      <td>Loader</td>
      <td>Loads the executable program and required libraries into memory for execution.</td>
    </tr>
    <tr>
      <td>Library Routines</td>
      <td>Pre-written, tested code that saves development time and reduces errors.</td>
    </tr>
  </tbody>
</table>
</div>

     <div class="knowledge-card">
  <p>
    One line of Python code results in many lines of machine code due to the steps
    necessary to perform the operation in hardware.
  </p>

  <p><strong>Python code:</strong></p>
  <pre>
a = 5 + 10
  </pre>

  <p><strong>Resulting Assembly Code:</strong></p>
  <pre>
1. MOV R1, #5     ; Move constant 5 into register R1
2. MOV R2, #10    ; Move constant 10 into register R2
3. ADD R3, R1, R2 ; Add R1 and R2, store result in R3
4. MOV [a], R3    ; Store the result from R3 into the memory location of a
  </pre>
</div>

    <div class="knowledge-card">
  <h3>How an Assembler Works</h3>

  <ul>
    <li>Reserves storage for instructions and data</li>
    <li>Replaces mnemonic opcodes with machine codes</li>
    <li>Replaces symbolic addresses with numeric addresses</li>
    <li>Creates a symbol table to map symbolic labels to numeric memory addresses</li>
    <li>Checks syntax</li>
    <li>Provides error diagnostics</li>
  </ul>

  <p><strong>Example Assembly Code (using symbols):</strong></p>
  <pre>
INP         ; Read input into the accumulator
ADD DATA    ; Add the value stored at DATA
STA DATA    ; Store the result back in DATA
HLT         ; Halt execution
DATA DAT 10 ; Store initial value 10
  </pre>

  <p><strong>After Assembly (symbols replaced with addresses):</strong></p>
  <pre>
INP
ADD 00010000 ; Add the value stored at address 00010000
STA 00010000 ; Store the result back at address 00010000
HLT
  </pre>

  <p><strong>Symbol Table:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Symbol</th>
        <th>Address</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>DATA</td>
        <td>00010000</td>
      </tr>
    </tbody>
  </table>
</div>

     <div class="knowledge-card">
  <table>
    <thead>
      <tr>
        <th>Compilers</th>
        <th>Interpreters</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Translate the entire source code in one go into machine code and create an executable file (exe)</td>
        <td>Translate and execute source code line by line</td>
      </tr>
      <tr>
        <td>Object code results in faster processing</td>
        <td>Slower processing</td>
      </tr>
      <tr>
        <td>Reports all errors at the end of compilation</td>
        <td>Reports errors as they occur</td>
      </tr>
      <tr>
        <td>Whole program must be loaded into memory</td>
        <td>Memory is only needed as each line of code is run</td>
      </tr>
      <tr>
        <td>Used at the end of development (ready for shipping)</td>
        <td>Used during development (aids debugging)</td>
      </tr>
      <tr>
        <td>Source code is hidden, protecting it from being copied</td>
        <td>Source code must be accessible</td>
      </tr>
      <tr>
        <td>Machine dependent – only runs on computers with a specific architecture</td>
        <td>Platform independent – requires a suitable interpreter</td>
      </tr>
    </tbody>
  </table>
</div>

    <div class="knowledge-card">
  <h3>High-Level Languages and Intermediate Code</h3>

  <p>
    Intermediate code is a type of code that sits between high-level source code
    (such as Python, Java, or C#) and machine code (binary code executed by the CPU).
    It is not specific to any machine, but it is more structured and lower-level than
    the original source code.
  </p>


    <img src="images/translators/intermediate-code-vm-flow.jpeg" height="199" width="655"/>
    <p>
    An interpreter or virtual machine handles machine-specific execution.
  </p>

  <ul>
    <li>Portable – can be used on any machine (write once, run anywhere)</li>
    <li>The same intermediate code can run on different systems using the appropriate interpreter or virtual machine</li>
    <li>Intermediate code is machine-independent</li>
    <li>Protects the source code from being copied</li>
  </ul>

  <h4>Execution Process</h4>
  <pre>
Source Code → Compiled → Intermediate Code → Runs in Virtual Machine
  </pre>
</div>

    <div class="knowledge-card">
          <h3>Opcode and Operand</h3>

          <p>
            An instruction is split into an <strong>opcode</strong> and an <strong>operand</strong>.
          </p>
          <ul>
            <li><strong>Opcode</strong> specifies which operation to carry out</li>
            <li><strong>Operand</strong> specifies the data that needs to be acted on</li>
          </ul>

          <h4>Common LMC Mnemonics</h4>
          <table>
            <thead>
              <tr>
                <th>Mnemonic</th>
                <th>Instruction</th>
                <th>Alternative Mnemonics Accepted</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>ADD</td>
                <td>Add</td>
                <td></td>
              </tr>
              <tr>
                <td>SUB</td>
                <td>Subtract</td>
                <td></td>
              </tr>
              <tr>
                <td>STA</td>
                <td>Store</td>
                <td>STO</td>
              </tr>
              <tr>
                <td>LDA</td>
                <td>Load</td>
                <td>LOAD</td>
              </tr>
              <tr>
                <td>BRA</td>
                <td>Branch always</td>
                <td>BR</td>
              </tr>
              <tr>
                <td>BRZ</td>
                <td>Branch if zero</td>
                <td>BZ</td>
              </tr>
              <tr>
                <td>BRP</td>
                <td>Branch if positive</td>
                <td>BP</td>
              </tr>
              <tr>
                <td>INP</td>
                <td>Input</td>
                <td>IN, INPUT</td>
              </tr>
              <tr>
                <td>OUT</td>
                <td>Output</td>
                <td></td>
              </tr>
              <tr>
                <td>HLT</td>
                <td>End program</td>
                <td>COB, END</td>
              </tr>
              <tr>
                <td>DAT</td>
                <td>Data location</td>
                <td></td>
              </tr>
            </tbody>
          </table>

          <h4>Example: Add Two Numbers (LMC)</h4>
          <pre>
        INP        // Input the first number
        STA 90     // Store the first number in memory location 90
        INP        // Input the second number
        ADD 90     // Add the number in memory location 90 to the accumulator
        OUT        // Output the result
        HLT        // End the program
        DAT        // Memory location 90 for storing data
          </pre>
        </div>

    <div class="knowledge-card">
          <h3>Addressing modes</h3>

          <h4>Immediate Addressing (#)</h4>
          <p><strong>#</strong> before a number means to use the <strong>value itself</strong>, not the address.</p>
          <p>
            Example: <code>ADD #4</code> means “Load the value 4 directly into the accumulator.”
          </p>

          <h4>Direct Addressing (default, no symbol)</h4>
          <p>The operand refers directly to a memory address.</p>
          <p>
            Example: <code>LDA 10</code> means “Load the value at memory address 10.”
          </p>

          <h4>Indirect Addressing (&amp;)</h4>
          <p>
            <strong>&amp;</strong> means the operand is the <strong>address of a memory location that contains another address</strong>.
          </p>
          <p>Example: <code>LDA &amp;7</code> means:</p>
          <ol>
            <li>Go to memory address 7, read the number there (15).</li>
            <li>Then go to memory address 15 and load that value.</li>
          </ol>

          <figure>
            <figcaption><strong>Fig. 3.1</strong></figcaption>
            <pre style="white-space: pre; overflow:auto; margin-top:.5rem;">
        0  LDA &amp;7
        1  ADD #4
        2  OUT
        3  HLT
        4  6
        5  2
        6  10
        7  15
        8  16
        9  17
            </pre>
          </figure>

          <hr />

          <h4>Indexed addressing</h4>
          <p>
            Indexed addressing uses a <strong>base address + the value in an index register</strong> to compute the final memory address.
            This allows for <strong>array-like access</strong> or <strong>looping through data</strong>.
          </p>

          <p><strong>For example:</strong></p>
          <ul>
            <li>The instruction is <code>LDA 20,X</code></li>
            <li>The index register <strong>X</strong> contains the value <code>0</code></li>
          </ul>

          <p>
            Then: The LMC loads the value from address <code>20 + 0 = 20</code>, so it accesses <strong>memory address 20</strong>.
          </p>
          <p>After the operation, the index register <strong>X increments by 1</strong>.</p>
        </div>

    <div class="knowledge-card">
          <h3>Stage 1: Lexical Analysis</h3>

          <ol>
            <li>Lexer scans the source code letter by letter</li>
            <li>Words (lexemes) are identified when there is whitespace, an operator symbol, or a special symbol</li>
            <li>Comments are stripped out and unnecessary spaces are removed</li>
            <li>Each lexeme is checked to see if it is a valid token</li>
            <li>The lexeme is stored along with its token and added to the symbol table</li>
          </ol>

          <p><strong>Example:</strong></p>
          <pre>
        [keyword: if][Separator: (][Identifier: x][Operator: >]
          </pre>

          <p>
            All keywords, constants, and identifiers (e.g. variable names) used in the
            source code are replaced by <strong>tokens</strong>.
          </p>

          <h4>Token Classes</h4>
          <table>
            <thead>
              <tr>
                <th>Token Class</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Identifier</td>
                <td>Any function or variable name</td>
              </tr>
              <tr>
                <td>Keyword</td>
                <td>As, If, Else, EndIf, Function, EndFunction, Return</td>
              </tr>
              <tr>
                <td>Separator</td>
                <td>( ) , &amp;</td>
              </tr>
              <tr>
                <td>Operator</td>
                <td>+ - * / % ^ DIV MOD &lt; &gt; =</td>
              </tr>
              <tr>
                <td>Literal</td>
                <td>"Hello world"</td>
              </tr>
              <tr>
                <td>Number</td>
                <td>-4, 0, 3.4</td>
              </tr>
              <tr>
                <td>Quote</td>
                <td>"</td>
              </tr>
              <tr>
                <td>Boolean</td>
                <td>True, False</td>
              </tr>
              <tr>
                <td>Datatype</td>
                <td>Integer, Decimal, String, Boolean</td>
              </tr>
            </tbody>
          </table>
        </div>

    <div class="knowledge-card">
          <h3>The Symbol Table</h3>

          <p>
            The symbol table plays a central role in the compilation process.
            It contains an entry for every keyword (reserved word) and identifier
            in the program.
          </p>

          <h4>The table will show:</h4>
          <ul>
            <li>Identifier or keyword</li>
            <li>Kind of item (variable, array, procedure, keyword, etc.)</li>
            <li>Type of item (integer, real, char, etc.) – added during the syntax stage</li>
          </ul>

          <h4>It will also store:</h4>
          <ul>
            <li>Run-time address of the item, or its value if it is a constant</li>
            <li>
              Pointer to accessing information
              (e.g. array bounds, or procedure parameter information)
            </li>
          </ul>

          <h4>Example Source Code</h4>
          <pre>
        Function checkScore(score As Integer)
          If score > 75 Then
            Return "Pass"
          Else
            Return "Fail"
          EndIf
        EndFunction
          </pre>

          <h4>Example Symbol Table</h4>

                      <img src="images/translators/symbol-table-function-checkscore.jpeg" height="352"
                                            width="761"/>


                      <img src="images/translators/symbol-table-token-list.jpeg" height="755" width="696"/>
                      <p><em>
            Note: Data types and additional details are added during the syntax analysis stage.
          </em></p>
        </div>

    <div class="knowledge-card">
          <h2>Stage 2: Syntax Analysis</h2>

          <ul>
            <li>This stage analyses the syntax of statements to ensure they conform to the grammar rules of the programming language</li>
            <li>The purpose of syntax analysis (parsing) is to check that there is a valid sequence of tokens</li>
            <li>Tokens represent symbols, keywords, identifiers, literals, etc.</li>
          </ul>

          <h4>Process</h4>
          <ol>
            <li>Token stream is sent to the syntax analyser</li>
            <li>The analyser checks that the token stream follows the grammar rules of the language</li>
            <li>Stacks are used to check structures such as correctly paired brackets</li>
            <li>If errors are found, they are reported</li>
            <li>Error diagnostics are produced</li>
            <li>An abstract syntax tree (AST) is created</li>
            <li>Identifiers in the symbol table are updated (e.g. data type, scope)</li>
          </ol>


            <img src="images/translators/compiler-lexical-syntax-flow.png" width="50%"/>
            <hr>

          <h3>Stage 3: Code Generation and Optimisation</h3>

          <p>
            This is the final phase of compilation and produces <strong>object code</strong>.
          </p>

          <ul>
            <li>Makes the program run faster / code more efficient</li>
            <li>Makes the program use fewer resources / less memory</li>
          </ul>

          <h4>Disadvantages of Code Optimisation</h4>
          <ul>
            <li>Increases compilation time, sometimes considerably</li>
            <li>May sometimes produce unexpected results</li>
          </ul>

          <h4>Examples of Optimisation</h4>
          <ul>
            <li>Removes variables and subprograms that are not used</li>
            <li>Removes lines of code that are never accessed</li>
          </ul>
        </div>

    <div class="knowledge-card">
          <h3>What is a Linker?</h3>

          <ul>
            <li>Combines/links code and programs to files or software libraries</li>
            <li>Forms a single executable file</li>
            <li>Static linkers combine code and libraries into one file</li>
            <li>Dynamic linkers add addresses to external libraries</li>
          </ul>

          <h3>What is a Loader?</h3>

          <ul>
            <li>Part of the operating system</li>
            <li>Loads an executable file into memory</li>
            <li>Loads the program from secondary storage</li>
            <li>Loads the required software libraries</li>
          </ul>

          <h3>Libraries</h3>

          <p>
            Library programs are ready-compiled programs grouped into software libraries,
            which can be loaded and run when required. In Windows, these often have a
            <code>.dll</code> extension.
          </p>

          <p>
            Most compiled languages have their own libraries of pre-written functions
            which can be invoked in a defined manner from within the user's program.
          </p>

          <h4>Advantages of Library Routines</h4>
          <ul>
            <li>Tested and error-free</li>
            <li>Save programmer time by avoiding re-inventing the wheel</li>
            <li>Provide ready-made solutions for common tasks</li>
          </ul>
        </div>

    <div class="knowledge-card">
    <h2>Topic C: Little Man Computer (LMC)</h2>
    <h3>Example</h3>
  <p>LMC — Example 2: Find the smallest of three numbers</p>

  <p>
    This program inputs three numbers and determines the smallest of the three, outputting the result.
  </p>

  <pre><code>INP                 // Input the first number
STA 91              // Store the first number in memory location 91
INP                 // Input the second number
STA 92              // Store the second number in memory location 92
INP                 // Input the third number
STA 93              // Store the third number in memory location 93
LDA 91              // Load the first number
SUB 92              // Subtract the second number
BRP CHECK_THIRD_FROM_FIRST   // If result is positive, then first number &gt; second number

LDA 92              // Load the second number
SUB 93              // Subtract the third number
BRP OUTPUT_SECOND   // If result is positive, then second number &gt; third number
LDA 93
OUT                 // Output the third number
HLT

CHECK_THIRD_FROM_FIRST:
  LDA 91
  SUB 93
  BRP OUTPUT_FIRST
  LDA 93
  OUT
  HLT

OUTPUT_FIRST:
  LDA 91
  OUT
  HLT

OUTPUT_SECOND:
  LDA 92
  OUT
  HLT

DAT                 // Memory locations for data storage
DAT
DAT</code></pre>
</div>

</div>
</div>


 <button id="printBtn" type="button">
  Print this worksheet
</button>

</main>

<footer>
    © <span id="year"></span> StudyHub CS
  </footer>

<script src="../js/booklets.js"></script>
<div id="command-words"></div>

</body>
</html>