<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Software</title>
  <link rel="stylesheet" href="../../css/main.css" />
</head>

<body>

<header>
 <h1>Software– Study Notes</h1>

</header>

<main>

 <div class="vertical-knowledge">

      <h2>Software & Operating Systems – Notes</h2>


      <div class="knowledge-card">
        <h3>System Software vs Application Software</h3>
        <p><strong>System software</strong> enables the computer to operate, controls hardware and provides a platform for applications (for example, the operating system, utilities and device drivers).</p>
        <p><strong>Application software</strong> consists of programs that perform tasks for the user, such as writing documents, browsing the web or editing images.</p>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-QC.html">Quick Check</a></div>
</div>

      </div>

      <div class="knowledge-card">
        <h3>Types of Application Software</h3>
        <table>
          <thead>
          <tr>
            <th>Type</th>
            <th>Purpose</th>
            <th>Examples</th>
          </tr>
          </thead>
          <tbody>
          <tr>
            <td>Word Processor</td>
            <td>Create and edit text documents.</td>
            <td>Word, Google Docs</td>
          </tr>
          <tr>
            <td>Spreadsheet</td>
            <td>Organise, analyse and process numerical data.</td>
            <td>Excel, Google Sheets</td>
          </tr>
          <tr>
            <td>Database</td>
            <td>Store, query and manage data.</td>
            <td>Access, MySQL</td>
          </tr>
          <tr>
            <td>Presentation Software</td>
            <td>Create visual / multimedia presentations.</td>
            <td>PowerPoint, Keynote</td>
          </tr>
          <tr>
            <td>Graphics / Image Editor</td>
            <td>Manipulate and create graphics.</td>
            <td>Photoshop, GIMP</td>
          </tr>
          <tr>
            <td>Web Browser</td>
            <td>Access and view web pages.</td>
            <td>Chrome, Firefox, Edge</td>
          </tr>
          <tr>
            <td>Video Editor</td>
            <td>Edit and create video content.</td>
            <td>Premiere Pro, Final Cut Pro</td>
          </tr>
          <tr>
            <td>IDE</td>
            <td>Develop, test and debug code.</td>
            <td>VS Code, IntelliJ IDEA</td>
          </tr>
          <tr>
            <td>Virtualisation Software</td>
            <td>Create and run virtual machines.</td>
            <td>VMware, VirtualBox</td>
          </tr>
          </tbody>
        </table>

 <div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-application-QC.html">Quick Check</a></div>
</div>

      </div>

      <div class="knowledge-card">
        <h3>Utility Software</h3>
        <p><strong>Utility software</strong> helps analyse, configure, optimise and maintain a computer system. It supports the operating system rather than directly performing end-user tasks.</p>
        <table>
          <thead>
          <tr>
            <th>Utility</th>
            <th>Purpose</th>
            <th>Example Use</th>
          </tr>
          </thead>
          <tbody>
          <tr>
            <td>Disk Defragmenter</td>
            <td>Rearranges files on a hard drive into contiguous blocks.</td>
            <td>Speeds up file access on HDDs.</td>
          </tr>
          <tr>
            <td>File Management</td>
            <td>Organise, search, rename and relocate files/folders.</td>
            <td>Windows Explorer, macOS Finder.</td>
          </tr>
          <tr>
            <td>Device Driver</td>
            <td>Interface between OS and hardware device.</td>
            <td>Printer, graphics card, network card.</td>
          </tr>
          <tr>
            <td>System Cleanup</td>
            <td>Remove temporary files and junk to free up space.</td>
            <td>Disk Cleanup, CCleaner.</td>
          </tr>
          <tr>
            <td>Security / Antivirus</td>
            <td>Protects against malware and other threats.</td>
            <td>Windows Defender, Norton.</td>
          </tr>
          <tr>
            <td>Backup</td>
            <td>Creates copies of important files.</td>
            <td>Nightly backup of coursework to cloud / drive.</td>
          </tr>
          <tr>
            <td>Compression</td>
            <td>Reduces file sizes for storage or transfer.</td>
            <td>Compress large projects to email.</td>
          </tr>
          </tbody>
        </table>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-utility-QC.html">Quick Check</a></div>
</div>

      </div>

      <div class="knowledge-card">
        <h3>Open Source vs Closed Source Software</h3>
        <p>Think of software like a recipe.</p>
        <ul>
          <li><strong>Open Source Software (OSS)</strong> – the “shared recipe”. Source code can be viewed, modified and redistributed. Good for collaboration, transparency and customisation.</li>
          <li><strong>Closed Source Software (CSS)</strong> – the “secret recipe”. Source code is hidden and proprietary. Usually sold under licence with professional support.</li>
        </ul>
        <table>
          <thead>
          <tr>
            <th>Type</th>
            <th>Benefits to User</th>
            <th>Drawbacks to User</th>
          </tr>
          </thead>
          <tbody>
          <tr>
            <td>Open source</td>
            <td>Often free, customisable, transparent.</td>
            <td>May be less polished; compatibility issues; may contain bugs.</td>
          </tr>
          <tr>
            <td>Closed source</td>
            <td>Polished products; professional support; consistency.</td>
            <td>Licence costs; less customisable; must trust the vendor.</td>
          </tr>
          </tbody>
        </table>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-closed-open-QC.html">Quick Check</a></div>
</div>

      </div>

      <div class="knowledge-card">
        <h3>Purposes & Types of Operating Systems</h3>
        <p><strong>Operating system</strong> – a set of programs that manage hardware and provide a platform for application software.</p>
          <p><img src="images/software/software.png"/></p>
          <p><strong>Main purposes include:</strong></p>
        <ul>
          <li>Controlling hardware / resource management.</li>
          <li>Providing a platform for applications and file storage.</li>
          <li>Providing a user interface.</li>
          <li>Handling communication with other systems (protocols).</li>
          <li>Translating code (e.g. via compilers / interpreters).</li>
          <li>Providing utilities / housekeeping programs.</li>
        </ul>


        <p><strong>Types of OS:</strong></p>
        <ul>
          <li><strong>Single-user</strong> – one user at a time.</li>
          <li><strong>Multitasking</strong> – apparently runs several programs at once by sharing processor time.</li>
          <li><strong>Multi-user</strong> – many users share one powerful computer via terminals.</li>
          <li><strong>Distributed</strong> – several computers work together on one job.</li>
          <li><strong>Embedded</strong> – dedicated, read-only, built into devices.</li>
          <li><strong>Real-time</strong> – guarantees responses within a fixed maximum time; used in time-critical systems.</li>
        </ul>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-OS-QC.html">Quick Check</a></div>
</div>

      </div>

      <div class="knowledge-card">
        <h3>Interfaces</h3>
        <ul>
          <li><strong>GUI</strong> – windows, icons, menus; pointer used to select; intuitive for most users.</li>
          <li><strong>Form-based</strong> – user completes fields; common in data entry systems; reduces errors.</li>
          <li><strong>Menu-based</strong> – user chooses from limited options; good for kiosks / tourist info.</li>
          <li><strong>Natural Language Interface (NLI)</strong> – user types or speaks in everyday language; used in virtual assistants and expert systems.</li>
        </ul>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-interfaces-QC.html">Quick Check</a></div>
</div>

      </div>

      <div class="knowledge-card">
        <h3>Memory Management, Paging, Segmentation & Virtual Memory</h3>

          <table >
  <thead>
    <tr>
      <th>Virtual Memory</th>
      <th>Segmentation and Paging</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <h3>Why is virtual memory needed?</h3>
        <ul>
          <li>To allow programs to run that need more memory than is available</li>
        </ul>

        <h3>Describe how virtual memory is used</h3>
        <ul>
          <li>Uses backing store as if it were main memory / temporary storage</li>
          <li>Uses paging (fixed-size units)</li>
          <li>Swaps pages between memory and backing store</li>
          <li>Frees space for pages that are needed</li>
          <li>Holds parts of programs that are not currently in use</li>
          <li>Allows programs to run that need more memory than is available</li>
        </ul>

        <h3>Describe the problem of disk thrashing</h3>
        <ul>
          <li>Occurs when using virtual memory and moving pages between memory and disk</li>
          <li>The disk is relatively slow</li>
          <li>High rate of disk access</li>
          <li>More time is spent transferring pages than processing data</li>
        </ul>
      </td>

      <td>
        <p>
          To enable memory to be shared, segmentation or paging is used when managing memory.
          <strong>State two ways in which segmentation and paging are similar.</strong>
        </p>

        <ul>
          <li>Both are ways of partitioning memory</li>
          <li>Both allow programs to run despite insufficient memory</li>
          <li>Both are used for virtual memory</li>
          <li>Segments and pages are stored on backing store</li>
          <li>Segments and pages are assigned to memory when needed</li>
        </ul>

        <p><strong>State one difference between segmentation and paging. (1)</strong></p>
        <ul>
          <li>Segments are variable size, pages are fixed size</li>
          <li>Segments are complete sections of programs; pages are made to fit memory</li>
          <li>Segments are logical divisions; pages are physical divisions</li>
        </ul>

        <p>
          <strong>Explain one problem that may occur when using paging and segmentation.</strong>
        </p>
        <ul>
          <li>Disk thrashing</li>
          <li>More time is spent swapping pages than processing</li>
          <li>The computer may appear to hang</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>
</div>

      <div class="knowledge-card">
        <p><strong>Memory management</strong> allocates and deallocates RAM so multiple programs can run safely and efficiently.</p>
        <ul>
          <li><strong>Paging</strong> – splits memory into equal-sized pages (physical divisions). Processes are divided into pages that can be stored non-contiguously.</li>
            <li><strong>Segmentation</strong> – splits memory into variable-sized segments (logical divisions) such as code, data and stack.</li>
          <li><strong>Virtual memory</strong> – uses an area of secondary storage as an extension of RAM. Pages not currently needed are swapped out.</li>
        </ul>
        <p><strong>Disk thrashing</strong> – when the computer spends more time swapping pages between RAM and disk than doing useful processing.</p>

          <table>
  <thead>
    <tr>
      <th>Memory Management Technique</th>
      <th>Description</th>
      <th>Example</th>
      <th>Benefits</th>
      <th>Drawbacks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Paging</strong></td>
      <td>
        Divides memory into fixed-sized blocks called <strong>pages</strong>.
        <br><br>
        Pages are <strong>physical divisions</strong>.
      </td>
      <td>
        A process needing 200KB of memory is divided into four 64KB pages,
        leaving 8KB unused in the last page.
      </td>
      <td>
        When an application is launched, data is moved from the hard disk
        into pages for faster access.
      </td>
      <td>
        <p>This can lead to <strong>internal fragmentation</strong>.</p>
        <p>
          Pages are fixed size, so unused space may exist within a page
          if the process does not fill it completely.

            <img src="images/software/p08_memory_01.png" width="80%"/></p>
      </td>
    </tr>

    <tr>
      <td><strong>Segmentation</strong></td>
      <td>
        Divides memory into <strong>variable-sized segments</strong> based on
        logical parts of a process and complete sections of programs.
        <br><br>
        Segments are <strong>logical divisions</strong>.
      </td>
      <td>
        In a video editing application, different segments may be created
        for video data, audio data, effects, and UI elements.
      </td>
      <td>
        Segmentation is space-efficient as it only allocates the amount of
        memory an application needs.
      </td>
      <td>
        <p>This can result in <strong>external fragmentation</strong>.</p>
        <p>
          Over time, memory becomes fragmented as segments of different sizes
          are allocated and removed, leaving unusable gaps.
        </p>

          <img src="images/software/p08_memory_02.png" width="80%"/></td>
    </tr>
  </tbody>
</table>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-memory-QC.html">Quick Check</a></div>
</div>
</div>

      <div class="knowledge-card">
  <h2>BIOS</h2>
   <h3><strong>BIOS</strong> – Basic Input/Output System firmware stored in ROM on the motherboard. Performs POST (Power-On Self-Test) then loads the OS (bootstraps).</h3>

  <ul>
    <li>
      BIOS refers to the <strong>Basic Input/Output System</strong> of a computer
    </li>
    <li>
      BIOS is a piece of <strong>firmware</strong> stored on a small memory chip
      on the motherboard
    </li>
    <li>
      On system start, the BIOS is the <strong>first software to run</strong>
    </li>
    <li>
      It performs a <strong>POST (Power-On Self-Test)</strong>, a diagnostic
      testing sequence that ensures all the hardware components are working properly
    </li>
    <li>
      If the BIOS encounters any errors during this test, it will either
      <strong>halt the boot process</strong> or issue an <strong>error message</strong>
    </li>
    <li>
      If the POST succeeds, the BIOS will run the
      <strong>Bootstrap loading sequence</strong>, which is the program responsible
      for starting the operating system
    </li>
  </ul>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-bios-QC.html">Quick Check</a></div>
</div>
</div>

      <div class="knowledge-card">
  <h2>Interrupt handling</h2>
     <h3><strong>Interrupt</strong> – a signal to the CPU that a device or process needs attention. Causes the CPU to pause its current task and run an Interrupt Service Routine (ISR).</h3>
  <p>
    <strong>START</strong> &nbsp;
    <strong>REGISTERS</strong> &nbsp;
    <strong>PRIORITY</strong> &nbsp;
    <strong>STACK</strong> &nbsp;
    <strong>ISR</strong> &nbsp;
    <strong>FLAG</strong>
  </p>

  <ol>
    <li>
      Interrupt checked for at <strong>start/end</strong> of each
      <strong>fetch-execute cycle</strong>
    </li>
    <li>
      If the interrupt is of a lower or equal <strong>priority</strong>
      to the current process, then the current process continues
    </li>
    <li>
      If interrupt raised, contents of <strong>registers</strong>
      are copied to the <strong>stack</strong>
    </li>
    <li>
      <strong>Flags</strong> are set to determine if interrupts are
      enabled or disabled
    </li>
    <li>
      Program Counter is changed to point to the
      <strong>Interrupt Service Routine (ISR)</strong>
      &mdash; the ISR runs
    </li>
    <li>
      After interrupt completion, previous register values are
      restored from the <strong>stack</strong>
    </li>
    <li>
      <strong>Flag</strong> is reset
    </li>
    <li>
      If a higher priority interrupt is received while servicing
      an interrupt…
    </li>
    <li>
      …this is added to the <strong>stack</strong> and the new
      interrupt is dealt with
    </li>
  </ol>

  <p>
    The <strong>ISR (Interrupt Service Routine)</strong> is software —
    it is the function/code that runs when an interrupt occurs.
    <strong>Loading the ISR</strong> means starting the correct piece
    of code to handle the interrupt.
  </p>

  <h3>Example ISRs</h3>

  <ul>
    <li>
      <strong>Timer interrupt</strong> – Every 1 ms or 1 s, the timer triggers
      and the ISR toggles an LED or updates a clock
    </li>
    <li>
      <strong>Keyboard interrupt</strong> – A key is pressed, the keyboard
      hardware signals the CPU, and the ISR reads the key
    </li>
    <li>
      <strong>Network packet received</strong> – A new packet arrives at the
      Ethernet port and the ISR quickly moves it into a buffer
    </li>
  </ul>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-IH-QC.html">Quick Check</a></div>
</div>
</div>

      <div class="knowledge-card">
     <h2>Scheduling algorithms</h2>

  <p>The purpose of scheduling is to:</p>
  <ul>
    <li>Make efficient use of processor time</li>
    <li>Make efficient use of resources</li>
    <li>Maximise the number of users</li>
    <li>Ensure that there is no apparent delay for users</li>
    <li>Maximise throughput of the CPU</li>
  </ul>

  <h3>Why scheduling is used</h3>
  <ul>
    <li>Maximise number of users</li>
    <li>…with no apparent delay</li>
    <li>Maximise number of jobs processed</li>
    <li>…as quickly as possible</li>
    <li>Obtain efficient use of processor time / resources</li>
    <li>…dependent upon priorities</li>
    <li>
      …to ensure all jobs obtain processor time /
      long jobs do not monopolise the processor
    </li>
  </ul>

  <h3>Explain why operating systems use scheduling</h3>
  <ul>
    <li>Ensure all tasks are processed</li>
    <li>…by changing priorities where necessary</li>
    <li>Process as many jobs as possible</li>
    <li>…in the least possible time</li>
    <li>Maximise number of interactive users</li>
    <li>…receiving fast response times</li>
  </ul>

  <h3>
    Round robin scheduling is one method that may be used by a
    <strong>multi-user</strong> operating system.
    Describe round robin scheduling. (3)
  </h3>

  <ul>
    <li>Each user is allocated a time slice</li>
    <li>When the time slice is up, the system moves to the next user</li>
    <li>If the next user needs the processor, they are given a time slice</li>
    <li>Repeat until all users are serviced</li>
    <li>Users may have different priorities</li>
    <li>Time slices are very small (fractions of a second)</li>
    <li>No apparent delay for any user</li>
  </ul>
            <table>
  <thead>
    <tr>
      <th>Algorithm</th>
      <th>Description</th>
      <th>Benefits</th>
      <th>Drawbacks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Round Robin</strong></td>
      <td>
        Each job gets a fixed <strong>time slice</strong>.
        Jobs cycle until completed.
      </td>
      <td>
        <ul>
          <li>All processes get a fair share of the CPU</li>
          <li>Good for time-sharing systems</li>
          <li>Predictable, as every process gets equal time</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Choosing the right time quantum can be difficult</li>
          <li>Can lead to high turnaround and waiting times for long processes</li>
        </ul>
      </td>
    </tr>

    <tr>
      <td><strong>First Come, First Served</strong></td>
      <td>
        Jobs are processed in the <strong>order they arrive</strong>.
      </td>
      <td>
        <ul>
          <li>Simple and easy to understand</li>
          <li>Fair in the sense that jobs are processed in arrival order</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Poor performance if a long job arrives before shorter jobs</li>
          <li>High-priority tasks must wait in the queue</li>
        </ul>
      </td>
    </tr>

    <tr>
      <td><strong>Multi-Level Feedback Queues</strong></td>
      <td>
        Jobs are placed in <strong>different priority queues</strong>;
        jobs can move between queues based on behaviour.
      </td>
      <td>
        <ul>
          <li>Smaller tasks are prioritised</li>
          <li>Groups similar-sized tasks together</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>More complex than other algorithms</li>
          <li>Setting parameters (e.g. number of queues, ageing rules) can be difficult</li>
        </ul>
      </td>
    </tr>

    <tr>
      <td><strong>Shortest Job First (SJF)</strong></td>
      <td>
        Executes jobs with the <strong>shortest total time</strong> first.
      </td>
      <td>
        <ul>
          <li>Minimises waiting time</li>
          <li>Efficient for short processes</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Requires knowing burst time in advance</li>
          <li>Long processes may starve</li>
        </ul>
      </td>
    </tr>

    <tr>
      <td><strong>Shortest Time Remaining</strong></td>
      <td>
        Preemptive version of SJF;
        always runs the job with the <strong>least time left</strong>.
      </td>
      <td>
        <ul>
          <li>Ideal for short burst-time jobs</li>
          <li>Preemptive, allowing better CPU utilisation</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Requires knowing burst time in advance</li>
          <li>High context-switching overhead due to preemption</li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-scheduling-QC.html">Quick Check</a></div>
</div>

</div>

      <div class="knowledge-card">


  <h2>Virtual Machines</h2>

  <ul>
    <li>
      Virtual machines (VMs) are entire operating systems running
      inside another operating system </li>


  </ul>

  <table>
    <thead>
      <tr>
        <th>Benefits</th>
        <th>Drawbacks</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <ul>
            <li>
              Virtual machines (VMs) are entire operating systems running
              inside another operating system
            </li>
            <li>
              Allows running different operating systems
              (e.g. Linux on Windows) simultaneously on a single machine
            </li>
            <li>
              VMs are a way to create isolated test environments that leave
              the host operating system unaffected
            </li>
            <li>
              Multiple VMs can run on one physical machine, maximising
              hardware usage and reducing the need for multiple
              physical devices
            </li>
            <li>
              Ideal for running potentially unsafe software or malware
              for analysis in a controlled environment
            </li>
          </ul>
        </td>

        <td>
          <ul>
            <li>
              VMs are slower than physical machines because resources
              (CPU, RAM, disk) are shared with the host system and other VMs
            </li>
            <li>
              Running multiple VMs can consume significant system resources,
              leading to slower performance or system crashes if not
              managed properly
            </li>
          </ul>
        </td>
      </tr>
    </tbody>
  </table>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-vm-QC.html">Quick Check</a></div>
</div>

 </div>

       <div class="knowledge-card">
  <h2>Device Drivers</h2>

  <ul>
    <li>
      A device driver is a piece of software that enables communication
      between an operating system and specific hardware devices such as:
      <ul>
        <li>Printers</li>
        <li>Graphics cards</li>
        <li>Network cards</li>
      </ul>
    </li>

    <li>
      Device drivers allow the operating system to control and interact
      with those devices
    </li>

    <li>
      Because many external devices have embedded system software,
      a driver bridges the gap between a major operating system and
      a small hardware operating system
    </li>

    <li>
      Device drivers make it possible to perform specific operations
      on the hardware, e.g. a printer driver enables the operating
      system to send print commands and manage print jobs
    </li>

    <li>
      Most hardware manufacturers write their own device driver
      software, meaning a single operating system may have several
      printer drivers installed
    </li>
  </ul>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-software-device-QC.html">Quick Check</a></div>
</div>

</div>
 </div>
</div>

    <button id="printBtn" type="button">
  Print this worksheet
</button>
</main>

<footer>
    © <span id="year"></span> StudyHub CS
  </footer>
<script src="../js/booklets.js"></script>
<div id="command-words"></div>

<!-- PDF MODAL -->
<div id="pdfModal">
  <div class="pdf-modal-content">
    <iframe id="pdfFrame"></iframe>
  </div>
</div>

</body>
</html>