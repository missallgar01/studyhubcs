<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hardware – Revision Page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../css/main.css" />

</head>
<style>

.highlight {
  background: #1273da !important;
  color: black !important;
}

.mid-highlight {
  background: #00bfff !important;
  color: black !important;
  box-shadow: 0 0 12px #00bfff !important;
}

.compare-highlight {
  background: #1273da !important;
  color: black !important;
}

.swap-highlight {
  background: #00bfff !important;
  color: black !important;
  box-shadow: 0 0 10px #00bfff !important;
}

.array-container {
  display: grid;
  justify-content: center;
  margin: 20px 0;
  border: 2px solid black;
}

.array-row {
  display: grid;
  grid-auto-flow: column;
  justify-content: center;
    color: black;
}

.array-box {
  width: 50px;
  height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  border: 1px solid black;
  background: white;
  color: black;
}

.index-label {
  width: 50px;
  text-align: center;
  font-size: 12px;
  border: 1px solid black;
  background: #f4f4f4;
}

</style>
<body>

<header>
  <h1>Algorithms – Study Notes</h1>

</header>

<main>

 <div class="vertical-knowledge">

        <div class="knowledge-card">
          <h3>Linear Search Algorithm</h3>

          <p>
            A <strong>linear search</strong> is a <strong>very simple searching algorithm</strong>.
            It is often described as a <strong>brute force</strong> method because it checks
            <strong>every item</strong> in a list until the required data is found or the end
            of the list is reached.
          </p>
        <figure><img src="images/algorithms/linear.gif" width="50%"/></figure>
          <p>
            The search starts at the <strong>beginning of the array or list</strong> and moves
            through it <strong>item by item</strong>. The linear search is
            <strong>sequential</strong>.
          </p>

          <p><strong>Steps for a linear search:</strong></p>
          <ol>
            <li>Start at the first item in the list</li>
            <li>Compare the item with the search value</li>
            <li>If they are the same, stop the search</li>
            <li>If they are not the same, move to the next item</li>
            <li>Repeat until the item is found or the end of the list is reached</li>
          </ol>

          <p>
            If the search reaches the end of the list without finding the item,
            the program reports that the item was <strong>not found</strong>.
          </p>
         </div>

        <div class="knowledge-card">
<h3>Linear Search Step-Through Visualiser</h3>

<pre id="linearCode">
1 alist = [1, 2, 5, 7, 11, 14]
2 position = 0
3 found = False
4 item = input()
5 WHILE position < length AND found == False
6     IF item == alist[position] THEN
7         print("Item found")
8         found = True
9     ELSE
10        position = position + 1
11    ENDIF
12 END WHILE
13 IF found == False THEN
14     print("Item not found")
15 ENDIF
</pre>

<input id="linearArray" value="10,8,1,21,7,32,5,11,0">
<input id="linearTarget" value="5">
<button onclick="startLinear()">Start</button>
<button onclick="nextLinear()">Next Step</button>

<div id="linearVisual" class="array-container"></div>

<table id="linearTable">
<thead>
<tr>
<th>Step</th>
<th>Position</th>
<th>Value</th>
<th>Comparison</th>
<th>Found</th>
</tr>
</thead>
<tbody></tbody>
</table>
</div>

        <div class="knowledge-card">
          <h3>Binary Search Algorithm</h3>

          <p>
            A <strong>binary search</strong> is a <strong>divide and conquer</strong> algorithm.
            It works by repeatedly splitting a list in half to find a target value.
          </p>

          <p>
            For a binary search to work, the <strong>list must be sorted</strong>.
          </p>

          <figure><img src="images/algorithms/binary.png" width="50%"/></figure>


          <p><strong>Steps for a binary search:</strong></p>
          <ol>
            <li>Sort the list</li>
            <li>Find the midpoint of the list</li>
            <li>If the search item is found, stop</li>
            <li>If the search item is less than the midpoint, search the left sub-list</li>
            <li>If the search item is greater than the midpoint, search the right sub-list</li>
            <li>Repeat until the item is found</li>
          </ol>

          <p>
            The midpoint is found by adding the start and end index values and using
            <strong>DIV</strong> to return a whole number (rounded down).
          </p>

          <p><strong>Example:</strong> <code>mid = (start + end) DIV 2</code></p>

         </div>

        <div class="knowledge-card">
<h2>Binary SearchStep-Through Visualiser</h2>

<pre id="binaryCode">
1 alist = [1,2,5,7,11,14]
2 item = input()
3 found = False
4 first = 0
5 last = length - 1
6 WHILE found == False AND first <= last
7     midPoint = (first + last) DIV 2
8     IF item == alist[midPoint] THEN
9         print("Item found at location", midPoint)
10        found = True
11    ELSE
12        IF item < alist[midPoint] THEN
13            last = midPoint - 1
14        ELSE
15            first = midPoint + 1
16        ENDIF
17    ENDIF
18 END WHILE
19 IF found == False THEN
20     print("Item not found")
21 ENDIF
</pre>

<input id="binaryArray" value="1,2,5,7,11,14">
<input id="binaryTarget" value="7">

<button onclick="startBinary()">Start</button>
<button onclick="nextBinary()">Next Step</button>

<h4>Array (with Index)</h4>
<div id="binaryVisual" class="array-container"></div>

<table id="binaryTable">
<thead>
<tr>
<th>Step</th>
<th>First</th>
<th>Last</th>
<th>MidPoint</th>
<th>Value</th>
<th>Compare</th>
<th>Found</th>
</tr>
</thead>
<tbody></tbody>
</table>


<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-algorithms-searching-QC.html">Quick Check</a></div>
</div>

</div>

        <div class="knowledge-card">
            <p><strong>Efficiency of searching algorithms:</strong></p>
          <h3>Efficiency of Searching Algorithms</h3>
        <figure><img src="images/algorithms/img_binarysearch_timecomplexity.png" height="444" width="505"/></figure>
          <table>
            <thead>
              <tr>
                <th>Linear</th>
                <th>Binary</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  Checks against each item until match using brute force, making it a slow algorithm.<br><br>
                  Works well on small, unsorted lists<br><br>
                  It can be improved by sorting the list first and can find an item quicker.<br><br>
                  Program requires less code
                </td>
                <td>
                  Splits lists and checks each half using divide and conquer<br><br>
                  List must be <strong>sorted</strong><br><br>
                  Much quicker than a linear search because the data that needs to be searched halves with each step.<br><br>
                  Program requires more code
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="knowledge-card">
          <h3>Bubble Sort Algorithm</h3>

          <p><strong>Describe the steps of the bubble sort:</strong></p>
        <figure><img src="images/algorithms/bubble.jpg" width="50%"/></figure>
          <ol>
            <li>Start at the beginning of the list.</li>
            <li>
              <strong>Compare</strong> the first value with the next value.
              If the first value is larger, <strong>swap</strong> the two values.
            </li>
            <li>
              Move to the <strong>next value</strong> in the list and compare it with the one after it.
              Swap if the value is bigger.
            </li>
            <li>
              Continue until there are <strong>no more items to compare</strong>.
            </li>
            <li>
              Go back to the <strong>start of the list</strong>.
            </li>
            <li>
              <strong>Repeat until no swaps are made</strong>.
            </li>
          </ol>

          <p>
            Each complete run through the list is called a <strong>pass</strong>.
          </p>

          <p>
            The bubble sort continues until a full pass is made with
            <strong>no values swapped</strong>. At this point, the list is sorted.
          </p>
        </div>

        <div class="knowledge-card">
<h2>Bubble Sort Step-Through Visualiser</h2>

<pre id="bubbleCode">
1 swapMade = True
2 WHILE swapMade == True
3     swapMade = False
4     FOR position = 0 TO listLength - 2
5         IF list[position] > list[position+1] THEN
6             temp = list[position]
7             list[position] = list[position+1]
8             list[position+1] = temp
9             swapMade = True
10        ENDIF
11    END FOR
12 END WHILE
</pre>

<input id="bubbleArray" value="7,4,2,9,1">
<button onclick="startBubble()">Start</button>
<button onclick="nextBubble()">Next Step</button>

<h3>Array (with Index)</h3>
<div id="bubbleVisual"  class="array-container"></div>

<table id="bubbleTable">
<thead>
<tr>
<th>Step</th>
<th>Position</th>
<th>Comparison</th>
<th>Swap Made</th>
<th>Array State</th>
</tr>
</thead>
<tbody></tbody>
</table>

</div>

        <div class="knowledge-card">
  <h3>Insertion Sort Algorithm</h3>

  <p>
    <strong>Insertion sort</strong> works by building a sorted section of the list
    one item at a time.
  </p>

  <p>
    It takes each item and <strong>inserts it into the correct position</strong>
    in the part of the list that is already sorted.
  </p>

  <ol>
    <li>Start from the second item in the list.</li>
    <li>Store the current value.</li>
    <li>Compare it with values before it.</li>
    <li>Shift larger values to the right.</li>
    <li>Insert the value in the correct position.</li>
    <li>Repeat until the list is sorted.</li>
  </ol>

        <figure><img src="images/algorithms/insertion.jpg" height="300" width="500"/></figure>
</div>

        <div class="knowledge-card">
<h2>Insertion Sort Step-Through Visualiser</h2>

<pre id="insertionCode">
1 FOR i = 1 TO listLength - 1
2     key = list[i]
3     j = i - 1
4     WHILE j >= 0 AND list[j] > key
5         list[j + 1] = list[j]
6         j = j - 1
7     END WHILE
8     list[j + 1] = key
9 END FOR
</pre>

<input id="insertionArray" value="7,4,2,9,1">
<button onclick="startInsertion()">Start</button>
<button onclick="nextInsertion()">Next Step</button>

<h3>Array (with Index)</h3>
<div id="insertionVisual" class="array-container"></div>

<table id="insertionTable">
<thead>
<tr>
<th>Step</th>
<th>i</th>
<th>j</th>
<th>Key</th>
<th>Array State</th>
</tr>
</thead>
<tbody></tbody>
</table>

</div>

        <div class="knowledge-card">
          <h3>Merge Sort</h3>

          <p>
            Merge sort can be used efficiently on very large lists of data.
            It uses a <strong>divide and conquer</strong> approach.
          </p>

          <h4>How Merge Sort Works</h4>
          <ol>
            <li>Split the list into sub-arrays of one element.</li>
            <li>Merge each sub-array into a new sorted array.</li>
            <li>Repeat until a single sorted array is produced.</li>
          </ol>


            <img src="images/algorithms/merge.png" width="50%"/>
            <p><strong>Output:</strong> A sorted array</p>

          <h4>Algorithm (High-Level Steps)</h4>
          <pre>
        Step 1: Split the array into sub-arrays of 1 element
        Step 2: Merge sub-arrays into sorted arrays
        Step 3: Repeat merging until one sorted array remains
          </pre>

          <h4>Merge Sort (Recursive Pseudocode)</h4>
          <pre>
        function mergeSort(list)
          if LENGTH(list) <= 1 then
            return list
          endif

          mid = LENGTH(list) DIV 2
          left = list[0 : mid]
          right = list[mid : LENGTH(list)]

          leftSorted = mergeSort(left)
          rightSorted = mergeSort(right)

          return merge(leftSorted, rightSorted)
        endfunction
          </pre>

          <h4>Merge Procedure (Pseudocode)</h4>
          <pre>
        function merge(left, right)
          result = empty list

          WHILE left not empty AND right not empty
            IF left[0] <= right[0] THEN
              add left[0] to result
              remove left[0] from left
            ELSE
              add right[0] to result
              remove right[0] from right
            ENDIF
          ENDWHILE

          add remaining elements of left to result
          add remaining elements of right to result

          return result
        endfunction
          </pre>

          <h4>Advantages</h4>
          <ul>
            <li>Very high performance on large lists.</li>
            <li>Consistent speed regardless of initial order.</li>
          </ul>

          <h4>Disadvantages</h4>
          <ul>
            <li>Uses a lot of additional memory.</li>
            <li>More complex to implement than simple sorts.</li>
          </ul>

          <p>
            <strong>Complexity:</strong>
            <code>O(n log n)</code> — logarithmic
            <br>
            Merge sort is substantially faster than bubble sort
            and selection sort for large data sets.
          </p>
        </div>

        <div class="knowledge-card">
          <h3>Quick Sort</h3>

          <p>
            Quick sort uses a <strong>divide-and-conquer</strong> approach.
            It works by selecting a pivot value and partitioning the list
            into values less than the pivot and values greater than the pivot.
          </p>

          <h4>How Quick Sort Works</h4>
          <ul>
            <li>Choose a pivot value (often the first element)</li>
            <li>Use a left pointer and a right pointer</li>
            <li>Move pointers inward, swapping values where required</li>
            <li>Place the pivot in its correct position</li>
            <li>Repeat on the left and right sublists</li>
          </ul>

            <img src="images/algorithms/quick.jpg" width="50%"/><h4>Algorithm </h4>

        <h3>Quick Sort (First Element as Pivot)</h3>

<pre id="quickCode">
1 PROCEDURE quickSort(list, low, high)
2     // Only sort if there is more than one item
3     IF low < high THEN
4         // Partition the list and find the pivot position
5         pivotIndex = partition(list, low, high)
6
7         // Recursively sort the left sub-list
8         quickSort(list, low, pivotIndex - 1)
9
10        // Recursively sort the right sub-list
11        quickSort(list, pivotIndex + 1, high)
12    ENDIF

13 FUNCTION partition(list, low, high)
14    // Choose the first element as the pivot
15    pivot = list[low]
16
17    // Set pointers
18    left = low + 1
19    right = high
20
21    // Move pointers until they cross
22    WHILE left <= right
23
24        // Move left pointer right while values are smaller than pivot
25        WHILE list[left] <= pivot
26            left = left + 1
27        END WHILE
28
29        // Move right pointer left while values are larger than pivot
30        WHILE list[right] > pivot
31            right = right - 1
32        END WHILE
33
34        // Swap values if left pointer is still before right pointer
35        IF left < right THEN
36            swap(list[left], list[right])
37        ENDIF
38
39    END WHILE
40
41    // Place pivot in its correct sorted position
42    swap(list[low], list[right])
43
44    // Return the pivot's final index
45    RETURN right
</pre>

          <h4>Advantages</h4>
          <ul>
            <li>Much faster than bubble sort and insertion sort on large lists</li>
            <li>Efficient average-case performance</li>
          </ul>

          <h4>Disadvantages</h4>
          <ul>
            <li>
              Uses recursion, which can require large amounts of memory
            </li>
            <li>
              Risk of stack overflow for very large lists or poor pivot choices
            </li>
          </ul>

          <p>
            <strong>Complexity:</strong>
            <code>O(n log n)</code> — logarithmic (average case)
          </p>

          <h4>Mark Scheme Points (Typical)</h4>
          <ul>
            <li>Uses divide-and-conquer</li>
            <li>Selects a pivot value</li>
            <li>Uses left and right pointers</li>
            <li>Swaps values when required</li>
            <li>Splits list into two sublists</li>
            <li>Recursively sorts sublists</li>
            <li>Repeats until all sublists contain one element</li>
          </ul>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-algorithms-sorting-QC.html">Quick Check</a></div>
</div>
        </div>

        <div class="knowledge-card">
  <h3>Efficiency of Sorting Algorithms</h3>

  <p>
    The <strong>efficiency</strong> of a sorting algorithm describes how its
    performance changes as the size of the list increases.
  </p>

  <p>
    Efficiency is measured using <strong>Big-O notation</strong>.
    Big-O shows how the number of operations grows as
    <em>n</em> (the number of items in the list) increases.
  </p>

  <h4>What Is Time Complexity?</h4>
  <p>
    <strong>Time complexity</strong> describes how the number of comparisons
    or operations increases as the list gets larger.
  </p>

  <ul>
    <li>
      <strong>O(n)</strong> – Linear growth.
      If the list doubles, the work roughly doubles.
    </li>
    <li>
      <strong>O(n²)</strong> – Quadratic growth.
      If the list doubles, the work becomes about four times larger.
      This becomes very slow for large lists.
    </li>
    <li>
      <strong>O(n log n)</strong> – Efficient growth.
      Much faster than O(n²) for large data sets.
    </li>
  </ul>

  <h4>What Is Space Complexity?</h4>
  <p>
    <strong>Space complexity</strong> describes how much extra memory
    an algorithm needs.
  </p>

  <ul>
    <li>Bubble Sort – O(1) (no extra list needed)</li>
    <li>Insertion Sort – O(1)</li>
    <li>Merge Sort – O(n) (uses extra lists)</li>
  </ul>

  <h4>Sorting Algorithm Comparison</h4>

  <table>
    <thead>
      <tr>
        <th>Algorithm</th>
        <th>Time Complexity</th>
        <th>Space Complexity</th>
        <th>Efficient for Large Lists?</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Bubble Sort</td>
        <td>O(n²)</td>
        <td>O(1)</td>
        <td>No</td>
      </tr>
      <tr>
        <td>Insertion Sort</td>
        <td>O(n²)</td>
        <td>O(1)</td>
        <td>No (unless nearly sorted)</td>
      </tr>
      <tr>
        <td>Merge Sort</td>
        <td>O(n log n)</td>
        <td>O(n)</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>Quick Sort</td>
        <td>O(n log n) average</td>
        <td>O(log n)</td>
        <td>Yes</td>
      </tr>
    </tbody>
  </table>

  <h4>Key Exam Points</h4>
  <ul>
    <li>O(n²) algorithms become very slow for large data sets.</li>
    <li>O(n log n) algorithms are more efficient and preferred for large lists.</li>
    <li>Merge sort is faster but uses more memory.</li>
    <li>Insertion sort can be efficient if the list is nearly sorted.</li>
    <li>Big-O describes growth rate, not exact speed in seconds.</li>
  </ul>
</div>

        <div class="knowledge-card">
  <h3>Sorting Algorithm Time Complexity Comparison</h3>

  <p>
    This graph compares how the running time increases as the number of values (n) grows.
  </p>

  <svg width="750" height="420" style="background:#f4f4f4;">

    <!-- Axes -->
    <line x1="60" y1="370" x2="700" y2="370" stroke="black" stroke-width="2"/>
    <line x1="60" y1="370" x2="60" y2="40" stroke="black" stroke-width="2"/>

    <!-- Axis Labels -->
    <text x="320" y="405" font-size="14">Number of values (n)</text>
    <text x="15" y="220" font-size="14" transform="rotate(-90 20,220)">Time</text>

    <!-- Bubble Sort O(n²) -->
    <path d="M60 370 Q 200 310 320 220 T 700 60"
          fill="none"
          stroke="#d62728"
          stroke-width="3" />
    <text x="520" y="85" fill="#d62728" font-size="14">
      Bubble Sort – O(n²)
    </text>

    <!-- Insertion Sort O(n²) -->
    <path d="M60 370 Q 200 330 320 260 T 700 110"
          fill="none"
          stroke="#ff7f0e"
          stroke-width="3" />
    <text x="520" y="125" fill="#ff7f0e" font-size="14">
      Insertion Sort – O(n²)
    </text>

    <!-- Merge Sort O(n log n) -->
    <path d="M60 370 Q 200 330 320 290 T 700 200"
          fill="none"
          stroke="#1f77b4"
          stroke-width="3" />
    <text x="500" y="215" fill="#1f77b4" font-size="14">
      Merge Sort – O(n log n)
    </text>

    <!-- Quick Sort O(n log n) average -->
    <path d="M60 370 Q 200 320 320 280 T 700 180"
          fill="none"
          stroke="#9467bd"
          stroke-width="3"
          stroke-dasharray="6,4" />
    <text x="500" y="175" fill="#9467bd" font-size="14">
      Quick Sort – O(n log n) average
    </text>

  </svg>

  <h4>What This Shows</h4>
  <ul>
    <li><strong>Bubble and Insertion</strong> are O(n²) and become slow for large lists.</li>
    <li><strong>Merge and Quick</strong> are O(n log n) and are much more efficient.</li>
    <li>The gap between O(n²) and O(n log n) becomes very large as n increases.</li>
  </ul>

  <h4>Key GCSE Comparison Points</h4>
  <ul>
    <li>Bubble Sort – Simple but inefficient.</li>
    <li>Insertion Sort – Better for nearly sorted lists.</li>
    <li>Merge Sort – Fast and consistent but uses extra memory.</li>
    <li>Quick Sort – Usually the fastest in practice.</li>
  </ul>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-algorithms-efficiency-QC.html">Quick Check</a></div>
</div>

</div>

        <div class="knowledge-card">
          <h3>Shortest Path Algorithms</h3>
          <p>
            Shortest path algorithms are used to find the minimum-cost path between
            nodes in a graph. The “cost” may represent distance, time, or any weighted
            value on the edges.
          </p>
          <p>
            Common shortest path algorithms include:
          </p>
          <ul>
            <li>
              <strong>Dijkstra’s Algorithm</strong> – Finds the shortest path from a
              single start node to all other nodes in a graph with non-negative edge
              weights. It repeatedly selects the unvisited node with the smallest
              tentative distance.
            </li>
            <li>
              <strong>A* (A-star) Algorithm</strong> – An extension of Dijkstra’s
              algorithm that uses a heuristic to estimate the remaining distance to the
              goal. This helps it find the shortest path more efficiently by exploring
              promising routes first.
            </li>
            <li>
              <strong>Breadth-First Search (BFS)</strong> – Can be used as a shortest
              path algorithm in unweighted graphs, as it explores nodes level by level.
            </li>
          </ul>
          <p>
            These algorithms are widely used in navigation systems, games, network
            routing, and AI to determine the most efficient route between locations.
          </p>
        </div>

        <div class="knowledge-card">
        <h3>Find the shortest path from A to J using Dijkstra’s Algorithm</h3>

        <p>
            <ul>
              <li>The purpose of Dijkstra's algorithm finds the shortest path between nodes / vertices in a weighted graph.</li>
              <li>Selects the unvisited node with the shortest path.</li>
              <li>Calculates the distance to each unvisited neighbor</li>
              <li>Updates the distance of each unvisited neighbor if smaller</li>
              <li><mark>Once all neighbours have been visited mark node as visited</mark></li>
            </ul>

           <p>Algorithm</p>
        <pre>
        # Next Current Node will be the node with the lower F value
        Mark the start node as a distance of 0 from itself and all other nodes as an infinite distance
                  from the start node.

        WHILE the destination node is unvisited:

              Go to the closest unvisited node to A (initially this will be A itself)

              Call this the current node.

              FOR every unvisited node connected to current node

                Calculate the distance to the current plus the distance of the edge to unvisited
                If this distance is less than the currently recorded shortest distance, make it the new shortest distance.


              NEXT Connected node

              Mark the current node as visited.

        ENDWHILE
        </pre>

         <img src="images/algorithms/dijkstras.png" height="345" width="706"/>

         <p><strong>Visited order:</strong> A → C → F → G → D → E → H → I → J</p>

             <table class="dijkstra-table">
          <thead>
            <tr>
              <th>Node</th>
              <th>Distance from A</th>
              <th>Previous Node</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>A (v)</td>
              <td>0</td>
              <td>-</td>
            </tr>
            <tr>
              <td>B (v)</td>
              <td>∞ 75</td>
              <td>A</td>
            </tr>
            <tr>
              <td>C (v)</td>
              <td>∞ 10</td>
              <td>A</td>
            </tr>
            <tr>
              <td>D (v)</td>
              <td>∞ 95, 80</td>
              <td>F, B</td>
            </tr>
            <tr>
              <td>E (v)</td>
              <td>∞ 65</td>
              <td>C</td>
            </tr>
            <tr>
              <td>F (v)</td>
              <td>∞ 40</td>
              <td>C</td>
            </tr>
            <tr>
              <td>G (v)</td>
              <td>∞ 50</td>
              <td>F</td>
            </tr>
            <tr>
              <td>H (v)</td>
              <td>∞ 90</td>
              <td>G</td>
            </tr>
            <tr>
              <td>I (v)</td>
              <td>∞ 90</td>
              <td>D</td>
            </tr>
            <tr>
              <td>J (c)</td>
              <td>∞ 135, 105</td>
              <td>E, H</td>
            </tr>
          </tbody>
        </table>

             <p>Final shortest path:</strong> A → C → F → G → H → J</p>

        </div>

        <div class="knowledge-card">
            <h3><strong>A*</strong></h3>
        <p>
                The A* Algorithm is a general path-finding algorithm which is an
                improvement of Dijkstra’s Algorithm.</p>
        <p>The structure in graph is searched using the A* algorithm making use of the heuristic values </p>

        <p>Heuristic values are Weighting/cost based on estimated distance from final node.
            The purpose of heuristic values in the A* algorithm are used to speed up process of finding solution.</p>


                <p>A <strong>heuristic</strong> is also used – usually an approximate
                distance from a node to the final node.
              </p>

              <p>
                This aims to make the shortest path finding process more
                efficient and much quicker.
              </p>

              <p>
                How effective the A* algorithm is, however, depends largely on
                the accuracy of the heuristics used.
              </p>

              <p>
                Will not visit all nodes.
                Will follow the route with the lowest F value
              </p>

              <p>
                Stops when current node is the destination node
              </p>


        <pre>
        Begin at the start node and make this the current node.
        WHILE the destination node is unvisited:

             For each open node directly connected to the current node:

             Add to the list of open nodes

             Add the distance from the start (g) to the heuristic estimate of the distance (h)

             Assign this value (f) to the node

             NEXT connected node

             Make the unvisited node with the lowest F value the current node

        ENDWHILE

        </pre>

            <p><img src="images/algorithms/Astar.png" height="343" width="750"/></p>


        <table>
          <thead>
            <tr>
              <th>Node</th>
              <th>Distance travelled (g)</th>
              <th>Heuristic (h)</th>
              <th>Distance + Heuristic (f)</th>
              <th>Previous node</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>H</td>
              <td>0</td>
              <td>80</td>
              <td>80</td>
              <td>-</td>
            </tr>
            <tr>
              <td>G</td>
              <td>25</td>
              <td>70</td>
              <td>95</td>
              <td>H</td>
            </tr>
            <tr>
              <td>N</td>
              <td>210</td>
              <td>90</td>
              <td>300</td>
              <td>H</td>
            </tr>
            <tr>
              <td>L</td>
              <td>51 + 25 = 76</td>
              <td>50</td>
              <td>126</td>
              <td>G</td>
            </tr>
            <tr>
              <td>M</td>
              <td>176 + 25 = 201</td>
              <td>20</td>
              <td>221</td>
              <td>G</td>
            </tr>
            <tr>
              <td>E</td>
              <td>307 +  76 = 383</td>
              <td>0</td>
              <td>383</td>
              <td>L</td>
            </tr>
          </tbody>
        </table>

               <p>Final path: H → G → L → E</p>

<div class="truthtable">
    <div class="links"><a class="btn" data-file="../A-activity/A-algorithms-shorest-path-QC.html">Quick Check</a></div>
</div>

</div>

</div>

 <button id="printBtn" type="button">
  Print this worksheet
</button>


</main>


<footer>
    © <span id="year"></span> StudyHub CS
  </footer>
<script>
/* =========================================================
   UNIVERSAL HIGHLIGHT FUNCTION
========================================================= */

function highlight(codeId, line){
  const lines = document.getElementById(codeId).innerText.split("\n");
  document.getElementById(codeId).innerHTML =
    lines.map((l,i)=>`<div class="${i+1===line?'highlight':''}">${l}</div>`).join("");
}

/* =========================================================
   LINEAR SEARCH
========================================================= */

let linearData = [];
let linearPosition = 0;
let linearFound = false;
let linearItem;
let linearStep = 1;
let linearFinished = false;

function renderLinear(highlightIndex = -1) {
  const container = document.getElementById("linearVisual");
  container.innerHTML = "";

  const indexRow = document.createElement("div");
  indexRow.className = "array-row";

  const valueRow = document.createElement("div");
  valueRow.className = "array-row";

  linearData.forEach((value, index) => {

    // Index cell
    const indexCell = document.createElement("div");
    indexCell.className = "index-label";
    indexCell.innerText = index;
    indexRow.appendChild(indexCell);

    // Value cell
    const box = document.createElement("div");
    box.className = "array-box";
    box.innerText = value;

    if (index === highlightIndex) {
      box.classList.add("highlight");   // light blue
    }

    valueRow.appendChild(box);
  });

  container.appendChild(indexRow);
  container.appendChild(valueRow);
}

function startLinear(){
  linearData = document.getElementById("linearArray").value.split(",").map(Number);
  linearItem = Number(document.getElementById("linearTarget").value);

  linearPosition = 0;
  linearFound = false;
  linearStep = 1;
  linearFinished = false;

  document.querySelector("#linearTable tbody").innerHTML = "";
  renderLinear();
  highlight("linearCode", 3);
}

function nextLinear(){
  if (linearFinished) return;

  if (linearPosition < linearData.length && !linearFound) {

    highlight("linearCode", 5);
    renderLinear(linearPosition);

    const value = linearData[linearPosition];

    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${linearStep++}</td>
      <td>${linearPosition}</td>
      <td>${value}</td>
      <td>${value === linearItem ? "=" : "≠"} ${linearItem}</td>
      <td>${linearFound}</td>
    `;
    document.querySelector("#linearTable tbody").appendChild(row);

    if (value === linearItem) {
      highlight("linearCode", 6);
      linearFound = true;
      linearFinished = true;
    } else {
      highlight("linearCode", 9);
      linearPosition++;
    }

  } else {
    highlight("linearCode", 12);
    linearFinished = true;
  }
}

/* =========================================================
   BINARY SEARCH
========================================================= */

let binaryData = [];
let binaryFirst, binaryLast, binaryMid;
let binaryItem;
let binaryFound = false;
let binaryStep = 1;
let binaryFinished = false;

function renderBinary(mid = -1){
  const container = document.getElementById("binaryVisual");
  container.innerHTML = "";

  const indexRow = document.createElement("div");
  indexRow.className = "array-row";

  const valueRow = document.createElement("div");
  valueRow.className = "array-row";

  binaryData.forEach((value,index)=>{

    // Index cell
    const indexCell=document.createElement("div");
    indexCell.className="index-label";
    indexCell.innerText=index;
    indexRow.appendChild(indexCell);

    // Value cell
    const box=document.createElement("div");
    box.className="array-box";
    box.innerText=value;

    if(index===mid){
      box.classList.add("mid-highlight");
    }

    valueRow.appendChild(box);
  });

  container.appendChild(indexRow);
  container.appendChild(valueRow);
}

function startBinary(){
  binaryData=document.getElementById("binaryArray").value.split(",").map(Number);
  binaryItem=Number(document.getElementById("binaryTarget").value);

  binaryFirst=0;
  binaryLast=binaryData.length-1;
  binaryFound=false;
  binaryStep=1;
  binaryFinished=false;

  document.querySelector("#binaryTable tbody").innerHTML="";
  renderBinary();
  highlight("binaryCode",3);
}

function nextBinary(){
  if(binaryFinished) return;

  if(!binaryFound && binaryFirst<=binaryLast){

    highlight("binaryCode",7);

    binaryMid=Math.floor((binaryFirst+binaryLast)/2);
    renderBinary(binaryMid);

    const sum=binaryFirst+binaryLast;

    const row=document.createElement("tr");
    row.innerHTML=`
      <td>${binaryStep++}</td>
      <td>${binaryFirst}</td>
      <td>${binaryLast}</td>
      <td>
        (${binaryFirst}+${binaryLast}) DIV 2<br>
        = ${sum} DIV 2<br>
        = ${binaryMid}
      </td>
      <td>${binaryData[binaryMid]}</td>
      <td>${binaryItem===binaryData[binaryMid]?"=":(binaryItem<binaryData[binaryMid]?"<":">")}</td>
      <td>${binaryFound}</td>
    `;
    document.querySelector("#binaryTable tbody").appendChild(row);

    if(binaryItem===binaryData[binaryMid]){
      highlight("binaryCode",9);
      binaryFound=true;
      binaryFinished=true;
    }else{
      highlight("binaryCode",12);
      if(binaryItem<binaryData[binaryMid]){
        highlight("binaryCode",13);
        binaryLast=binaryMid-1;
      }else{
        highlight("binaryCode",15);
        binaryFirst=binaryMid+1;
      }
    }

  }else{
    highlight("binaryCode",19);
    binaryFinished=true;
  }
}

/* =========================================================
   BUBBLE SORT (FULL FIXED VERSION)
========================================================= */

let bubbleData=[];
let bubbleSwapMade;
let bubblePosition;
let bubbleStep=1;
let bubbleFinished=false;
let bubbleInPass=false;

let bubbleSwapping=false;
let bubbleSwapStage=0;
let bubbleTemp=null;

function renderBubble(highlights = []) {
  const container = document.getElementById("bubbleVisual");
  container.innerHTML = "";

  const indexRow = document.createElement("div");
  indexRow.className = "array-row";

  const valueRow = document.createElement("div");
  valueRow.className = "array-row";

  bubbleData.forEach((value, index) => {

    // Index cell
    const indexCell = document.createElement("div");
    indexCell.className = "index-label";
    indexCell.innerText = index;
    indexRow.appendChild(indexCell);

    // Value cell
    const box = document.createElement("div");
    box.className = "array-box";
    box.innerText = value;

    if (highlights.includes(index)) {
      box.classList.add("highlight");   // light blue
    }

    valueRow.appendChild(box);
  });

  container.appendChild(indexRow);
  container.appendChild(valueRow);
}

function startBubble(){
  bubbleData=document.getElementById("bubbleArray").value.split(",").map(Number);

  bubbleSwapMade=true;
  bubblePosition=0;
  bubbleStep=1;
  bubbleFinished=false;
  bubbleInPass=false;
  bubbleSwapping=false;
  bubbleSwapStage=0;

  document.querySelector("#bubbleTable tbody").innerHTML="";
  renderBubble();
  highlight("bubbleCode",1);
}

function nextBubble(){
  if(bubbleFinished) return;

  if(!bubbleInPass && !bubbleSwapping){

    if(!bubbleSwapMade){
      highlight("bubbleCode",12);
      bubbleFinished=true;
      return;
    }

    highlight("bubbleCode",3);
    bubbleSwapMade=false;
    bubblePosition=0;
    bubbleInPass=true;
    return;
  }

  if(bubbleSwapping){

    if(bubbleSwapStage===1){
      highlight("bubbleCode",6);
      bubbleTemp=bubbleData[bubblePosition];
      bubbleSwapStage++;
      return;
    }

    if(bubbleSwapStage===2){
      highlight("bubbleCode",7);
      bubbleData[bubblePosition]=bubbleData[bubblePosition+1];
      renderBubble([bubblePosition,bubblePosition+1]);
      bubbleSwapStage++;
      return;
    }

    if(bubbleSwapStage===3){
      highlight("bubbleCode",8);
      bubbleData[bubblePosition+1]=bubbleTemp;
      renderBubble([bubblePosition,bubblePosition+1]);
      bubbleSwapStage++;
      return;
    }

    if(bubbleSwapStage===4){
      highlight("bubbleCode",9);
      bubbleSwapMade=true;

      const row=document.createElement("tr");
      row.innerHTML=`
        <td>${bubbleStep++}</td>
        <td>${bubblePosition}</td>
        <td>SWAP</td>
        <td>${bubbleSwapMade}</td>
        <td>${bubbleData.join(", ")}</td>
      `;
      document.querySelector("#bubbleTable tbody").appendChild(row);

      bubbleSwapping=false;
      bubbleSwapStage=0;
      bubblePosition++;
      return;
    }
  }

  if(bubblePosition<bubbleData.length-1){

    highlight("bubbleCode",5);
    renderBubble([bubblePosition,bubblePosition+1]);

    const comparison=`${bubbleData[bubblePosition]} > ${bubbleData[bubblePosition+1]}`;

    if(bubbleData[bubblePosition]>bubbleData[bubblePosition+1]){
      bubbleSwapping=true;
      bubbleSwapStage=1;
      return;
    }else{
      const row=document.createElement("tr");
      row.innerHTML=`
        <td>${bubbleStep++}</td>
        <td>${bubblePosition}</td>
        <td>${comparison}</td>
        <td>${bubbleSwapMade}</td>
        <td>${bubbleData.join(", ")}</td>
      `;
      document.querySelector("#bubbleTable tbody").appendChild(row);
      bubblePosition++;
    }

  }else{
    highlight("bubbleCode",11);
    bubbleInPass=false;
  }
}

/* =========================================================
   INSERTION SORT
========================================================= */

let insertionData = [];
let insertionI;
let insertionJ;
let insertionKey;
let insertionStep = 1;
let insertionFinished = false;
let insertionStage = 0;

function renderInsertion(highlights = []) {
  const container = document.getElementById("insertionVisual");
  container.innerHTML = "";

  const indexRow = document.createElement("div");
  indexRow.className = "array-row";

  const valueRow = document.createElement("div");
  valueRow.className = "array-row";

  insertionData.forEach((value, index) => {

    const indexCell = document.createElement("div");
    indexCell.className = "index-label";
    indexCell.innerText = index;
    indexRow.appendChild(indexCell);

    const box = document.createElement("div");
    box.className = "array-box";
    box.innerText = value;

    if (highlights.includes(index)) {
      box.classList.add("highlight");
    }

    valueRow.appendChild(box);
  });

  container.appendChild(indexRow);
  container.appendChild(valueRow);
}

function startInsertion() {
  insertionData = document.getElementById("insertionArray")
    .value.split(",").map(Number);

  insertionI = 1;
  insertionStep = 1;
  insertionFinished = false;
  insertionStage = 0;

  document.querySelector("#insertionTable tbody").innerHTML = "";
  renderInsertion();
  highlight("insertionCode", 1);
}

function nextInsertion() {

  if (insertionFinished) return;

  if (insertionI >= insertionData.length) {
    insertionFinished = true;
    return;
  }

  if (insertionStage === 0) {
    highlight("insertionCode", 2);
    insertionKey = insertionData[insertionI];
    insertionJ = insertionI - 1;
    insertionStage = 1;
    return;
  }

  if (insertionStage === 1) {

    highlight("insertionCode", 4);

    if (insertionJ >= 0 && insertionData[insertionJ] > insertionKey) {

      highlight("insertionCode", 5);
      insertionData[insertionJ + 1] = insertionData[insertionJ];

      renderInsertion([insertionJ, insertionJ + 1]);

      const row = document.createElement("tr");
      row.innerHTML = `
        <td>${insertionStep++}</td>
        <td>${insertionI}</td>
        <td>${insertionJ}</td>
        <td>${insertionKey}</td>
        <td>${insertionData.join(", ")}</td>
      `;
      document.querySelector("#insertionTable tbody").appendChild(row);

      insertionJ--;
      return;

    } else {
      insertionStage = 2;
      return;
    }
  }

  if (insertionStage === 2) {

    highlight("insertionCode", 8);
    insertionData[insertionJ + 1] = insertionKey;

    renderInsertion([insertionJ + 1]);

    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${insertionStep++}</td>
      <td>${insertionI}</td>
      <td>${insertionJ}</td>
      <td>${insertionKey}</td>
      <td>${insertionData.join(", ")}</td>
    `;
    document.querySelector("#insertionTable tbody").appendChild(row);

    insertionI++;
    insertionStage = 0;
  }
}

</script>
<script src="../js/booklets.js"></script>
<div id="command-words"></div>

<!-- PDF MODAL -->
<div id="pdfModal">
  <div class="pdf-modal-content">
    <iframe id="pdfFrame"></iframe>
  </div>
</div>

</body>
</html>