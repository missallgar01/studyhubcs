<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Big O</title>
  <link rel="stylesheet" href="../../css/main.css" />
</head>

<body>

<header>
   <h1>BigO – Study Notes</h1>

</header>

<main>
<div class = "vertical-knowledge">

    <div class="knowledge-card">
      <h3>Big O Notation</h3>

      <h4>What is Big O?</h4>
      <p>
        Big O notation is used to evaluate the complexity of an algorithm.
        It shows how the time, memory, or resources required by an algorithm
        increase as the size of the data set increases.
      </p>

      <p>
        Big O notation usually describes the <strong>worst-case scenario</strong>
        for an algorithm.
      </p>

      <p>
        <strong>Time complexity</strong> – how the execution time scales as data size increases<br>
        <strong>Space complexity</strong> – how much memory is required
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Common Big O Notations</h3>

      <table>
        <thead>
          <tr>
            <th>Notation</th>
            <th>Description</th>
            <th>Example Code</th>
            <th>Example Use</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>O(1)</code></td>
            <td>
              <strong>Constant.</strong>
              Always executes in the same time regardless of data size.
              Very efficient.
            </td>
            <td>
              <code>value = data_set[x]</code>
            </td>
            <td>
              Accessing an element in an array.<br>
              Hashing algorithms.
            </td>
          </tr>

          <tr>
            <td><code>O(log N)</code></td>
            <td>
              <strong>Logarithmic.</strong>
              The problem size is halved each step.
              Common in divide-and-conquer algorithms.
            </td>
            <td>
              <pre>
    WHILE found == False AND low <= high
      mid = (low + high) DIV 2
      IF data[mid] == target THEN
        found = True
      ELSEIF data[mid] < target THEN
        low = mid + 1
      ELSE
        high = mid - 1
      ENDIF
    ENDWHILE
              </pre>
            </td>
            <td>Binary search.</td>
          </tr>

          <tr>
            <td><code>O(N)</code></td>
            <td>
              <strong>Linear.</strong>
              Performance decreases proportionally as data size grows.
            </td>
            <td>
              <pre>
    FOR x = 1 TO N
      total = total + data[x]
    NEXT x
              </pre>
            </td>
            <td>
              Looping through an array.<br>
              Linear search.
            </td>
          </tr>

          <tr>
            <td><code>O(N log N)</code></td>
            <td>
              <strong>Linearithmic.</strong><br>
              The algorithm processes every item and repeatedly divides the problem.
            </td>
            <td>
             Merge sort’s time comes from two separate actions:
                  <ul>
    <li>Splitting → log n (You keep dividing the list in half)</li>
    <li>Merging → n At each level of splitting, you merge all elements back together.
        Every element is looked at once per level </li>
            </ul>
            </td>
            <td>
              Quick sort.<br>
              Merge sort.
            </td>
          </tr>

          <tr>
            <td><code>O(N²)</code></td>
            <td>
              <strong>Polynomial.</strong>
              Performance proportional to the square of the data size.
              Often caused by nested loops.
            </td>
            <td>
              <pre>
    FOR x = 1 TO N
      FOR y = 1 TO N
        total = total + 1
      NEXT y
    NEXT x
              </pre>
            </td>
            <td>
              Nested loops.<br>
              Bubble sort.
            </td>
          </tr>
          <tr>
            <td><code>O(2ⁿ)</code></td>
            <td>
              <strong>Exponential.</strong>
              Time doubles with each additional data item.
              Extremely inefficient.
            </td>
            <td>
              <pre>
    FUNCTION fib(x)
      IF x <= 1 THEN
        RETURN x
      ELSE
        RETURN fib(x - 1) + fib(x - 2)
      ENDIF
    ENDFUNCTION
              </pre>
            </td>
            <td>
              Recursive Fibonacci calculation.
            </td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="knowledge-card">
  <h3>Big O Growth Comparison Diagram</h3>

  <p>
    This diagram compares how common complexity classes grow as input size <code>N</code> increases
    (y-values are scaled/capped to fit on one chart).
  </p>


            <img src="images/algorithms/comparison.jpg" height="375" width="616"/>
            <p>
    Key idea: as <code>N</code> grows, <code>O(N²)</code> and especially <code>O(2ⁿ)</code>
    become impractical much faster than <code>O(N log N)</code> or <code>O(log N)</code>.
  </p>
</div>

     <div class="knowledge-card">
  <h3>Big O Notation – Searching Algorithms</h3>

  <table>
    <thead>
      <tr>
        <th rowspan="2">Searching Algorithm</th>
        <th colspan="3">Time Complexity</th>
      </tr>
      <tr>
        <th>Best</th>
        <th>Average</th>
        <th>Worst</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Linear Search</td>
        <td>O(1)</td>
        <td>O(n)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Binary Search (Array)</td>
        <td>O(1)</td>
        <td>O(log n)</td>
        <td>O(log n)</td>
      </tr>
      <tr>
        <td>Binary Search Tree</td>
        <td>O(1)</td>
        <td>O(log n)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Hashing</td>
        <td>O(1)</td>
        <td>O(1)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Breadth / Depth First Search (Graph)</td>
        <td>O(1)</td>
        <td>O(V + E)</td>
        <td>O(V²)</td>
      </tr>
    </tbody>
  </table>

  <p>
    Where <strong>V</strong> is the number of vertices and
    <strong>E</strong> is the number of edges.
  </p>
</div>

     <div class="knowledge-card">
  <h3>Big O Notation – Sorting Algorithms</h3>

  <table>
    <thead>
      <tr>
        <th rowspan="2">Sorting Algorithm</th>
        <th colspan="3">Time Complexity</th>
        <th rowspan="2">Space Complexity</th>
      </tr>
      <tr>
        <th>Best</th>
        <th>Average</th>
        <th>Worst</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Bubble Sort</td>
        <td>O(n)</td>
        <td>O(n²)</td>
        <td>O(n²)</td>
        <td>O(1)</td>
      </tr>
      <tr>
        <td>Insertion Sort</td>
        <td>O(n)</td>
        <td>O(n²)</td>
        <td>O(n²)</td>
        <td>O(1)</td>
      </tr>
      <tr>
        <td>Merge Sort</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Quick Sort</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>O(n²)</td>
        <td>O(log n)</td>
      </tr>
    </tbody>
  </table>
</div>

     <div class="knowledge-card">
  <h3>Growth Rate Comparison</h3>

  <table>
    <thead>
      <tr>
        <th>n</th>
        <th>n² (Polynomial)</th>
        <th>2ⁿ (Exponential)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>2</td>
      </tr>
      <tr>
        <td>10</td>
        <td>100</td>
        <td>1,024</td>
      </tr>
      <tr>
        <td>20</td>
        <td>400</td>
        <td>1,048,576</td>
      </tr>
      <tr>
        <td>30</td>
        <td>900</td>
        <td>1,073,741,824</td>
      </tr>
    </tbody>
  </table>

  <p>
    Exponential algorithms become impractical extremely quickly compared
    to polynomial algorithms.
  </p>
</div>
</div>

<button id="printBtn" type="button">
  Print this worksheet
</button>

</main>


<footer>
    © <span id="year"></span> StudyHub CS
  </footer>

<script src="../js/booklets.js"></script>
<div id="command-words"></div>

</body>
</html>