<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>A* Shortest Path Demo</title>

<style>
body {
  font-family: Arial, sans-serif;
  background: #f4f9ff;
  padding: 2rem;
  text-align: center;
}

h1 { color: #003366; }

button {
  padding: 0.6rem 1rem;
  margin: 0.5rem;
  font-size: 1rem;
  cursor: pointer;
}

svg {
  border: 1px solid #ccc;
  background: white;
  margin-top: 1rem;
}

.node {
  fill: #e0e0e0;
  stroke: #333;
  stroke-width: 2;
}

.start { fill: #4caf50; }
.goal { fill: #f44336; }
.open { fill: #ffeb3b; }
.closed { fill: #90caf9; }
.path { fill: #9c27b0; color: white; }

table {
  margin: 1rem auto;
  border-collapse: collapse;
  width: 70%;
}

th, td {
  border: 1px solid #ccc;
  padding: 0.5rem;
}

th {
  background: #d0eaff;
}
</style>
</head>
<body>

<h1>‚≠ê A* Shortest Path Algorithm Demo</h1>

<button onclick="startAStar()">Start</button>
<button onclick="nextStep()">Next Step</button>
<button onclick="reset()">Reset</button>

<svg width="500" height="350" id="graph"></svg>

<h2>üìä A* Table</h2>
<table>
<thead>
<tr>
<th>Node</th>
<th>g(n)</th>
<th>h(n)</th>
<th>f(n)</th>
<th>Status</th>
</tr>
</thead>
<tbody id="tableBody"></tbody>
</table>

<script>

const nodes = {
  A: { x: 80, y: 150, h: 7 },
  B: { x: 180, y: 80, h: 6 },
  C: { x: 180, y: 220, h: 2 },
  D: { x: 320, y: 80, h: 1 },
  E: { x: 320, y: 220, h: 0 }
};

const edges = {
  A: { B: 1, C: 4 },
  B: { D: 5 },
  C: { D: 1, E: 7 },
  D: { E: 3 },
  E: {}
};

let openSet = [];
let closedSet = [];
let cameFrom = {};
let gScore = {};
let steps = [];
let currentStep = 0;

const svg = document.getElementById("graph");
const tableBody = document.getElementById("tableBody");

/* -------- DRAW GRAPH -------- */

function drawGraph(highlightPath = []) {

  svg.innerHTML = "";

  // Draw edges
  for (let from in edges) {
    for (let to in edges[from]) {
      let line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", nodes[from].x);
      line.setAttribute("y1", nodes[from].y);
      line.setAttribute("x2", nodes[to].x);
      line.setAttribute("y2", nodes[to].y);
      line.setAttribute("stroke", "#999");
      svg.appendChild(line);
    }
  }

  // Draw nodes
  for (let id in nodes) {
    let circle = document.createElementNS("http://www.w3.org/2000/svg","circle");
    circle.setAttribute("cx", nodes[id].x);
    circle.setAttribute("cy", nodes[id].y);
    circle.setAttribute("r", 20);
    circle.setAttribute("class", getNodeClass(id, highlightPath));
    svg.appendChild(circle);

    let text = document.createElementNS("http://www.w3.org/2000/svg","text");
    text.setAttribute("x", nodes[id].x);
    text.setAttribute("y", nodes[id].y + 5);
    text.setAttribute("text-anchor", "middle");
    text.textContent = id;
    svg.appendChild(text);
  }
}

function getNodeClass(id, path) {
  if (path.includes(id)) return "node path";
  if (id === "A") return "node start";
  if (id === "E") return "node goal";
  if (closedSet.includes(id)) return "node closed";
  if (openSet.includes(id)) return "node open";
  return "node";
}

/* -------- A* LOGIC -------- */

function startAStar() {

  reset();

  openSet.push("A");
  gScore["A"] = 0;

  recordAStar();

}

function nextStep() {
  if (currentStep >= steps.length) return;
  steps[currentStep]();
  currentStep++;
}

function recordAStar() {

  while (openSet.length > 0) {

    let current = openSet.reduce((a,b) =>
      (gScore[a] + nodes[a].h) < (gScore[b] + nodes[b].h) ? a : b
    );

    steps.push(() => {
      updateTable();
      drawGraph();
    });

    if (current === "E") {
      let path = reconstructPath(current);
      steps.push(() => drawGraph(path));
      return;
    }

    openSet = openSet.filter(n => n !== current);
    closedSet.push(current);

    for (let neighbor in edges[current]) {

      let tentative = gScore[current] + edges[current][neighbor];

      if (!gScore.hasOwnProperty(neighbor) || tentative < gScore[neighbor]) {
        cameFrom[neighbor] = current;
        gScore[neighbor] = tentative;
        if (!openSet.includes(neighbor)) openSet.push(neighbor);
      }
    }
  }
}

function reconstructPath(current) {
  let totalPath = [current];
  while (cameFrom[current]) {
    current = cameFrom[current];
    totalPath.unshift(current);
  }
  return totalPath;
}

function updateTable() {
  tableBody.innerHTML = "";

  for (let id in nodes) {
    let g = gScore[id] ?? "-";
    let h = nodes[id].h;
    let f = g !== "-" ? g + h : "-";
    let status = openSet.includes(id) ? "Open" :
                 closedSet.includes(id) ? "Closed" : "";

    let row = `<tr>
      <td>${id}</td>
      <td>${g}</td>
      <td>${h}</td>
      <td>${f}</td>
      <td>${status}</td>
    </tr>`;

    tableBody.innerHTML += row;
  }
}

/* -------- RESET -------- */

function reset() {
  openSet = [];
  closedSet = [];
  cameFrom = {};
  gScore = {};
  steps = [];
  currentStep = 0;
  tableBody.innerHTML = "";
  drawGraph();
}

drawGraph();

</script>

</body>
</html>