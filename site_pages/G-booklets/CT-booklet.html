<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hardware – Revision Page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../styles.css" />
</head>

<body>
<div class="back-container">
    <a href="../G-booklets.html">← Back</a>
  </div>
<header>
  <h1>Topic 1 Computational Thinking – Revision</h1>
  <h2>Read • Write • Check • Amend</h2>
  <p class="subtitle">
    Read the notes, write your own answers, then reveal the model answers to check and improve.
  </p>
</header>

<main>

  <!-- =========================
       NOTES / RECAP (VERTICAL)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Notes</h2>
    </div>

    <div class="vertical-knowledge">


<div class="knowledge-card">
      <h3>Computational Thinking</h3>

      <p>
        <strong>Computational thinking</strong> is the ability to think about how a computer could be used to solve a problem.
      </p>
      <p>
        <strong>Algorithms</strong> are a step-by-step set of instructions used to solve a problem.
        Algorithms can be written as <strong>pseudocode</strong> or <strong>flowcharts</strong>.
      </p>

      <p>
        <strong>Pseudocode</strong> is written in English and is used to plan an algorithm before programming.
        It allows programmers using different programming languages to understand the logic.
      </p>

      <p>
        <strong>Flowcharts</strong> are visual diagrams used to design algorithms that can be implemented in any programming language.
        Common flowchart symbols include:
      </p>
    <figure>
    <img src="images/CT/flowchart.png" height="172" width="420"/>
    </figure>
    <ul>
        <li><strong>Start/Stop</strong> – beginning or end of an algorithm</li>
        <li><strong>Decision</strong> – a yes/no or true/false choice</li>
        <li><strong>Input/Output</strong> – data entering or leaving the system</li>
        <li><strong>Process</strong> – an instruction or calculation</li>
        <li><strong>Function / Subroutine</strong> – a reusable block of code</li>
      </ul>

    </div>

     <div class="knowledge-card">
  <h3>Decomposition</h3>

  <p>
    <strong>Decomposition</strong> is the process of <strong>breaking down a large problem into a set of smaller problems</strong>.
  </p>

  <p><strong>Benefits of decomposition:</strong></p>
  <ul>
    <li>Smaller problems are easier to solve</li>
    <li>Each smaller problem can be solved independently</li>
    <li>Smaller problems can be tested independently</li>
    <li>The smaller problems can be combined to solve the full problem</li>
      <li>
      It allows a task to be tackled by a <strong>team working together</strong>,
      with each person contributing their own insights, experience, and skills
    </li>
  </ul>
</div>

        <div class="knowledge-card">
  <h3>Example</h3>

  <p><strong>Example: Logging on to a system</strong></p>

  <p>When a user logs on, the program can be decomposed into the following steps:</p>

  <ul>
    <li>Ask the user for their username</li>
    <li>Ask the user for their password</li>
    <li>Check if the username exists and is valid</li>
    <li>If not valid, ask for the username again</li>
    <li>Check if the password is correct</li>
    <li>If not correct, ask for the password again</li>
    <li>Check if the user has used all 3 attempts</li>
    <li>Lock the account if the maximum attempts are reached</li>
  </ul>
<figure><img src="images/CT/login.png" height="165" width="303"/></figure>
  <p>
    Each of these steps can be programmed, tested, and improved separately before
    being combined into the full login system.
  </p>
</div>

<div class="knowledge-card">
  <h3>Abstraction</h3>

  <p>
    <strong>Abstraction</strong> is the process of <strong>removing unnecessary details</strong> of a problem to
    <strong>focus on the important features</strong> needed to implement a solution.
  </p>

  <p><strong>Examples of abstraction include:</strong></p>
  <ul>
    <li>Modelling a real-life object</li>
    <li>Modelling an environment</li>
    <li>Modelling an action or sequence of actions</li>
    <li>Modelling a concept</li>
  </ul>

  <p><strong>Implementations of abstraction include:</strong></p>
  <ul>
    <li>A computer game that simulates playing a sport</li>
    <li>A simulator such as a car or flight simulator</li>
  <li>a map of a bus or train route in a city</li>
  </ul>

    <p>When creating a program, developers must
identify important features
that willcontribute to solving the problem or have a role to play in the solution</p>

<h3>Abstraction – Why is it used?</h3>

  <ul>
    <li>
      Helps identify what the <strong>important details</strong> are when designing an algorithm
      (data and processes)
    </li>
    <li>
      Removes detail that <strong>is not needed</strong>, making the problem easier to solve
    </li>
    <li>
      Helps to <strong>reduce complexity</strong>, making the implementation
      <strong>simpler, more efficient, and quicker</strong>
    </li>
  </ul>
</div>


      <div class="knowledge-card">
  <h3>Abstraction – SatNav Map Example</h3>
<figure><img src="images/CT/satnav.jpg" height="215" width="333"/></figure>
  <p>
    <strong>Abstraction</strong> involves <strong>removing unnecessary details</strong> so the user can
    focus on the <strong>most important information</strong>.
  </p>

  <p><strong>Example: Designing a SatNav map</strong></p>

  <p><strong>Important information to include:</strong></p>
  <ul>
    <li>A clear view of the roads</li>
    <li>Main roads and minor roads shown differently</li>
    <li>Petrol stations and places to eat shown using symbols</li>
    <li>Directions, distance, and speed limits</li>
  </ul>

  <p><strong>Less important information to remove:</strong></p>
  <ul>
    <li>Scenery such as trees and fields</li>
    <li>Individual houses</li>
    <li>Other cars on the road</li>
  </ul>

  <p>
    By removing unnecessary detail, the SatNav becomes easier to read and helps the
    driver focus on navigation.
  </p>
</div>


<div class="knowledge-card">
  <h3>Subprograms</h3>

  <p>
    A <strong>subprogram</strong> is an <strong>out-of-line block of code</strong> that can be
    run by simply calling its <strong>name</strong> from elsewhere in a program.
  </p>

  <p>
    Each subprogram has a <strong>unique name</strong> so it can be called whenever it is needed.
  </p>

  <p><strong>Benefits of using subprograms:</strong></p>
  <ul>
    <li>Helps break large problems into smaller parts (<strong>decomposition</strong>)</li>
    <li>Allows team members to work on <strong>different parts</strong> of a program</li>
    <li>Makes programs <strong>easier to debug</strong></li>
    <li>Makes programs <strong>more efficient</strong> by avoiding duplicated code</li>
  </ul>

  <p><strong>Types of subprogram:</strong></p>
  <ul>
    <li>
      <strong>Procedure</strong> – a subprogram that does <strong>not return</strong> a value
    </li>
    <li>
      <strong>Function</strong> – a subprogram that <strong>returns one or more values</strong>
      to the calling code
    </li>
  </ul>

  <hr>

  <h4>Examples (Python)</h4>

  <pre><code>
# Subprogram 1 – Procedure
def information():
    first_name = input("Enter a name: ")
    surname = input("Enter a surname: ")

# Subprogram 2 – Function
def tax(pay_per_hour, hours_worked):
    total = pay_per_hour * hours_worked
    net_pay = total * 0.8
    return net_pay

# Main program
information()           # call procedure
print(tax(10, 20))      # call function
  </code></pre>

  <p>
    Procedures perform tasks, while functions perform tasks
    <strong>and return a result</strong>.
  </p>
</div>

</div>
</section>



   <section class="topic-section expanded" id="ct-match">
  <div class="topic-header">
    <span class="topic-arrow">&#9656;</span>
    <h2>Drag & Drop Matching</h2>
  </div>

  <div class="vertical-knowledge">
    <p>Drag each <strong>term</strong> onto the correct <strong>definition</strong>, then click <em>Check</em>.</p>

    <div class="match-wrap">
      <div class="match-bank">
        <h3>Terms</h3>

        <div class="term" draggable="true" data-term="algorithm">Algorithm</div>
        <div class="term" draggable="true" data-term="abstraction">Abstraction</div>
        <div class="term" draggable="true" data-term="decomposition">Decomposition</div>

      </div>

      <div class="match-targets">
        <h3>Definitions</h3>


        <div class="target" data-accept="algorithm">
          <p><strong>Step-by-step instructions to solve a problem.</strong></p>
          <div class="dropzone"></div>
        </div>


        <div class="target" data-accept="abstraction">
          <p><strong>Remove unnecessary detail; focus on what matters.</strong></p>
          <div class="dropzone"></div>
        </div>

        <div class="target" data-accept="decomposition">
          <p><strong>Break a problem into smaller sub-problems.</strong></p>
          <div class="dropzone"></div>
        </div>


      </div>
    </div>

    <div class="match-actions">
      <button class="secondary" id="checkMatch" type="button">Check</button>
      <button class="secondary" id="resetMatch" type="button">Reset</button>
      <p><strong>Result:</strong> <span id="matchResult">—</span></p>
    </div>
  </div>
</section>

  <!-- =========================
       QUESTIONS & ANSWERS
       ========================= -->
   <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Check your understanding</h2>
    </div>

    <div class="vertical-knowledge">

<div class="rev-card qa-card">
  <p>
    Jack plays rugby at his local rugby club. He wants to create a program to store
    the results of each rugby match and the names of the try scorers.<br><br>

    <strong>a)</strong> Define what is meant by <strong>abstraction</strong>. [2]<br>
    <strong>b)</strong> Give <strong>one example</strong> of how abstraction could be used
    when developing this program. [1]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">
    <p><strong>a)</strong> Abstraction is removing unnecessary detail from a problem so that you
    can focus on the important parts that need solving. This reduces complexity and
    makes the problem easier to solve.</p>

    <p><strong>b)</strong> For example, the program could store the match result and the names of
    the try scorers, while ignoring details such as the time the try was scored,
    the player’s shirt number, or the venue.</p>
  </div>

</div>
    </div>
  </section>

</main>

        <button id="printBtn" type="button">
  Print this worksheet
</button>

</main>

<footer>
  &copy; 2025 StudyHubCS
</footer>

<script>
  // Toggle topic sections open/closed
  document.querySelectorAll('.topic-header').forEach(header => {
    header.addEventListener('click', () => {
      const section = header.parentElement;
      section.classList.toggle('collapsed');
      section.classList.toggle('expanded');
    });
  });

  // Show / hide individual answers
  document.querySelectorAll('.answer-toggle').forEach(btn => {
    const answer = btn.nextElementSibling;
    if (!answer) return;

    // ensure hidden initially (CSS also sets .answer display:none)
    answer.style.display = 'none';

    btn.addEventListener('click', () => {
      const open = answer.style.display === 'block';
      answer.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Show answer' : 'Hide answer';
    });
  });

  /* -----------------------------
     Print button
  ------------------------------ */
  const printBtn = document.getElementById("printBtn");
  if (printBtn) {
    printBtn.addEventListener("click", () => {
      window.print();
    });
  }

</script>
<style>
  #ct-match .match-wrap{display:grid;grid-template-columns:1fr 2fr;gap:16px;margin-top:12px}
  #ct-match .match-bank,#ct-match .match-targets{border:1px solid #000;border-radius:10px;padding:12px}
  #ct-match .term{border:1px solid #000;border-radius:10px;padding:10px;margin:8px 0;cursor:grab;background:#fff;user-select:none}
  #ct-match .target{border:1px dashed #000;border-radius:10px;padding:10px;margin:10px 0}
  #ct-match .dropzone{min-height:44px;border:1px solid #000;border-radius:10px;margin-top:8px;padding:6px;display:flex;align-items:center;flex-wrap:wrap;gap:8px}
  #ct-match .placed{padding:6px 10px;border:1px solid #000;border-radius:999px;background:#fff}
  #ct-match .correct-zone{outline:3px solid #2a8}
  #ct-match .wrong-zone{outline:3px solid #d33}
  #ct-match .match-actions{margin-top:12px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  #ct-match .placed { cursor: grab; }
</style>

<script>

    (() => {
  const matchRoot = document.getElementById("ct-match");
  if (!matchRoot) return;

  const bank = matchRoot.querySelector(".match-bank");
  if (!bank) return;

  // Get only the draggable terms (ignore headings, hr, etc.)
  const terms = Array.from(bank.querySelectorAll(".term"));

  // Fisher–Yates shuffle
  for (let i = terms.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [terms[i], terms[j]] = [terms[j], terms[i]];
  }

  // Re-append in shuffled order
  terms.forEach(term => bank.appendChild(term));
})();


(() => {
  const root = document.getElementById("ct-match");
  if (!root) return;

  const bank = root.querySelector(".match-bank");
  const terms = Array.from(root.querySelectorAll(".term"));
  const targets = Array.from(root.querySelectorAll(".target"));
  const resultEl = root.querySelector("#matchResult");
  const checkBtn = root.querySelector("#checkMatch");
  const resetBtn = root.querySelector("#resetMatch");

  let draggedEl = null;   // can be a .term OR a .placed
  let draggedType = null; // "term" | "placed"

  function makePlaced(termKey, text) {
    const pill = document.createElement("div");
    pill.className = "placed";
    pill.textContent = text;
    pill.dataset.term = termKey;
    pill.draggable = true;

    pill.addEventListener("dragstart", () => {
      draggedEl = pill;
      draggedType = "placed";
      setTimeout(() => pill.style.opacity = "0.5", 0);
    });

    pill.addEventListener("dragend", () => {
      pill.style.opacity = "1";
      draggedEl = null;
      draggedType = null;
    });

    return pill;
  }

  // Enable dragging from the bank
  terms.forEach(t => {
    t.addEventListener("dragstart", () => {
      draggedEl = t;
      draggedType = "term";
      setTimeout(() => t.style.opacity = "0.5", 0);
    });

    t.addEventListener("dragend", () => {
      t.style.opacity = "1";
      draggedEl = null;
      draggedType = null;
    });
  });

  // Bank drop: allow returning a placed pill back to the bank
  bank.addEventListener("dragover", (e) => e.preventDefault());
  bank.addEventListener("drop", (e) => {
    e.preventDefault();
    if (!draggedEl) return;

    // Only handle returning placed pills
    if (draggedType === "placed") {
      const termKey = draggedEl.dataset.term;

      // Remove pill from its dropzone
      draggedEl.remove();

      // Reveal the original bank term again
      const original = terms.find(t => t.dataset.term === termKey);
      if (original) original.style.display = "block";

      // Optional: clear any outlines as user is editing
      targets.forEach(target => {
        target.querySelector(".dropzone")?.classList.remove("correct-zone", "wrong-zone");
      });
      resultEl.textContent = "—";
    }
  });

  // Dropzones behavior
  targets.forEach(target => {
    const zone = target.querySelector(".dropzone");
    zone.addEventListener("dragover", (e) => e.preventDefault());

    zone.addEventListener("drop", (e) => {
      e.preventDefault();
      if (!draggedEl) return;

      // If zone already has a pill, return it to bank first
      const existing = zone.querySelector(".placed");
      if (existing) {
        const oldKey = existing.dataset.term;
        existing.remove();
        const oldTerm = terms.find(t => t.dataset.term === oldKey);
        if (oldTerm) oldTerm.style.display = "block";
      }

      // Place based on what is being dragged
      if (draggedType === "term") {
        // Put a new pill in the zone
        zone.innerHTML = "";
        const pill = makePlaced(draggedEl.dataset.term, draggedEl.textContent);
        zone.appendChild(pill);

        // Hide the original term in the bank
        draggedEl.style.display = "none";
      }

      if (draggedType === "placed") {
        // Move the pill into the new zone
        zone.innerHTML = "";
        zone.appendChild(draggedEl);
      }

      // Clear outlines as user is editing
      zone.classList.remove("correct-zone", "wrong-zone");
      resultEl.textContent = "—";
    });
  });

  function resetAll() {
    // Show all bank terms
    terms.forEach(t => t.style.display = "block");

    // Clear dropzones + outlines
    targets.forEach(target => {
      const zone = target.querySelector(".dropzone");
      zone.innerHTML = "";
      zone.classList.remove("correct-zone", "wrong-zone");
    });

    resultEl.textContent = "—";
  }

  checkBtn?.addEventListener("click", () => {
    let correct = 0;

    targets.forEach(target => {
      const accept = target.dataset.accept;
      const zone = target.querySelector(".dropzone");
      const placed = zone.querySelector(".placed");
      const ok = placed && placed.dataset.term === accept;

      zone.classList.remove("correct-zone", "wrong-zone");
      zone.classList.add(ok ? "correct-zone" : "wrong-zone");
      if (ok) correct += 1;
    });

    resultEl.textContent = `${correct} / ${targets.length}`;
  });

  resetBtn?.addEventListener("click", resetAll);

  resetAll();
})();
</script>
</body>
</html>