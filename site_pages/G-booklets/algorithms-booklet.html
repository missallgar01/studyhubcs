<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hardware – Revision Page</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../../styles.css" />
</head>

<body>
<div class="back-container">
    <a href="../G-booklets.html">← Back</a>
  </div>
<header>
  <h1>Topic 1 Computational Thinking Algorithms – Revision</h1>
  <h2>Read • Write • Check • Amend</h2>
  <p class="subtitle">
    Read the notes, write your own answers, then reveal the model answers to check and improve.
  </p>
</header>

<main>

  <!-- =========================
       NOTES / RECAP (VERTICAL)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Notes</h2>
    </div>

    <div class="vertical-knowledge">


        <div class="knowledge-card">
  <h1>Read, Write, Analyse &amp; Refine Programs</h1>

  <ul>
    <li>Many exam questions require students to <strong>analyse and refine</strong> given code by:</li>
    <ul>
      <li>Correcting errors</li>
      <li>Adding or rearranging lines</li>
      <li>Selecting the correct line</li>
      <li>Improving readability</li>
    </ul>
  </ul>

  <h2>Correcting errors</h2>
  <p>Find and correct the errors in this program.</p>

  <h3>Python code (contains errors)</h3>
  <pre><code>
# This program calculates the area of a rectangle

lenght = float(input("Enter the lenght of the rectangle: "))
widht = float(input("Enter the widht of the rectangle: "))

area = lenght * widht

print"The area of the rectangle is:", area)

if area &gt; 100:
print("This is a large rectangle!")
  </code></pre>

  <h3>What are the errors?</h3>
  <ul>
    <li>Spelling mistakes in variable names (e.g. <code>lenght</code> and <code>widht</code>)</li>
    <li>Misspelled variables used in the calculation</li>
    <li>Missing brackets in the first <code>print()</code> statement</li>
    <li>Incorrect indentation for the <code>if</code> statement block</li>
  </ul>

  <h3>Python code (corrected)</h3>
  <pre><code>
# This program calculates the area of a rectangle

length = float(input("Enter the length of the rectangle: "))
width = float(input("Enter the width of the rectangle: "))

area = length * width

print("The area of the rectangle is:", area)

if area &gt; 100:
    print("This is a large rectangle!")
  </code></pre>
</div>

<div class="knowledge-card">
  <h1>Read, Write, Analyse &amp; Refine Programs</h1>

  <ul>
    <li>Many exam questions require students to <strong>analyse and refine</strong> given code by:</li>
    <ul>
      <li>Correcting errors</li>
      <li>Adding or rearranging lines</li>
      <li>Selecting the correct line</li>
      <li>Improving readability</li>
    </ul>
  </ul>

  <h2>Correcting errors</h2>
  <p>Find and correct the errors in this program.</p>

  <h3>Python code (contains errors)</h3>
  <pre><code>
# This program calculates the area of a rectangle

lenght = float(input("Enter the lenght of the rectangle: "))
widht = float(input("Enter the widht of the rectangle: "))

area = lenght * widht

print"The area of the rectangle is:", area)

if area &gt; 100:
print("This is a large rectangle!")
  </code></pre>

  <h3>What are the errors?</h3>
  <ul>
    <li>Spelling mistakes in variable names (e.g. <code>lenght</code> and <code>widht</code>)</li>
    <li>Misspelled variables used in the calculation</li>
    <li>Missing brackets in the first <code>print()</code> statement</li>
    <li>Incorrect indentation for the <code>if</code> statement block</li>
  </ul>

  <h3>Python code (corrected)</h3>
  <pre><code>
# This program calculates the area of a rectangle

length = float(input("Enter the length of the rectangle: "))
width = float(input("Enter the width of the rectangle: "))

area = length * width

print("The area of the rectangle is:", area)

if area &gt; 100:
    print("This is a large rectangle!")
  </code></pre>
</div>

   <div class="knowledge-card">
  <h1>How can you convert algorithms?</h1>

  <ul>
    <li>By having a good understanding of at least one <strong>programming language</strong> and how algorithms work, it is possible to convert between different representations.</li>
    <li>In exams, students must be able to convert algorithms from:</li>
    <ul>
      <li><strong>Flowcharts to program code</strong></li>
      <li><strong>Pseudocode to program code</strong></li>
    </ul>
  </ul>

  <div class="examiner-tip">
    <strong>Examiner Tips and Tricks</strong>
    <p>
      Before attempting algorithm conversion questions, make sure you understand
      flowchart symbols and pseudocode keywords.
    </p>
  </div>
<figure><img src="images/CT/flowchart_example.png" height="1080" width="952"/></figure>
  <h2>Flowcharts to Program Code</h2>
  <p><strong>Task:</strong> Convert the following flowchart into program code (Python).</p>

  <h3>Correct Python Code</h3>
  <pre><code>
import random

# Generate a random number
num = random.randint(1, 100)

print("Welcome to the number guessing game!")

# First guess
guess = int(input("Guess a number between 1 and 100: "))

# Repeat until the correct number is guessed
while guess != num:
    if guess > num:
        print("Too high, try again")
    elif guess < num:
        print("Too low, try again")

    guess = int(input("Guess a number between 1 and 100: "))

print("Good guess!")
  </code></pre>
</div>

    <div class="knowledge-card">
  <h3>Trace Tables</h3>

  <p>
    A <strong>trace table</strong> is used to <strong>track the values of variables</strong>
    as a program runs. It shows how a program executes
    <strong>step by step</strong>.
  </p>

  <p><strong>Why trace tables are used:</strong></p>
  <ul>
    <li>To understand how a program works</li>
    <li>To follow loops and selection statements</li>
    <li>To debug programs and find errors</li>
    <li>To answer exam questions about program execution</li>
  </ul>

  <p><strong>How to complete a trace table:</strong></p>
  <ol>
    <li>Write the variable names as column headings</li>
    <li>Start with the initial values before the program runs</li>
    <li>Follow the program line by line</li>
    <li>Update values when variables change</li>
    <li>Record inputs when <code>input()</code> is used</li>
    <li>Record output when a <code>print()</code> statement is reached</li>
    <li>Add a new row for each loop iteration</li>
  </ol>

  <hr>

  <h4>Worked Example</h4>

  <p>
    A program checks the weight of <strong>4 boxes of strawberries</strong>.
    Boxes are <strong>accepted</strong> if the weight is between
    <strong>395 and 405 (inclusive)</strong>, otherwise they are
    <strong>rejected</strong>.
  </p>

  <p><strong>Inputs:</strong> 404, 393, 395, 405</p>

  <h4>Algorithm (Python)</h4>

  <pre><code>
count = 0
accept = 0
reject = 0

while count &lt; 4:
    count = count + 1
    weight = int(input("Enter weight of box: "))

    if weight &lt; 395 or weight &gt; 405:
        reject = reject + 1
    else:
        accept = accept + 1

print(accept, reject)
  </code></pre>

  <h4>Trace Table</h4>

  <table border="1" cellpadding="8" cellspacing="0" width="100%">
    <thead>
      <tr>
        <th>count</th>
        <th>accept</th>
        <th>reject</th>
        <th>weight</th>
        <th>Display</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>–</td>
        <td>–</td>
      </tr>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>0</td>
        <td>404</td>
        <td>–</td>
      </tr>
      <tr>
        <td>2</td>
        <td>1</td>
        <td>1</td>
        <td>393</td>
        <td>–</td>
      </tr>
      <tr>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>395</td>
        <td>–</td>
      </tr>
      <tr>
        <td>4</td>
        <td>3</td>
        <td>1</td>
        <td>405</td>
        <td>–</td>
      </tr>
      <tr>
        <td>4</td>
        <td>3</td>
        <td>1</td>
        <td>–</td>
        <td><strong>3 1</strong></td>
      </tr>
    </tbody>
  </table>

  <p>
    <strong>Final Output:</strong> <code>3 1</code><br>
    This means <strong>3 boxes were accepted</strong> and
    <strong>1 box was rejected</strong>.
  </p>
</div>

    <div class="knowledge-card">
  <h3>Linear Search Algorithm</h3>

  <p>
    A <strong>linear search</strong> is a <strong>very simple searching algorithm</strong>.
    It is often described as a <strong>brute force</strong> method because it checks
    <strong>every item</strong> in a list until the required data is found or the end
    of the list is reached.
  </p>
<figure><img src="images/CT/linear.png" height="147" width="382"/></figure>
  <p>
    The search starts at the <strong>beginning of the array or list</strong> and moves
    through it <strong>item by item</strong>. The linear search is
    <strong>sequential</strong>.
  </p>

  <p><strong>Steps for a linear search:</strong></p>
  <ol>
    <li>Start at the first item in the list</li>
    <li>Compare the item with the search value</li>
    <li>If they are the same, stop the search</li>
    <li>If they are not the same, move to the next item</li>
    <li>Repeat until the item is found or the end of the list is reached</li>
  </ol>

  <p>
    If the search reaches the end of the list without finding the item,
    the program reports that the item was <strong>not found</strong>.
  </p>


  <h3>Linear Search – Worked Example (Trace Table)</h3>

  <p><strong>Array:</strong> [10, 8, 1, 21, 7, 32, 5, 11, 0]</p>
  <p><strong>Target value:</strong> 5</p>

  <table border="1" cellpadding="10" cellspacing="0" width="100%">
    <thead>
      <tr>
        <th>Step</th>
        <th>Index</th>
        <th>Value at Index</th>
        <th>Comparison</th>
        <th>Result</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>10</td>
        <td>10 ≠ 5</td>
        <td>Move to next index</td>
      </tr>
      <tr>
        <td>2</td>
        <td>1</td>
        <td>8</td>
        <td>8 ≠ 5</td>
        <td>Move to next index</td>
      </tr>
      <tr>
        <td>3</td>
        <td>2</td>
        <td>1</td>
        <td>1 ≠ 5</td>
        <td>Move to next index</td>
      </tr>
      <tr>
        <td>4</td>
        <td>3</td>
        <td>21</td>
        <td>21 ≠ 5</td>
        <td>Move to next index</td>
      </tr>
      <tr>
        <td>5</td>
        <td>4</td>
        <td>7</td>
        <td>7 ≠ 5</td>
        <td>Move to next index</td>
      </tr>
      <tr>
        <td>6</td>
        <td>5</td>
        <td>32</td>
        <td>32 ≠ 5</td>
        <td>Move to next index</td>
      </tr>
      <tr>
        <td>7</td>
        <td>6</td>
        <td>5</td>
        <td>5 = 5</td>
        <td><strong>Item found – stop</strong></td>
      </tr>
    </tbody>
  </table>

  <p>
    The linear search checks each item in the list one by one until the target
    value is found.
  </p>


        <figure><img src="images/CT/linearflowchart.png" height="628" width="600"/></figure>
</div>

    <div class="knowledge-card">
  <h3>Binary Search Algorithm</h3>

  <p>
    A <strong>binary search</strong> is a <strong>divide and conquer</strong> algorithm.
    It works by repeatedly splitting a list in half to find a target value.
  </p>

  <p>
    For a binary search to work, the <strong>list must be sorted</strong>.
  </p>

  <p><strong>Steps for a binary search:</strong></p>
  <ol>
    <li>Sort the list</li>
    <li>Find the midpoint of the list</li>
    <li>If the search item is found, stop</li>
    <li>If the search item is less than the midpoint, search the left sub-list</li>
    <li>If the search item is greater than the midpoint, search the right sub-list</li>
    <li>Repeat until the item is found</li>
  </ol>

  <p>
    The midpoint is found by adding the start and end index values and using
    <strong>DIV</strong> to return a whole number (rounded down).
  </p>

  <p><strong>Example:</strong> <code>mid = (start + end) DIV 2</code></p>

        <figure><img src="images/CT/binary.png" height="215" width="471"/></figure>


  <h3>Binary Search – Worked Example (Trace Table)</h3>

  <p><strong>List (sorted):</strong> [3, 7, 10, 21, 22, 25, 27, 30]</p>
  <p><strong>Target value:</strong> 10</p>

  <table border="1" cellpadding="10" cellspacing="0" width="100%">
    <thead>
      <tr>
        <th>Step</th>
        <th>Start</th>
        <th>End</th>
        <th>Mid</th>
        <th>Value at Mid</th>
        <th>Comparison</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>7</td>
        <td>(0 + 7) DIV 2 = <strong>3</strong></td>
        <td>21</td>
        <td>10 &lt; 21</td>
        <td>Search left half</td>
      </tr>

      <tr>
        <td>2</td>
        <td>0</td>
        <td>2</td>
        <td>(0 + 2) DIV 2 = <strong>1</strong></td>
        <td>7</td>
        <td>10 &gt; 7</td>
        <td>Search right half</td>
      </tr>

      <tr>
        <td>3</td>
        <td>2</td>
        <td>3</td>
        <td>(2 + 3) DIV 2 = <strong>2</strong></td>
        <td>10</td>
        <td>10 = 10</td>
        <td><strong>Item found</strong></td>
      </tr>
    </tbody>
  </table>

  <p>
    The binary search stops when the target value is found at the midpoint.
  </p>


</div>
       <div class="knowledge-card">
  <p><strong>Efficiency of searching algorithms:</strong></p>
<div class="knowledge-card">
  <h3>Efficiency of Searching Algorithms</h3>
<figure><img src="images/CT/img_binarysearch_timecomplexity.png" height="444" width="505"/></figure>
  <table>
    <thead>
      <tr>
        <th>Linear</th>
        <th>Binary</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          Checks against each item until match using brute force, making it a slow algorithm.<br><br>
          Works well on small, unsorted lists<br><br>
          It can be improved by sorting the list first and can find an item quicker.<br><br>
          Program requires less code
        </td>
        <td>
          Splits lists and checks each half using divide and conquer<br><br>
          List must be <strong>sorted</strong><br><br>
          Much quicker than a linear search because the data that needs to be searched halves with each step.<br><br>
          Program requires more code
        </td>
      </tr>
    </tbody>
  </table>
</div>

  <div class="knowledge-card">
  <h3>Linear Search vs Binary Search (Python)</h3>

  <table>
    <thead>
      <tr>
        <th>Feature</th>
        <th>Linear Search</th>
        <th>Binary Search</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Search method</strong></td>
        <td>Checks each item one by one</td>
        <td>Repeatedly splits the list in half</td>
      </tr>

      <tr>
        <td><strong>Type</strong></td>
        <td>Brute force</td>
        <td>Divide and conquer</td>
      </tr>

      <tr>
        <td><strong>List requirement</strong></td>
        <td>List does <strong>not</strong> need to be sorted</td>
        <td>List <strong>must be sorted</strong></td>
      </tr>

      <tr>
        <td><strong>Efficiency</strong></td>
        <td>Slow for large lists</td>
        <td>Fast for large lists</td>
      </tr>

      <tr>
        <td><strong>Memory use</strong></td>
        <td>Low (in-place)</td>
        <td>Low (iterative version)</td>
      </tr>

      <tr>
        <td><strong>Python example</strong></td>
        <td>
<pre>
def linear_search(data, target):
    for item in data:
        if item == target:
            return True
    return False
</pre>
        </td>
        <td>
<pre>
def binary_search(data, target):
    low = 0
    high = len(data) - 1

    while low <= high:
        mid = (low + high) // 2

        if data[mid] == target:
            return True
        elif target < data[mid]:
            high = mid - 1
        else:
            low = mid + 1

    return False
</pre>
        </td>
      </tr>

      <tr>
        <td><strong>Ease of writing</strong></td>
        <td>Very easy to write</td>
        <td>More complex to write</td>
      </tr>

      <tr>
        <td><strong>Best used when</strong></td>
        <td>Data is small or unsorted</td>
        <td>Data is large and sorted</td>
      </tr>
    </tbody>
  </table>
</div>
</div>

    <div class="knowledge-card">
  <h3>Bubble Sort Algorithm</h3>

  <p><strong>Describe the steps of the bubble sort:</strong></p>
<figure><img src="images/CT/bubble.png" height="650" width="1093"/></figure>
  <ol>
    <li>Start at the beginning of the list.</li>
    <li>
      <strong>Compare</strong> the first value with the next value.
      If the first value is larger, <strong>swap</strong> the two values.
    </li>
    <li>
      Move to the <strong>next value</strong> in the list and compare it with the one after it.
      Swap if the value is bigger.
    </li>
    <li>
      Continue until there are <strong>no more items to compare</strong>.
    </li>
    <li>
      Go back to the <strong>start of the list</strong>.
    </li>
    <li>
      <strong>Repeat until no swaps are made</strong>.
    </li>
  </ol>

  <p>
    Each complete run through the list is called a <strong>pass</strong>.
  </p>

  <p>
    The bubble sort continues until a full pass is made with
    <strong>no values swapped</strong>. At this point, the list is sorted.
  </p>
        <figure><img src="images/CT/bubblealgorithm.png" height="626" width="1222"/></figure>
</div>

<div class="knowledge-card">
  <h3>Bubble Sort – Worked Example</h3>

  <p><strong>Number of passes:</strong> 5</p>

  <table border="1" cellpadding="6" cellspacing="0">
    <thead>
      <tr>
        <th>0</th>
        <th>1</th>
        <th>2</th>
        <th>3</th>
        <th>4</th>
        <th>Compares</th>
        <th>Swaps</th>
        <th>Pass</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Lake</td>
        <td>Grass</td>
        <td>Tree</td>
        <td>Rock</td>
        <td>Flower</td>
        <td>–</td>
        <td>–</td>
        <td>–</td>
      </tr>
      <tr>
        <td>Grass</td>
        <td>Lake</td>
        <td>Rock</td>
        <td>Flower</td>
        <td>Tree</td>
        <td>4</td>
        <td>3</td>
        <td>1</td>
      </tr>
      <tr>
        <td>Grass</td>
        <td>Lake</td>
        <td>Flower</td>
        <td>Rock</td>
        <td>Tree</td>
        <td>4</td>
        <td>1</td>
        <td>2</td>
      </tr>
      <tr>
        <td>Grass</td>
        <td>Flower</td>
        <td>Lake</td>
        <td>Rock</td>
        <td>Tree</td>
        <td>4</td>
        <td>1</td>
        <td>3</td>
      </tr>
      <tr>
        <td>Flower</td>
        <td>Grass</td>
        <td>Lake</td>
        <td>Rock</td>
        <td>Tree</td>
        <td>4</td>
        <td>1</td>
        <td>4</td>
      </tr>
      <tr>
        <td>Flower</td>
        <td>Grass</td>
        <td>Lake</td>
        <td>Rock</td>
        <td>Tree</td>
        <td>4</td>
        <td>0</td>
        <td>5</td>
      </tr>
    </tbody>
  </table>
</div>

    <div class="knowledge-card">
  <h3>Merge Sort Algorithm</h3>

  <p>
    <strong>Merge sort</strong> sorts a list of data by <strong>splitting the list into two halves</strong>,
    then splitting again and again until only <strong>single-element sub-arrays</strong> remain.
    These are then <strong>merged back together in order</strong>.
  </p>

  <p>
    Merge sort is <strong>very fast on large data sets</strong> but
    <strong>uses more memory</strong> than other sorting algorithms.
  </p>

  <p><strong>Steps of the merge sort:</strong></p>
  <ol>
    <li>Split the array into sub-arrays containing one element.</li>
    <li>Merge each sub-array into a new, sorted array.</li>
    <li>Repeat this process until a single, fully sorted array is produced.</li>
  </ol>

  <p><strong>Output:</strong> A sorted array.</p>


        <figure><img src="images/CT/merge.gif" height="166" width="380"/></figure>

    </div>
<div class="knowledge-card">
  <h3>Bubble Sort vs Merge Sort</h3>
<figure><img src="images/CT/comparison.png" height="420" width="724"/></figure>
  <table>
    <thead>
      <tr>
        <th>Bubble Sort</th>
        <th>Merge Sort</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          Uses a <strong>brute force</strong> approach by repeatedly starting at the
          beginning of the list and comparing values until a solution is found.
        </td>
        <td>
          Uses a <strong>divide and conquer</strong> approach by breaking the problem
          into smaller sub-problems, solving them, and combining the results.
        </td>
      </tr>

      <tr>
        <td>
          An <strong>in-place sort</strong> because it does not create copies of the array
          and does not require additional memory.
        </td>
        <td>
          Creates copies of sub-lists during sorting, so
          <strong>additional memory</strong> is required.
        </td>
      </tr>

      <tr>
        <td>
          Requires a <strong>large number of comparisons</strong>, making it unsuitable
          for large lists.
        </td>
        <td>
          The number of comparisons grows slowly as the list size increases,
          making it <strong>efficient for large data sets</strong>.
        </td>
      </tr>

      <tr>
        <td>
          Simple algorithm that usually takes <strong>less time to write</strong>.
        </td>
        <td>
          More complex algorithm that takes <strong>longer to write and debug</strong>.
        </td>
      </tr>
    </tbody>
  </table>
</div>
    </div>

    <div class="knowledge-card">
  <h3>Algorithm Efficiency</h3>

  <h4>What is algorithm efficiency?</h4>
  <ul>
    <li>
      <strong>Algorithm efficiency</strong> describes how much
      <strong>time</strong> and <strong>memory</strong> an algorithm takes to complete.
    </li>
    <li>
      There is often <strong>more than one algorithm</strong> that can solve the same problem.
    </li>
    <li>
      Some algorithms are <strong>faster</strong> or use <strong>less memory</strong> than others,
      depending on the situation.
    </li>
  </ul>

  <p><strong>Example data set:</strong></p>
  <p>
    7 &nbsp; 8 &nbsp; 4 &nbsp; 11 &nbsp; 2 &nbsp; 16 &nbsp; 27 &nbsp; 3
  </p>

  <hr>

  <h4>Linear Search – Best and Worst Case</h4>
  <ul>
    <li>
      <strong>Best case:</strong> The item being searched for is the
      <strong>first item</strong> in the list.
    </li>
    <li>
      <strong>Worst case:</strong> The item is the
      <strong>last item</strong> in the list or is <strong>not present</strong>.
    </li>
    <li>
      Linear search checks <strong>each item one by one</strong> from the start.
    </li>
    <li>
      For a list of 1000 items, the worst case could require
      <strong>1000 comparisons</strong>.
    </li>
  </ul>

  <hr>

  <h4>Binary Search – Best and Worst Case</h4>
  <ul>
    <li>
      <strong>Best case:</strong> The item is found after
      <strong>one comparison</strong>.
    </li>
    <li>
      <strong>Worst case:</strong> The item is found in the
      <strong>final comparison</strong>.
    </li>
    <li>
      Binary search uses <strong>divide and conquer</strong>,
      halving the data each time.
    </li>
    <li>
      Even with 1000 items, binary search would need
      <strong>around 10 comparisons</strong>.
    </li>
    <li>
      <strong>Important:</strong> The data <strong>must be sorted</strong> first.
    </li>
  </ul>

  <p><strong>Sorted version of the data:</strong></p>
  <p>
    2 &nbsp; 3 &nbsp; 4 &nbsp; 7 &nbsp; 8 &nbsp; 11 &nbsp; 16 &nbsp; 27
  </p>

  <hr>

  <h4>Bubble Sort – Best and Worst Case</h4>
  <ul>
    <li>
      <strong>Best case:</strong> The data is already in order or almost in order.
    </li>
    <li>
      <strong>Worst case:</strong> The data is in the
      <strong>reverse order</strong>.
    </li>
    <li>
      Bubble sort makes many comparisons, so it is
      <strong>not suitable for large data sets</strong>.
    </li>
  </ul>

  <hr>

  <h4>Merge Sort – Best and Worst Case</h4>
  <ul>
    <li>
      <strong>Best case:</strong> Data is already sorted or nearly sorted.
    </li>
    <li>
      Merge sort is an <strong>out-of-place algorithm</strong>,
      meaning it requires <strong>extra memory</strong>.
    </li>
    <li>
      Memory usage depends on the <strong>size of the data</strong>.
    </li>
    <li>
      It works by <strong>splitting data</strong> into smaller parts,
      then merging them back together in order.
    </li>
    <li>
      Further analysis of merge sort leads into
      <strong>Big O notation</strong> (A-level content).
    </li>
  </ul>

  <p>
    Choosing the most efficient algorithm can make a program
    <strong>faster</strong> and more <strong>memory-efficient</strong>.
  </p>
</div>


    </div>
</section>

<section class="topic-section expanded" id="ct-match-algos">
  <div class="topic-header">
    <span class="topic-arrow">&#9656;</span>
    <h2>Drag & Drop Matching – Searching & Sorting</h2>
  </div>

  <div class="vertical-knowledge">
    <p>Drag each <strong>algorithm</strong> onto the correct <strong>description</strong>, then click <em>Check</em>.</p>

    <div class="match-wrap">
      <div class="match-bank">
        <h3>Algorithms</h3>

        <div class="term" draggable="true" data-term="linear">Linear Search</div>
        <div class="term" draggable="true" data-term="binary">Binary Search</div>
        <div class="term" draggable="true" data-term="bubble">Bubble Sort</div>
        <div class="term" draggable="true" data-term="merge">Merge Sort</div>
      </div>

      <div class="match-targets">
        <h3>Descriptions</h3>

        <div class="target" data-accept="linear">
          <p><strong>Brute force search that checks items one-by-one from the start until found or end reached.</strong></p>
          <div class="dropzone"></div>
        </div>

        <div class="target" data-accept="binary">
          <p><strong>Divide and conquer search that repeatedly halves the list. The list must be sorted.</strong></p>
          <div class="dropzone"></div>
        </div>

        <div class="target" data-accept="bubble">
          <p><strong>Brute force sort that compares adjacent items and swaps them. Repeats passes until no swaps.</strong></p>
          <div class="dropzone"></div>
        </div>

        <div class="target" data-accept="merge">
          <p><strong>Divide and conquer sort that splits the list, then merges back in order. Fast on large lists but uses more memory.</strong></p>
          <div class="dropzone"></div>
        </div>

      </div>
    </div>

    <div class="match-actions">
      <button class="secondary" id="checkMatchAlgos" type="button">Check</button>
      <button class="secondary" id="resetMatchAlgos" type="button">Reset</button>
      <p><strong>Result:</strong> <span id="matchResultAlgos">—</span></p>
    </div>

  </div>
</section>
<script>
/* Shuffle the terms in the bank */
(() => {
  const matchRoot = document.getElementById("ct-match-algos");
  if (!matchRoot) return;

  const bank = matchRoot.querySelector(".match-bank");
  if (!bank) return;

  const terms = Array.from(bank.querySelectorAll(".term"));

  // Fisher–Yates shuffle
  for (let i = terms.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [terms[i], terms[j]] = [terms[j], terms[i]];
  }

  // Re-append in shuffled order
  terms.forEach(term => bank.appendChild(term));
})();

/* Drag & drop logic */
(() => {
  const root = document.getElementById("ct-match-algos");
  if (!root) return;

  const bank = root.querySelector(".match-bank");
  const terms = Array.from(root.querySelectorAll(".term"));
  const targets = Array.from(root.querySelectorAll(".target"));

  const resultEl = root.querySelector("#matchResultAlgos");
  const checkBtn = root.querySelector("#checkMatchAlgos");
  const resetBtn = root.querySelector("#resetMatchAlgos");

  let draggedEl = null;   // can be a .term OR a .placed
  let draggedType = null; // "term" | "placed"

  function clearFeedback() {
    targets.forEach(target => {
      target.querySelector(".dropzone")?.classList.remove("correct-zone", "wrong-zone");
    });
    if (resultEl) resultEl.textContent = "—";
  }

  function makePlaced(termKey, text) {
    const pill = document.createElement("div");
    pill.className = "placed";
    pill.textContent = text;
    pill.dataset.term = termKey;
    pill.draggable = true;

    pill.addEventListener("dragstart", () => {
      draggedEl = pill;
      draggedType = "placed";
      setTimeout(() => pill.style.opacity = "0.5", 0);
    });

    pill.addEventListener("dragend", () => {
      pill.style.opacity = "1";
      draggedEl = null;
      draggedType = null;
    });

    return pill;
  }

  // Enable dragging from the bank
  terms.forEach(t => {
    t.addEventListener("dragstart", () => {
      draggedEl = t;
      draggedType = "term";
      setTimeout(() => t.style.opacity = "0.5", 0);
    });

    t.addEventListener("dragend", () => {
      t.style.opacity = "1";
      draggedEl = null;
      draggedType = null;
    });
  });

  // Bank drop: allow returning a placed pill back to the bank
  bank.addEventListener("dragover", (e) => e.preventDefault());
  bank.addEventListener("drop", (e) => {
    e.preventDefault();
    if (!draggedEl) return;

    if (draggedType === "placed") {
      const termKey = draggedEl.dataset.term;
      draggedEl.remove();

      const original = terms.find(t => t.dataset.term === termKey);
      if (original) original.style.display = "block";

      clearFeedback();
    }
  });

  // Dropzones behavior
  targets.forEach(target => {
    const zone = target.querySelector(".dropzone");
    if (!zone) return;

    zone.addEventListener("dragover", (e) => e.preventDefault());

    zone.addEventListener("drop", (e) => {
      e.preventDefault();
      if (!draggedEl) return;

      // If zone already has a pill, return it to bank first
      const existing = zone.querySelector(".placed");
      if (existing) {
        const oldKey = existing.dataset.term;
        existing.remove();
        const oldTerm = terms.find(t => t.dataset.term === oldKey);
        if (oldTerm) oldTerm.style.display = "block";
      }

      // Place based on what is being dragged
      zone.innerHTML = "";

      if (draggedType === "term") {
        const pill = makePlaced(draggedEl.dataset.term, draggedEl.textContent);
        zone.appendChild(pill);
        draggedEl.style.display = "none"; // hide original in bank
      } else if (draggedType === "placed") {
        zone.appendChild(draggedEl); // move pill
      }

      clearFeedback();
    });
  });

  function resetAll() {
    terms.forEach(t => t.style.display = "block");
    targets.forEach(target => {
      const zone = target.querySelector(".dropzone");
      if (!zone) return;
      zone.innerHTML = "";
      zone.classList.remove("correct-zone", "wrong-zone");
    });
    if (resultEl) resultEl.textContent = "—";
  }

  checkBtn?.addEventListener("click", () => {
    let correct = 0;

    targets.forEach(target => {
      const accept = target.dataset.accept;
      const zone = target.querySelector(".dropzone");
      const placed = zone?.querySelector(".placed");
      const ok = placed && placed.dataset.term === accept;

      zone?.classList.remove("correct-zone", "wrong-zone");
      zone?.classList.add(ok ? "correct-zone" : "wrong-zone");
      if (ok) correct += 1;
    });

    if (resultEl) resultEl.textContent = `${correct} / ${targets.length}`;
  });

  resetBtn?.addEventListener("click", resetAll);

  resetAll();
})();
</script>

  <!-- =========================
       QUESTIONS & ANSWERS
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Check your understanding</h2>
    </div>

    <div class="vertical-knowledge">




    </div>
    </div>
  </section>

</main>

        <button id="printBtn" type="button">
  Print this worksheet
</button>

</main>

<footer>
  &copy; 2025 StudyHubCS
</footer>

<script>
  // Toggle topic sections open/closed
  document.querySelectorAll('.topic-header').forEach(header => {
    header.addEventListener('click', () => {
      const section = header.parentElement;
      section.classList.toggle('collapsed');
      section.classList.toggle('expanded');
    });
  });

  // Show / hide individual answers
  document.querySelectorAll('.answer-toggle').forEach(btn => {
    const answer = btn.nextElementSibling;
    if (!answer) return;

    // ensure hidden initially (CSS also sets .answer display:none)
    answer.style.display = 'none';

    btn.addEventListener('click', () => {
      const open = answer.style.display === 'block';
      answer.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Show answer' : 'Hide answer';
    });
  });

  /* -----------------------------
     Print button
  ------------------------------ */
  const printBtn = document.getElementById("printBtn");
  if (printBtn) {
    printBtn.addEventListener("click", () => {
      window.print();
    });
  }


</script>


</body>
</html>