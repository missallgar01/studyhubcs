<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Software Development</title>
  <link rel="stylesheet" href="../../css/main.css" />
</head>

<body>
<div class="back-container">
    <a href="../A-booklets.html">← Back</a>
  </div>
<header>
   <h1>Software Development – Revision Booklet</h1>
<p>
    Write your answers in the boxes provided.</p>
   <p> Click <strong>Show answer</strong> to reveal model answers.
  </p>
</header>

<main>
    <button class="cmd-btn" onclick="openTip()">Exam Marking Tip</button>

    <!-- Wrap the whole tabs+panels block in this -->
<div class="booklet panels" data-tabs>

  <!-- Tab list -->
  <div role="tablist" aria-label="Algorithms tabs">
    <button
      id="tabbtn-revision"
      type="button"
      role="tab"
      aria-controls="tab-revision"
      aria-selected="true"
      tabindex="0">
      Revision Notes
    </button>

    <button
      id="tabbtn-KC"
      type="button"
      role="tab"
      aria-controls="tab-KC"
      aria-selected="false"
      tabindex="-1">
      Knowledge Check
    </button>
  </div>

  <!-- Panels -->
  <div class="panels">
    <div
      id="tab-revision"
      role="tabpanel"
      aria-labelledby="tabbtn-revision">
     <!-- =========================
       KNOWLEDGE SECTIONS
       ========================= -->
       <div class="vertical-knowledge">


        <h2>Software Development – Notes</h2>

<div class="knowledge-card">
  <h3>Software Development Life Cycles (SDLCs)</h3>
  <p>
    Software can be developed using a variety of approaches. The approach used
    depends on the type of software being developed but most software
    development life cycles (SDLCs) have some stages in common.
  </p>
</div>

<div class="knowledge-card">
  <h3>Analysis</h3>
  <p>
    Stakeholders state what they require from the finished product. This
    information is used to clearly define the problem and the system
    requirements.
  </p>
  <ul>
    <li>Analysing strengths and weaknesses with the current way this problem is being solved</li>
    <li>Considering types of data involved including inputs, outputs, stored data and amount of data</li>
  </ul>

  <h3>Design</h3>
  <p>
    The different aspects of the new system are designed, such as:
  </p>
  <ul>
    <li>Inputs: volume, methods, frequency</li>
    <li>Outputs: volume, methods, frequency</li>
    <li>Security features: level required, access levels</li>
    <li>Hardware set-up: compatibility</li>
    <li>User interface: menus, accessibility, navigation</li>
  </ul>
  <p>A test plan may also be designed at this stage.</p>

  <h3>Development</h3>
  <p>
    The design from the previous stage is used to split the project into
    individual, self-contained modules, which are allocated to teams for
    programming.
  </p>

  <h3>Testing</h3>
  <p>
    The program is tested against the test plan formed in the Design stage.
    There are various types of testing that can be carried out:
  </p>
  <ul>
    <li>
      <strong>Alpha testing</strong><br>
      Alpha testing is carried out in-house by the software development teams
      within the company. Bugs are pinpointed and fixed.
    </li>
    <li>
      <strong>Beta testing</strong><br>
      Beta testing is carried out by end-users after alpha testing has been
      completed. Feedback from users is used to inform the next stage of
      development.
    </li>
    <li>
      <strong>White box testing</strong><br>
      Testing carried out by software development teams in which the test plan
      is based on the internal structure of the program. All possible routes
      through the program are tested.
    </li>
    <li>
      <strong>Black box testing</strong><br>
      Testing where the software is tested without the testers being aware of
      the internal structure of the software. Can be carried out both within
      the company and by end-users. The test plan traces through inputs and
      outputs within the software.
    </li>
  </ul>



  <h3>Implementation</h3>
  <p>
    Once the testing stage has been used to make the appropriate changes to the
    software, it is installed onto the users’ systems.
  </p>



  <h3>Evaluation</h3>
  <p>
    After the implementation stage, the effectiveness of the software is
    evaluated against the system requirements defined at the analysis stage to
    evaluate its suitability in solving the problem.
  </p>
  <p>
    Different criteria are considered, including robustness, reliability,
    portability and maintainability.
  </p>



  <h3>Maintenance</h3>
  <p>
    Any errors or improvements that could be made to the software are flagged
    up by the end-users. Programmers will regularly send out software updates
    to fix any bugs, security issues or make any needed improvements.
  </p>
</div>

<div class="knowledge-card">
  <h3>Waterfall lifecycle</h3>
  <p>
    The traditional waterfall model of software development is very well-known
    and well-defined but is now being replaced with more agile models.
  </p>
  <p>
    The waterfall model is based on a series of stages which are completed in
    sequence, from start to finish.
  </p>

<figure>

          <img src="images/softDev/waterfall.svg"  width="60%"/>

      </figure>

  <h3>Waterfall stages</h3>
  <ul>
    <li>Analysis</li>
    <li>Design</li>
    <li>Implementation</li>
    <li>Evaluation</li>
    <li>Maintenance</li>
  </ul>



  <h3>Feasibility study (TELOS)</h3>
  <p>
    The analysis stage includes a feasibility study in which designers evaluate
    the feasibility of the project using <strong>TELOS</strong>:
  </p>
  <ul>
    <li>
      <strong>Technical:</strong>
      Is the project possible considering the technology available and accessible?
    </li>
    <li>
      <strong>Economic:</strong>
      Can the project be financed in the short-term and the long-term?
    </li>
    <li>
      <strong>Legal:</strong>
      Can the project be solved within the law?
    </li>
    <li>
      <strong>Operational:</strong>
      Can the project be successfully implemented and maintained?
    </li>
    <li>
      <strong>Scheduling:</strong>
      Can the project be completed given the time available?
    </li>
  </ul>



  <h3>Limitations of the Waterfall model</h3>
  <p>
    If a change needs to be made within a project being developed using the
    waterfall model, programmers must revisit all levels between the current
    stage and the stage at which a change needs to be made.
  </p>
  <p>
    This makes the model inflexible and so unsuitable to projects with changing
    requirements.
  </p>
  <p>
    This also means that users have little input as they are only involved at
    the very beginning and end of the waterfall lifecycle, during the analysis
    and evaluation stages.
  </p>
</div>

     <div class="knowledge-card">
  <h3>Agile methodologies</h3>
  <p>
    This refers to a collection of methodologies which aim to improve the
    flexibility of software development and adapt to changes in user
    requirements faster.
  </p>
  <p>
    It is also easier to make improvements or changes to the software.
  </p>

<figure>

          <img src="images/softDev/agile.png"  width="60%"/>

      </figure>

  <h3>How Agile development works</h3>
  <p>
    The problem is broken down into sections which are developed in parallel.
    The design and analysis phase often occur together.
  </p>
  <p>
    Different sections of software can be at different stages of development.
  </p>



  <h3>Iterative development and prototyping</h3>
  <p>
    A working prototype is delivered early and prototypes are built upon and
    improved in an iterative manner so that new prototypes are delivered
    regularly throughout the course of the development cycle.
  </p>



  <h3>User involvement and feedback</h3>
  <p>
    User feedback is gathered regularly and used to refine prototypes and guide
    further development.
  </p>



  <h3>Documentation and user satisfaction</h3>
  <p>
    In agile development methodologies, there is less of a focus on documentation
    and more priority is given to user satisfaction.
  </p>
</div>

          <div class="knowledge-card">
  <h3>Extreme Programming (XP)</h3>
  <p>
    This is an agile model in which the development team consists of a pair of
    programmers alongside a representative end-user.
  </p>


  <h3>User stories</h3>
  <p>
    The model is built on <strong>user stories</strong>. System requirements are
    specified by the end-user and used when designing the program.
  </p>



  <h3>Paired programming</h3>
  <p>
    The aim of paired programming is to produce high-quality code, as the code
    is written by one person and critiqued by the other so it is improved as it
    is written.
  </p>
  <p>
    Programmers work no longer than <strong>forty hours a week</strong> with the
    aim that quality is not compromised.
  </p>



  <h3>Iterations and working versions</h3>
  <p>
    Each iteration through the cycle generates what is called a
    <strong>working version</strong> of the program, which means it could function
    as the final product.
  </p>



  <h3>Documentation and communication</h3>
  <p>
    The iterative nature of development means that it is hard to produce
    high-quality documentation, which is less of a priority.
  </p>
  <p>
    In order for XP to be effective, programmers must communicate effectively.
  </p>
</div>

 <div class="knowledge-card">
  <h3>Spiral model</h3>
  <p>
    The spiral model is built on four key stages with the focus of effectively
    managing risk-heavy projects:
  </p>

     <figure>

          <img src="images/softDev/spiral.svg"  width="60%"/>

      </figure>
  <ul>
    <li>Analysing system requirements</li>
    <li>Pinpointing and mitigating risks</li>
    <li>Development, testing and implementation</li>
    <li>Evaluating to inform the next iteration</li>
  </ul>



  <h3>Risk management and project suitability</h3>
  <p>
    If the project is found to be too risky at any point, the project is
    terminated.
  </p>
  <p>
    However, hiring risk assessors to analyse the risks involved can be
    expensive, which makes this methodology suited to only very large-scale
    projects.
  </p>
</div>

<div class="knowledge-card">
  <h3>Rapid application development (RAD)</h3>
  <p>
    RAD is an iterative methodology which uses partially functioning prototypes
    which are continually built upon.
  </p>
  <p>
    User requirements are initially gathered using focus groups and used to
    develop an incomplete version of the solution which is given to the user
    to trial.
  </p>



  <h3>User feedback and prototyping</h3>
  <p>
    User feedback is then used to generate the next, improved prototype and
    this continues until the prototype matches the requirements of the
    end-users, at which point it becomes the final product.
  </p>



  <h3>When RAD is used</h3>
  <p>
    This is commonly used where user requirements are incomplete or unclear
    at the start.
  </p>
  <p>
    However, as requirements change over the course of the project, additions
    and changes made to the code may be inefficient.
  </p>
</div>

<div class="knowledge-card">
  <h3>Writing and following algorithms</h3>
  <p>
    An algorithm is a set of instructions used to solve a problem. They are
    core to computer science and can be used to tackle a wide range of problems.
  </p>
  <p>
    Regardless of the problem, all good algorithms have certain key qualities:
  </p>
  <ul>
    <li>Inputs must be clearly defined – what is valid and what is invalid?</li>
    <li>Must always produce a valid output for any defined input</li>
    <li>Must be able to deal with invalid inputs</li>
    <li>Must always reach a stopping condition</li>
    <li>Must be well-documented for reference</li>
    <li>Must be well-commented so modifications can easily be made</li>
  </ul>
</div>


          <div class="knowledge-card">
        <table>
  <caption><strong>Merits, drawbacks and uses of programming methodologies</strong></caption>
  <thead>
    <tr>
      <th></th>
      <th>Merits</th>
      <th>Drawbacks</th>
      <th>Uses</th>
    </tr>
  </thead>
  <tbody>

    <tr>
      <td><strong>Waterfall</strong>

      <figure>

          <img src="images/softDev/waterfall.svg"  width="100%"/>

      </figure>


      </td>
      <td>
        <ul>
          <li>Straightforward to manage</li>
          <li>Clearly documented</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Lack of flexibility</li>
          <li>No risk analysis</li>
          <li>Limited user involvement</li>
        </ul>
      </td>
      <td>
        Static, low-risk projects which need little user input, such as a piece of
        general-purpose software
      </td>
    </tr>

    <tr>
      <td><strong>Agile</strong>

      <figure>

          <img src="images/softDev/agile.png" width="100%"/>

      </figure>

      </td>
      <td>
        <ul>
          <li>Produces high quality code</li>
          <li>Flexible to changing requirements</li>
          <li>Regular user input</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Poor documentation</li>
          <li>Requires consistent interaction between user and programmer</li>
        </ul>
      </td>
      <td>
        Small to medium projects with unclear initial requirements.
      </td>
    </tr>

    <tr>
      <td><strong>Extreme Programming</strong></td>
      <td>
        <ul>
          <li>Produces high quality code</li>
          <li>Constant user involvement means high usability</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>High cost of two people working on one project</li>
          <li>Teamwork is essential</li>
          <li>End-user may not be able to be present</li>
        </ul>
      </td>
      <td>
        Small to medium projects with unclear initial requirements requiring excellent usability.
      </td>
    </tr>

    <tr>
      <td><strong>Spiral</strong>


      <figure>

          <img src="images/softDev/spiral.svg" width="100%"/>

      </figure>

      </td>
      <td>
        <ul>
          <li>Thorough risk-analysis and mitigation</li>
          <li>Caters to changing user needs</li>
          <li>Produces prototypes throughout</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Expensive to hire risk assessors</li>
          <li>Lack of focus on code efficiency</li>
          <li>High costs due to constant prototyping</li>
        </ul>
      </td>
      <td>
        Large, risk-intensive projects with a high budget.
      </td>
    </tr>

    <tr>
      <td><strong>Rapid Application Development</strong></td>
      <td>
        <ul>
          <li>Caters to changing user requirements</li>
          <li>Highly usable finished product</li>
          <li>Focus on core features, reducing development time</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Poorer quality documentation</li>
          <li>Fast pace may reduce code quality</li>
        </ul>
      </td>
      <td>
        Small to medium, low-budget projects with short time-frames.
      </td>
    </tr>

  </tbody>
</table>
      </div>
    </div>
    </div>

    <div
      id="tab-KC"
      role="tabpanel"
      aria-labelledby="tabbtn-KC"
      hidden>

      <h2>Check Your Understanding – Questions</h2>


<div class="rev-card qa-card">
  <p>
    <strong>Question:</strong><br>
    A programmer has been asked by a client to create a complex computer program.
    Compare the spiral model and waterfall lifecycle methodologies for this task.
    <br><br>
    You should include:
    <ul>
      <li>how both methodologies could be used to develop a complex computer program</li>
      <li>the benefits of each methodology for this task</li>
      <li>the drawbacks of each methodology for this task</li>
    </ul>
    <em>[9]</em>
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Indicative content / mark scheme:</strong></p>

    <p><strong>AO1 – Knowledge & understanding</strong></p>
    <ul>
      <li>The spiral model has four quadrants: determine objectives, identify and manage risk, develop and test, plan next iteration.</li>
      <li>Client feedback informs future development and prototypes.</li>
      <li>Waterfall has structured analysis, design, development and testing stages.</li>
      <li>Progress to the next stage is not made until the previous stage is completed.</li>
    </ul>

    <p><strong>AO2 – Application</strong></p>
    <ul>
      <li>Spiral relies on frequent client feedback and produces functional prototypes.</li>
      <li>Spiral focuses on risk; projects may be modified or dropped if risk is too great.</li>
      <li>Waterfall relies on clear requirements defined early; changes are difficult later.</li>
    </ul>

    <p><strong>AO3 – Evaluation</strong></p>
    <ul>
      <li>Spiral is better where requirements may change and risk management is important.</li>
      <li>Waterfall is better where requirements are clear and outcomes are known.</li>
      <li>Large teams may suit waterfall due to clearly defined responsibilities.</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>
    <strong>Question:</strong><br>
    A company makes anti-virus software. The programmers use an Extreme Programming
    approach when developing updates.
    <br><br>
    Explain what is meant by Extreme Programming and why it is a suitable approach
    in this case.
    <em>[4]</em>
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Indicative content / mark scheme (1 mark per point):</strong></p>
    <ul>
      <li>Extreme Programming is a software development methodology.</li>
      <li>It is an agile paradigm.</li>
      <li>Focus on producing high quality code.</li>
      <li>Involves paired programming.</li>
      <li>Program is regularly reviewed / iterative.</li>
      <li>Suitable because virus threats are continually changing.</li>
      <li>High emphasis on code quality improves virus detection.</li>
    </ul>
    <p><em>Maximum 4 marks. If no justification of suitability is given, max 3.</em></p>
  </div>
</div>

 <div class="rev-card qa-card">
  <p>
    <strong>Question:</strong><br>
    A software development team is writing a word game.
    The team is using Rapid Application Development.
    <br><br>
    Describe the Rapid Application Development process.
    <em>[4]</em>
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Indicative content / mark scheme:</strong></p>
    <ul>
      <li>A prototype is created.</li>
      <li>The prototype is evaluated and feedback is used.</li>
      <li>Changes are made.</li>
      <li>The process is repeated.</li>
      <li>The prototype eventually becomes the final product.</li>
    </ul>
    <p><em>Maximum 4 marks.</em></p>
  </div>
</div>

  <div class="rev-card qa-card">
  <p>
    <strong>Question:</strong><br>
    A software development company is building an operating system for a mobile phone.
    The developers follow the waterfall lifecycle.
    <br><br>
    i) List three stages of the waterfall lifecycle. <em>[3]</em><br>
    ii) Justify why the waterfall lifecycle is suited to this project. <em>[2]</em><br>
    iii) Give one disadvantage of using the waterfall lifecycle. <em>[1]</em>
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Indicative content / mark scheme:</strong></p>

    <p><strong>i) Stages (any 3):</strong></p>
    <ul>
      <li>Feasibility study</li>
      <li>Analysis</li>
      <li>Design</li>
      <li>Implementation</li>
      <li>Testing</li>
      <li>Evaluation</li>
      <li>Maintenance</li>
    </ul>

    <p><strong>ii) Justification:</strong></p>
    <ul>
      <li>Suited to large-scale projects.</li>
      <li>Operating systems have stable requirements.</li>
    </ul>

    <p><strong>iii) Disadvantage:</strong></p>
    <ul>
      <li>Difficult and costly to respond to changes in requirements.</li>
    </ul>
  </div>
</div>

          <div class="rev-card qa-card">
  <p>
    <strong>Question 5 (12 marks):</strong><br>
    Evaluate the use of different software development methodologies for a
    large-scale software project.
  </p>

  <textarea class="student-answer" placeholder="Plan your answer here (bullet points)..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>High-mark planning structure:</strong></p>
    <ul>
      <li>Define the project type (large-scale, complex, high risk)</li>
      <li>Describe at least two methodologies (e.g. Waterfall, Agile, Spiral)</li>
      <li>Explain how each methodology would be used</li>
      <li>Evaluate benefits for this type of project</li>
      <li>Evaluate drawbacks for this type of project</li>
      <li>Reach a justified conclusion (which is most suitable and why)</li>
    </ul>
  </div>
</div>

          <div class="rev-card qa-card">
  <p>
    <strong>Question 5 (12 marks):</strong><br>
    Evaluate the use of different software development methodologies for a
    large-scale software project.
  </p>

  <textarea class="student-answer" placeholder="Write a full exam-style answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Model top-band answer:</strong></p>

    <p>
      A large-scale software project is complex, expensive, and often involves
      many stakeholders, so the choice of development methodology is important.
    </p>

    <p>
      The <strong>Waterfall lifecycle</strong> uses a structured sequence of
      stages such as analysis, design, implementation, testing, and evaluation.
      This can be beneficial for large projects because it produces clear
      documentation and allows progress to be managed easily. However, it is
      inflexible, as changes require revisiting earlier stages, which can be
      costly and time-consuming.
    </p>

    <p>
      <strong>Agile methodologies</strong> use iterative development with
      frequent user feedback. This allows requirements to change throughout the
      project, which can be useful if user needs are unclear. However, for a
      large-scale project, Agile can be difficult to manage due to reduced
      documentation and the need for constant user involvement.
    </p>

    <p>
      The <strong>Spiral model</strong> combines iterative development with
      detailed risk analysis. This makes it particularly suitable for
      large-scale, high-risk projects, as risks are identified and mitigated
      early. The main drawback is that it is expensive due to the need for
      specialist risk assessors.
    </p>

    <p>
      Overall, the spiral model is often the most suitable methodology for a
      large-scale software project because it balances structure with flexibility
      and focuses heavily on managing risk.
    </p>
  </div>
</div>
</div>

<button id="printBtn" type="button">
  Print this worksheet
</button>


</main>

<footer>
  &copy; 2025 StudyHubCS
</footer>

<script src="../js/booklets.js"></script>
<div id="command-words"></div>

</body>
</html>