<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algorithms</title>
  <link rel="stylesheet" href="../../styles.css" />
</head>

<body>
<div class="back-container">
    <a href="../A-booklets.html">← Back</a>
  </div>
<header>
   <h1>Algorithms – Revision Booklet</h1>
<p>
    Write your answers in the boxes provided.</p>
   <p> Click <strong>Show answer</strong> to reveal model answers.
  </p>
</header>

<main>


    <div class="booklet panels" data-tabs>

  <!-- Tab list -->
  <div role="tablist" aria-label="Algorithms tabs">
    <button
      id="tabbtn-revision"
      type="button"
      role="tab"
      aria-controls="tab-revision"
      aria-selected="true"
      tabindex="0"
    >
      Revision Notes
    </button>

    <button
      id="tabbtn-KC"
      type="button"
      role="tab"
      aria-controls="tab-KC"
      aria-selected="false"
      tabindex="-1"
    >
      Knowledge Check
    </button>
  </div>

  <!-- Panels -->
  <div class="panels">
    <div
      id="tab-revision"
      role="tabpanel"
      aria-labelledby="tabbtn-revision"
    >
      <!-- REVISION CONTENT HERE -->
         <!-- =========================
       KNOWLEDGE SECTIONS (VERTICAL)
       (unchanged, but you can tweak)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Algorithms – Notes</h2>
    </div>

    <div class="vertical-knowledge">

    <div class="knowledge-card">
  <h3>Binary Search vs Linear Search — Comparison</h3>

  <table>
    <thead>
      <tr>
        <th>Feature</th>
        <th>Linear Search</th>
        <th>Binary Search</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Works on</td>
        <td>Any list</td>
        <td>Sorted lists only</td>
      </tr>
      <tr>
        <td>Method</td>
        <td>Checks each item in turn</td>
        <td>Repeatedly halves the list</td>
      </tr>
      <tr>
        <td>Best for</td>
        <td>Small or unsorted lists</td>
        <td>Large sorted lists</td>
      </tr>
      <tr>
        <td>Time complexity</td>
        <td><code>O(N)</code></td>
        <td><code>O(log N)</code></td>
      </tr>
      <tr>
        <td>Main advantage</td>
        <td>Simple and flexible</td>
        <td>Very fast on large datasets</td>
      </tr>
      <tr>
        <td>Main disadvantage</td>
        <td>Slow on large lists</td>
        <td>Requires sorted data</td>
      </tr>
    </tbody>
  </table>
</div>

<div class="knowledge-card">
  <h3>Linear Search — Pseudocode</h3>

    <img src="images/algorithms/linear.gif" height="274" width="816"/>
    <pre>
letters_list = ['A','F','B','E','D','G','C']
position = 0
found = False
search_item = INPUT

WHILE position < LENGTH(letters_list) AND found == False
  IF letters_list[position] == search_item THEN
    PRINT "Item found at position", position
    found = True
  ELSE
    position = position + 1
  ENDIF
ENDWHILE

IF found == False THEN
  PRINT "Item not found"
ENDIF
  </pre>

  <p><strong>Complexity:</strong> <code>O(N)</code></p>
</div>

<div class="knowledge-card">


    <img src="images/algorithms/binary.png" width="70%"/>
    <h3>Binary Search — Pseudocode</h3>

  <pre>
mylist = [1, 2, 5, 7, 11, 14]
item = INPUT
found = False
first = 0
last = LENGTH(mylist) - 1

WHILE found == False AND first <= last
  midpoint = (first + last) DIV 2

  IF mylist[midpoint] == item THEN
    PRINT "Item found at index", midpoint
    found = True
  ELSE
    IF item < mylist[midpoint] THEN
      last = midpoint - 1
    ELSE
      first = midpoint + 1
    ENDIF
  ENDIF
ENDWHILE
  </pre>

  <p><strong>Complexity:</strong> <code>O(log N)</code></p>
</div>

<div class="knowledge-card">
  <h3>Trace Table — Binary Search (Search for 50)</h3>

  <p><strong>List:</strong> <code>[1, 5, 20, 35, 50, 65, 70]</code></p>

  <table>
    <thead>
      <tr>
        <th>Step</th>
        <th>first</th>
        <th>last</th>
        <th>midpoint</th>
        <th>value</th>
        <th>Comparison</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>0</td>
        <td>6</td>
        <td>3</td>
        <td>35</td>
        <td>35 &lt; 50</td>
        <td>first = 4</td>
      </tr>
      <tr>
        <td>2</td>
        <td>4</td>
        <td>6</td>
        <td>5</td>
        <td>65</td>
        <td>65 &gt; 50</td>
        <td>last = 4</td>
      </tr>
      <tr>
        <td>3</td>
        <td>4</td>
        <td>4</td>
        <td>4</td>
        <td>50</td>
        <td>50 == 50</td>
        <td>Found</td>
      </tr>
    </tbody>
  </table>
</div>

<div class="knowledge-card">
  <h3>Trace Table — Linear Search (Search for 5)</h3>

  <p><strong>List:</strong> <code>[10, 8, 1, 21, 7, 32, 5, 11, 0]</code></p>

  <table>
    <thead>
      <tr>
        <th>Step</th>
        <th>position</th>
        <th>value</th>
        <th>Comparison</th>
        <th>Found?</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>1</td><td>0</td><td>10</td><td>≠ 5</td><td>No</td></tr>
      <tr><td>2</td><td>1</td><td>8</td><td>≠ 5</td><td>No</td></tr>
      <tr><td>3</td><td>2</td><td>1</td><td>≠ 5</td><td>No</td></tr>
      <tr><td>4</td><td>3</td><td>21</td><td>≠ 5</td><td>No</td></tr>
      <tr><td>5</td><td>4</td><td>7</td><td>≠ 5</td><td>No</td></tr>
      <tr><td>6</td><td>5</td><td>32</td><td>≠ 5</td><td>No</td></tr>
      <tr><td>7</td><td>6</td><td>5</td><td>= 5</td><td>Yes</td></tr>
    </tbody>
  </table>
</div>


        <div class="knowledge-card">
  <h3>Bubble Sort</h3>

  <p>
    Bubble sort works by repeatedly comparing adjacent items in a list.
    If the item on the right is smaller than the item on the left,
    the two values are swapped.
  </p>

  <p>
    This process is repeated until a complete pass through the list
    occurs with no swaps, meaning the list is sorted.
  </p>

  <h4>How Bubble Sort Works</h4>
  <ul>
    <li>Compare the first and second items</li>
    <li>Swap if the first is greater than the second</li>
    <li>Move to the next pair</li>
    <li>Repeat passes until no swaps occur</li>
    <li>Largest values gradually move to the end of the list</li>
  </ul>


            <img src="images/algorithms/bubble.jpg" height="400" width="668"/><h4>Algorithm (Pseudocode)</h4>
  <pre>
swapMade = True

WHILE swapMade == True
  swapMade = False
  position = 0

  FOR position = 0 TO listLength - 2
    IF list[position] > list[position + 1] THEN
      temp = list[position]
      list[position] = list[position + 1]
      list[position + 1] = temp
      swapMade = True
    ENDIF
  NEXT position

ENDWHILE
  </pre>

  <p>
    The loop continues until a full pass is completed with
    <code>swapMade</code> remaining <code>False</code>.
  </p>

  <h4>Advantages</h4>
  <ul>
    <li>Simple to understand and implement</li>
    <li>Works well for very small lists</li>
  </ul>

  <h4>Disadvantages</h4>
  <ul>
    <li>
      Even when the list is almost sorted, comparisons must still be made
    </li>
    <li>
      Requires multiple passes through the data
    </li>
    <li>
      Very inefficient for large data sets
    </li>
  </ul>

  <p>
    <strong>Complexity:</strong> <code>O(n²)</code> — polynomial
  </p>
</div>

        <div class="knowledge-card">
  <h3>Bubble Sort – Trace Table</h3>

  <p>
    Trace the bubble sort algorithm on the following list:
  </p>

  <p><strong>Initial list:</strong> <code>[65, 40, 30, 10, 100, 6]</code></p>

  <table>
    <thead>
      <tr>
        <th>Pass</th>
        <th>Comparison</th>
        <th>List State</th>
        <th>Swap?</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>65 &gt; 40</td>
        <td>[40, 65, 30, 10, 100, 6]</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>1</td>
        <td>65 &gt; 30</td>
        <td>[40, 30, 65, 10, 100, 6]</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>1</td>
        <td>65 &gt; 10</td>
        <td>[40, 30, 10, 65, 100, 6]</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>1</td>
        <td>65 &lt; 100</td>
        <td>[40, 30, 10, 65, 100, 6]</td>
        <td>No</td>
      </tr>
      <tr>
        <td>1</td>
        <td>100 &gt; 6</td>
        <td>[40, 30, 10, 65, 6, 100]</td>
        <td>Yes</td>
      </tr>

      <tr>
        <td>2</td>
        <td>40 &gt; 30</td>
        <td>[30, 40, 10, 65, 6, 100]</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>2</td>
        <td>40 &gt; 10</td>
        <td>[30, 10, 40, 65, 6, 100]</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>2</td>
        <td>40 &lt; 65</td>
        <td>[30, 10, 40, 65, 6, 100]</td>
        <td>No</td>
      </tr>
      <tr>
        <td>2</td>
        <td>65 &gt; 6</td>
        <td>[30, 10, 40, 6, 65, 100]</td>
        <td>Yes</td>
      </tr>

      <tr>
        <td>3</td>
        <td>30 &gt; 10</td>
        <td>[10, 30, 40, 6, 65, 100]</td>
        <td>Yes</td>
      </tr>
      <tr>
        <td>3</td>
        <td>30 &lt; 40</td>
        <td>[10, 30, 40, 6, 65, 100]</td>
        <td>No</td>
      </tr>
      <tr>
        <td>3</td>
        <td>40 &gt; 6</td>
        <td>[10, 30, 6, 40, 65, 100]</td>
        <td>Yes</td>
      </tr>

      <tr>
        <td>4</td>
        <td>30 &gt; 6</td>
        <td>[10, 6, 30, 40, 65, 100]</td>
        <td>Yes</td>
      </tr>

      <tr>
        <td>5</td>
        <td>10 &gt; 6</td>
        <td>[6, 10, 30, 40, 65, 100]</td>
        <td>Yes</td>
      </tr>

      <tr>
        <td>6</td>
        <td>No swaps in pass</td>
        <td>[6, 10, 30, 40, 65, 100]</td>
        <td>No</td>
      </tr>
    </tbody>
  </table>

  <p>
    The algorithm stops when a full pass is completed with no swaps.
  </p>
</div>

<div class="knowledge-card">
  <h3>Insertion Sort</h3>

  <p>
    Insertion sort is used to sort a “live” list of data.
    It builds a sorted section of the list one item at a time by inserting
    each new value into its correct position among the already-sorted values.
  </p>

  <h4>How Insertion Sort Works</h4>
  <ol>
    <li>Start by looking at the second item in the list.</li>
    <li>Compare it to the items before it and insert it into the correct place.</li>
    <li>Move to the next item and repeat until the end of the list is reached.</li>
  </ol>


    <img src="images/algorithms/insertion.jpg"  width="60%"/><h4>Algorithm (OCR-style Pseudocode)</h4>
  <pre>
FOR position = 1 TO LENGTH(array) - 1
  currentValue = array[position]
  pos = position

  WHILE pos > 0 AND array[pos - 1] > currentValue
    array[pos] = array[pos - 1]
    pos = pos - 1
  ENDWHILE

  array[pos] = currentValue
NEXT position
  </pre>

  <h4>Advantages</h4>
  <ul>
    <li>Very high performance on small lists.</li>
    <li>Works well on “live” data where items are still arriving.</li>
  </ul>

  <h4>Disadvantages</h4>
  <ul>
    <li>Poor performance on large lists.</li>
    <li>Not as fast as merge sort for large data sets.</li>
  </ul>

  <p><strong>Complexity:</strong> <code>O(n²)</code> — polynomial</p>
</div>

<div class="knowledge-card">
  <h3>Insertion Sort – Trace Table (Exam Practice)</h3>

  <p>
    Trace insertion sort on the list:
    <code>[8, 5, 7, 1, 9, 3]</code>
  </p>

  <table>
    <thead>
      <tr>
        <th>Pass (position)</th>
        <th>currentValue</th>
        <th>Shifts / Insertion</th>
        <th>List State After Pass</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>5</td>
        <td>8 shifts right → insert 5 at index 0</td>
        <td>[5, 8, 7, 1, 9, 3]</td>
      </tr>
      <tr>
        <td>2</td>
        <td>7</td>
        <td>8 shifts right → insert 7 at index 1</td>
        <td>[5, 7, 8, 1, 9, 3]</td>
      </tr>
      <tr>
        <td>3</td>
        <td>1</td>
        <td>8, 7, 5 shift right → insert 1 at index 0</td>
        <td>[1, 5, 7, 8, 9, 3]</td>
      </tr>
      <tr>
        <td>4</td>
        <td>9</td>
        <td>No shifts needed → 9 stays in place</td>
        <td>[1, 5, 7, 8, 9, 3]</td>
      </tr>
      <tr>
        <td>5</td>
        <td>3</td>
        <td>9, 8, 7, 5 shift right → insert 3 at index 1</td>
        <td>[1, 3, 5, 7, 8, 9]</td>
      </tr>
    </tbody>
  </table>

  <p>
    Each pass grows the sorted portion on the left side of the list.
  </p>
</div>




<div class="knowledge-card">
  <h3>Merge Sort</h3>

  <p>
    Merge sort can be used efficiently on very large lists of data.
    It uses a <strong>divide and conquer</strong> approach.
  </p>

  <h4>How Merge Sort Works</h4>
  <ol>
    <li>Split the list into sub-arrays of one element.</li>
    <li>Merge each sub-array into a new sorted array.</li>
    <li>Repeat until a single sorted array is produced.</li>
  </ol>


    <img src="images/algorithms/merge.png" width="50%"/>
    <p><strong>Output:</strong> A sorted array</p>

  <h4>Algorithm (High-Level Steps)</h4>
  <pre>
Step 1: Split the array into sub-arrays of 1 element
Step 2: Merge sub-arrays into sorted arrays
Step 3: Repeat merging until one sorted array remains
  </pre>

  <h4>Merge Sort (Recursive Pseudocode)</h4>
  <pre>
function mergeSort(list)
  if LENGTH(list) <= 1 then
    return list
  endif

  mid = LENGTH(list) DIV 2
  left = list[0 : mid]
  right = list[mid : LENGTH(list)]

  leftSorted = mergeSort(left)
  rightSorted = mergeSort(right)

  return merge(leftSorted, rightSorted)
endfunction
  </pre>

  <h4>Merge Procedure (Pseudocode)</h4>
  <pre>
function merge(left, right)
  result = empty list

  WHILE left not empty AND right not empty
    IF left[0] <= right[0] THEN
      add left[0] to result
      remove left[0] from left
    ELSE
      add right[0] to result
      remove right[0] from right
    ENDIF
  ENDWHILE

  add remaining elements of left to result
  add remaining elements of right to result

  return result
endfunction
  </pre>

  <h4>Advantages</h4>
  <ul>
    <li>Very high performance on large lists.</li>
    <li>Consistent speed regardless of initial order.</li>
  </ul>

  <h4>Disadvantages</h4>
  <ul>
    <li>Uses a lot of additional memory.</li>
    <li>More complex to implement than simple sorts.</li>
  </ul>

  <p>
    <strong>Complexity:</strong>
    <code>O(n log n)</code> — logarithmic
    <br>
    Merge sort is substantially faster than bubble sort
    and selection sort for large data sets.
  </p>
</div>

<div class="knowledge-card">
  <h3>Quick Sort</h3>

  <p>
    Quick sort uses a <strong>divide-and-conquer</strong> approach.
    It works by selecting a pivot value and partitioning the list
    into values less than the pivot and values greater than the pivot.
  </p>

  <h4>How Quick Sort Works</h4>
  <ul>
    <li>Choose a pivot value (often the first element)</li>
    <li>Use a left pointer and a right pointer</li>
    <li>Move pointers inward, swapping values where required</li>
    <li>Place the pivot in its correct position</li>
    <li>Repeat on the left and right sublists</li>
  </ul>


    <img src="images/algorithms/quick.jpg" width="70%"/><h4>Algorithm (OCR-Style Pseudocode)</h4>

 <pre>
FUNCTION partition(list, first, last)
    pivotValue = list[first]
    leftMark = first + 1
    rightMark = last
    done ← FALSE

    WHILE done = FALSE
        WHILE leftMark <= rightMark AND list[leftMark] <= pivotValue
            leftMark = leftMark + 1
        ENDWHILE

        WHILE list[rightMark] >= pivotValue AND rightMark >= leftMark
            rightMark = rightMark − 1
        ENDWHILE

        IF rightMark < leftMark THEN
            done = TRUE
        ELSE
            SWAP list[leftMark] WITH list[rightMark]
        ENDIF
    ENDWHILE

    SWAP list[first] WITH list[rightMark]
    RETURN rightMark
ENDFUNCTION

     PROCEDURE quickSortHelper(list, first, last)
    IF first < last THEN
        splitPoint = partition(list, first, last)
        quickSortHelper(list, first, splitPoint − 1)
        quickSortHelper(list, splitPoint + 1, last)
    ENDIF
ENDPROCEDURE
    </pre>


  <h4>Advantages</h4>
  <ul>
    <li>Much faster than bubble sort and insertion sort on large lists</li>
    <li>Efficient average-case performance</li>
  </ul>

  <h4>Disadvantages</h4>
  <ul>
    <li>
      Uses recursion, which can require large amounts of memory
    </li>
    <li>
      Risk of stack overflow for very large lists or poor pivot choices
    </li>
  </ul>

  <p>
    <strong>Complexity:</strong>
    <code>O(n log n)</code> — logarithmic (average case)
  </p>

  <h4>Mark Scheme Points (Typical)</h4>
  <ul>
    <li>Uses divide-and-conquer</li>
    <li>Selects a pivot value</li>
    <li>Uses left and right pointers</li>
    <li>Swaps values when required</li>
    <li>Splits list into two sublists</li>
    <li>Recursively sorts sublists</li>
    <li>Repeats until all sublists contain one element</li>
  </ul>
</div>

      </div>
  </section>


         <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2> Shortest Path</h2>
    </div>
    <div class="topic-body vertical-knowledge">

    <div class="knowledge-card">
  <h3>Shortest Path Algorithms</h3>
  <p>
    Shortest path algorithms are used to find the minimum-cost path between
    nodes in a graph. The “cost” may represent distance, time, or any weighted
    value on the edges.
  </p>
  <p>
    Common shortest path algorithms include:
  </p>
  <ul>
    <li>
      <strong>Dijkstra’s Algorithm</strong> – Finds the shortest path from a
      single start node to all other nodes in a graph with non-negative edge
      weights. It repeatedly selects the unvisited node with the smallest
      tentative distance.
    </li>
    <li>
      <strong>A* (A-star) Algorithm</strong> – An extension of Dijkstra’s
      algorithm that uses a heuristic to estimate the remaining distance to the
      goal. This helps it find the shortest path more efficiently by exploring
      promising routes first.
    </li>
    <li>
      <strong>Breadth-First Search (BFS)</strong> – Can be used as a shortest
      path algorithm in unweighted graphs, as it explores nodes level by level.
    </li>
  </ul>
  <p>
    These algorithms are widely used in navigation systems, games, network
    routing, and AI to determine the most efficient route between locations.
  </p>
</div>
 <div class="knowledge-card">
<h3>Find the shortest path from A to J using Dijkstra’s Algorithm</h3>

<p>
    <ul>
      <li>The purpose of Dijkstra's algorithm finds the shortest path between nodes / vertices in a weighted graph.</li>
      <li>Selects the unvisited node with the shortest path.</li>
      <li>Calculates the distance to each unvisited neighbor</li>
      <li>Updates the distance of each unvisited neighbor if smaller</li>
      <li><mark>Once all neighbours have been visited mark node as visited</mark></li>
    </ul>

   <p>Algorithm</p>
<pre>
# Next Current Node will be the node with the lower F value
Mark the start node as a distance of 0 from itself and all other nodes as an infinite distance
          from the start node.

WHILE the destination node is unvisited:

      Go to the closest unvisited node to A (initially this will be A itself)

      Call this the current node.

      FOR every unvisited node connected to current node

        Calculate the distance to the current plus the distance of the edge to unvisited
        If this distance is less than the currently recorded shortest distance, make it the new shortest distance.


      NEXT Connected node

      Mark the current node as visited.

ENDWHILE
</pre>

 <img src="images/algorithms/dijkstras.png" height="345" width="706"/>

 <p><strong>Visited order:</strong> A → C → F → G → D → E → H → I → J</p>

     <table class="dijkstra-table">
  <thead>
    <tr>
      <th>Node</th>
      <th>Distance from A</th>
      <th>Previous Node</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A (v)</td>
      <td>0</td>
      <td>-</td>
    </tr>
    <tr>
      <td>B (v)</td>
      <td>∞ 75</td>
      <td>A</td>
    </tr>
    <tr>
      <td>C (v)</td>
      <td>∞ 10</td>
      <td>A</td>
    </tr>
    <tr>
      <td>D (v)</td>
      <td>∞ 95, 80</td>
      <td>F, B</td>
    </tr>
    <tr>
      <td>E (v)</td>
      <td>∞ 65</td>
      <td>C</td>
    </tr>
    <tr>
      <td>F (v)</td>
      <td>∞ 40</td>
      <td>C</td>
    </tr>
    <tr>
      <td>G (v)</td>
      <td>∞ 50</td>
      <td>F</td>
    </tr>
    <tr>
      <td>H (v)</td>
      <td>∞ 90</td>
      <td>G</td>
    </tr>
    <tr>
      <td>I (v)</td>
      <td>∞ 90</td>
      <td>D</td>
    </tr>
    <tr>
      <td>J (c)</td>
      <td>∞ 135, 105</td>
      <td>E, H</td>
    </tr>
  </tbody>
</table>

     <p>Final shortest path:</strong> A → C → F → G → H → J</p>

</div>


<div class="knowledge-card">
    <h3><strong>A*</strong></h3>
<p>
        The A* Algorithm is a general path-finding algorithm which is an
        improvement of Dijkstra’s Algorithm.</p>
<p>The structure in graph is searched using the A* algorithm making use of the heuristic values </p>

<p>Heuristic values are Weighting/cost based on estimated distance from final node.
    The purpose of heuristic values in the A* algorithm are used to speed up process of finding solution.</p>


        <p>A <strong>heuristic</strong> is also used – usually an approximate
        distance from a node to the final node.
      </p>

      <p>
        This aims to make the shortest path finding process more
        efficient and much quicker.
      </p>

      <p>
        How effective the A* algorithm is, however, depends largely on
        the accuracy of the heuristics used.
      </p>

      <p>
        Will not visit all nodes.
        Will follow the route with the lowest F value
      </p>

      <p>
        Stops when current node is the destination node
      </p>


<pre>
Begin at the start node and make this the current node.
WHILE the destination node is unvisited:

     For each open node directly connected to the current node:

     Add to the list of open nodes

     Add the distance from the start (g) to the heuristic estimate of the distance (h)

     Assign this value (f) to the node

     NEXT connected node

     Make the unvisited node with the lowest F value the current node

ENDWHILE

</pre>

    <p><img src="images/algorithms/Astar.png" height="343" width="750"/></p>


<table>
  <thead>
    <tr>
      <th>Node</th>
      <th>Distance travelled (g)</th>
      <th>Heuristic (h)</th>
      <th>Distance + Heuristic (f)</th>
      <th>Previous node</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>H</td>
      <td>0</td>
      <td>80</td>
      <td>80</td>
      <td>-</td>
    </tr>
    <tr>
      <td>G</td>
      <td>25</td>
      <td>70</td>
      <td>95</td>
      <td>H</td>
    </tr>
    <tr>
      <td>N</td>
      <td>210</td>
      <td>90</td>
      <td>300</td>
      <td>H</td>
    </tr>
    <tr>
      <td>L</td>
      <td>51 + 25 = 76</td>
      <td>50</td>
      <td>126</td>
      <td>G</td>
    </tr>
    <tr>
      <td>M</td>
      <td>176 + 25 = 201</td>
      <td>20</td>
      <td>221</td>
      <td>G</td>
    </tr>
    <tr>
      <td>E</td>
      <td>307 +  76 = 383</td>
      <td>0</td>
      <td>383</td>
      <td>L</td>
    </tr>
  </tbody>
</table>

       <p>Final path: H → G → L → E</p>
</div>
    </div>
</section>




    </div>

    <div
      id="tab-KC"
      role="tabpanel"
      aria-labelledby="tabbtn-KC"
      hidden
    >
       <!-- =========================
       QUESTIONS & ANSWERS (BY TOPIC)
       ========================= -->

  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Check Your Understanding – Questions</h2>
    </div>
    <div class="vertical-knowledge">

        <!-- =======================
             TOPIC A – Question and answer
             ======================= -->

<div class="rev-card qa-card">

  <p>
    1(a) A program makes use of searching and sorting algorithms.<br><br>
    The following incomplete pseudocode algorithm uses a binary search to find the
    integer <code>numberToFind</code> in the array <code>array</code>.
    It returns the index of the array or <code>-1</code> if the integer is not found.
  </p>

  <p><strong>Complete the pseudocode algorithm.</strong></p>

  <pre>
function binarySearch(array, .....................................)
 lowerbound = 0
 upperbound = array.length - 1
 while true
  if (upperbound &lt; lowerbound) then
   return .............................................
  else
   mid = (upperbound + lowerbound) ...................................
   if (array[mid] &lt; numberToFind) then
    lowerbound = mid .............................................
   elseif (array[mid] &gt; numberToFind) then
    upperbound = mid .............................................
   else
    return .............................................
   endif
  endif
 endwhile
endfunction
  </pre>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">
    <pre>
function binarySearch(array, numberToFind)
 lowerbound = 0
 upperbound = array.length - 1
 while true
  if (upperbound &lt; lowerbound) then
   return -1
  else
   mid = (upperbound + lowerbound) DIV 2
   if (array[mid] &lt; numberToFind) then
    lowerbound = mid + 1
   elseif (array[mid] &gt; numberToFind) then
    upperbound = mid - 1
   else
    return mid
   endif
  endif
 endwhile
endfunction
    </pre>
  </div>
</div>

          <div class="rev-card qa-card">


  <p>
     1(b) An array stores the following data:
  </p>
  <p><strong>20&nbsp;&nbsp;8&nbsp;&nbsp;33&nbsp;&nbsp;16</strong></p>

  <p>
    <strong>(i)</strong> Describe how the given data will be sorted into
    <strong>descending numerical order</strong> using an
    <strong>insertion sort</strong>.
    You should refer to the data in this array throughout your answer.
    <br><em>[5]</em>
  </p>

  <p>
    <strong>(ii)</strong> The size of the array has now been increased to
    seven elements.
    The insertion sort algorithm needs to be tested to ensure it sorts a
    range of test data into descending numerical order.
  </p>

  <p>
    For example, the test data below will test to see if the insertion sort
    will sort data in the opposite order:
  </p>

  <p><strong>1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7</strong></p>

  <p>
    Give <strong>two other different sets of data</strong> that can be used
    to test the insertion sort and state the
    <strong>purpose</strong> of each set of test data.
    Each test needs to have a different purpose.
    <br><em>[2]</em>
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">
    <p><strong>Mark Scheme Answer:</strong></p>

    <p><strong>(i)</strong></p>
    <ul>
      <li>20 becomes the initial sorted list</li>
      <li>8 is compared with 20 and placed after it → <strong>[20, 8]</strong></li>
      <li>33 is compared with 20 and 8, both are shifted right and 33 is inserted at the start → <strong>[33, 20, 8]</strong></li>
      <li>16 is compared with 33, 20 and 8</li>
      <li>16 is inserted between 20 and 8 → <strong>[33, 20, 16, 8]</strong></li>
      <li>This process continues until all elements are in descending order</li>
    </ul>

    <p><strong>(ii)</strong></p>
    <ul>
      <li>
        <strong>Test Data:</strong> 7 6 5 4 3 2 1<br>
        <strong>Purpose:</strong> Tests that the algorithm correctly handles data that is already in descending order
      </li>
      <li>
        <strong>Test Data:</strong> 1 7 2 6 3 5 4<br>
        <strong>Purpose:</strong> Tests that the algorithm correctly sorts mixed, unsorted data
      </li>
    </ul>
  </div>
</div>

          <div class="rev-card qa-card">


  <p>
    2. Kofi and Zac both write a different pseudocode algorithm to read the data from
    a text file into an array.
  </p>

  <p><strong>Kofi's Algorithm</strong></p>
  <pre>
fileName = "data.txt"
fileToRead = openRead(fileName)
for x = 0 to 1000
  anyData = fileToRead.endOfFile()
  if NOT anyData then
    x = 1001
  else
    dataValue = fileToRead.readLine()
    array[x] = dataValue
  endif
next x
fileToRead.close()
  </pre>

  <p><strong>Zac's Algorithm</strong></p>
  <pre>
function readData(fileName)
  array data[100]
  x = 0
  fileToRead = openRead(fileName)
  while NOT fileToRead.endOfFile()
    data[x] = fileToRead.readLine()
    x = x + 1
  endwhile
  return data
endfunction
  </pre>

  <p>
    The solution needs to be used in different programs. Each program will use a
    different text file where the number of lines in the text file is unknown.
  </p>

  <p>
    Compare the suitability of each algorithm for the given problem.
  </p>

  <p>You should include:</p>
  <ul>
    <li>the suitability of the programming techniques including the use of loops</li>
    <li>how effectively the solution meets the requirements</li>
  </ul>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">
    <p><strong>Kofi’s algorithm</strong> is less suitable because it uses a
    count-controlled loop that runs up to 1000 times, which is inappropriate when
    the number of lines in the file is unknown. It may stop reading data early or
    waste processing time. The file name is hard-coded, meaning it cannot easily
    be reused in other programs or with different files, reducing flexibility.
    Although the file is correctly closed, the algorithm cannot be reused easily
    as it is not written as a function.</p>

    <p><strong>Zac’s algorithm</strong> is more suitable because it uses a
    condition-controlled loop that continues until the end of the file is reached,
    making it appropriate when the number of lines is unknown. The algorithm is
    written as a function and takes the file name as a parameter, allowing it to be
    reused in different programs and with different files. This makes it more
    modular and flexible. However, the fixed array size of 100 could cause problems
    if the file contains more than 100 lines.</p>

    <p>Overall, Zac’s solution better meets the requirements due to its use of a
    suitable loop, parameterisation, and reusability.</p>
  </div>
</div>

     <!-- Question 4 -->
    <div class="rev-card qa-card">
  <p>3. Question</p>

  <p><strong>i.</strong> A sorting algorithm has a best time complexity of O(n). Describe what is meant by the best time complexity O(n) for a sorting algorithm.</p>
  <p><strong>ii.</strong> Another sorting algorithm has a worst space complexity of O(log(n)). Describe what is meant by the worst space complexity O(log(n)) for a sorting algorithm.</p>
  <p><strong>iii.</strong> Identify the time complexity that means the time will not change even when the number of items increases.</p>
  <p><strong>iv.</strong> Identify the space complexity that means the amount of memory (space) used will double each time a new item is included.</p>

 <textarea placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button><p><strong>Mark scheme answers:</strong></p>
     <div class="answer">
        <p><strong>i.</strong> Linear — the time will increase in direct proportion to the number of items.</p>
    <p><strong>ii.</strong> Logarithmic — the additional memory space required grows at a decreasing rate as the number of items increases.</p>
    <p><strong>iii.</strong> Constant / O(1).</p>
    <p><strong>iv.</strong> Exponential / O(2<sup>n</sup>) (also accepted: O(K<sup>n</sup>)).</p>
  </div>
        </div>




         <div class="rev-card qa-card">

  <p>
    4(a) The following strings are stored in an array:<br><br>
    “rainbow” “moon” “sun” “stars” “clouds” “tornado”<br><br>
    Explain how a linear search would search the array for the index that stores
    “clouds”.
  </p>

  <textarea placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">
    <p>
      The algorithm compares the first element in the array (“rainbow”) with
      “clouds”. If it is not equal, it moves to the next element (“moon”) and
      repeats the comparison. This process continues for each element in order
      until “clouds” is found, at which point the index is returned. If the end
      of the array is reached without finding “clouds”, the search stops.
    </p>
  </div>
</div>

     <div class="rev-card">

  <p>
    4(b) State why a binary search cannot be used in this example.
  </p>

  <textarea placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">
    <p>
      A binary search cannot be used because the data in the array is not sorted
      into order.
    </p>
  </div>
</div>

      <div class="rev-card">

  <p>
    4(c) Show how an insertion sort will sort the given data into ascending
    alphabetical order:<br><br>
    “rainbow” “moon” “sun” “stars” “clouds” “tornado”
  </p>

  <textarea placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">
    <p>
      First, “rainbow” is taken as the sorted list. “moon” is compared to
      “rainbow” and inserted before it. “sun” is compared and placed after
      “rainbow”. “stars” is compared and inserted between “sun” and “rainbow”.
      “clouds” is compared and inserted at the start of the list. Finally,
      “tornado” is compared and placed at the end. After all passes, the list is
      sorted in ascending alphabetical order.
    </p>
  </div>
</div>

<!-- Q19(a)(i) -->
<div class="rev-card qa-card">

  <p>
    5(a)(i) A program stores data in a 1-dimensional array.<br>
    The program needs to search the array for a number that is input by the user.<br>
    <strong>i.</strong> Describe how a linear search will search the data in the array for a number that has been input.
    <br>[5]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" hidden>
    <p>
      • Start at the first element in the array and compare it to the number to find.<br>
      • If it matches, stop and report success (found / return position).<br>
      • If it does not match, move to the next element and compare again.<br>
      • Repeat until the item is found or the end of the array is reached.<br>
      • If the end is reached without a match, report not found.
    </p>
  </div>
</div>

<!-- Q19(a)(ii) -->
<div class="rev-card qa-card">

  <p>
    <strong>5(a) ii.</strong> State why you would use a linear search rather than a binary search.
    <br>[1]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" hidden>
    <p>
      Because the data does not need to be sorted for a linear search (binary search requires sorted data).
    </p>
  </div>
</div>

<!-- Q19(b) -->
<div class="rev-card qa-card">

  <p>
    5(b) Describe how an array can be used to store and access data in a stack data structure.
    <br>[4]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" hidden>
    <p>
      • Use a stack pointer to indicate the top of the stack (the last element added).<br>
      • PUSH: add new data at the next free position (stackPointer + 1), check for overflow, then increment the stack pointer.<br>
      • POP: remove data from the current top position (stackPointer), check for underflow, then decrement the stack pointer.<br>
      • Access is via Push() and Pop() operations using the stack pointer to index the array.
    </p>
  </div>
</div>

<!-- Q20(i) -->
<div class="rev-card qa-card">


  <p>
    6(i) The array numbers contains 356 numbers to be sorted by the bubble sort algorithm.<br>
    State the maximum number of passes a bubble sort would need to complete to sort 356 numbers into order.
    <br>[1]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" hidden>
    <p>355</p>
  </div>
</div>

<!-- Q20(ii) -->
<div class="rev-card qa-card">

  <p>
    6(ii) State the name of one other sorting algorithm.
    <br>[1]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" hidden>
    <p>Insertion sort</p>
  </div>
</div>

<div class="rev-card qa-card">


  <p>
    7(a) Fig. 5 shows a graph data structure representing a small section of a parcel delivery network. Each node
    represents an address where deliveries need to be made. The edges show the possible routes and distances
    between these deliveries.
  </p>

  <!-- IMAGE PLACEHOLDER: Fig. 5 graph -->

      <img src="images/algorithms/fig5.png" width="50%"/>



  <p>Give one reason why the graph is a visualisation of the problem. <strong>[1]</strong></p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>

  <div class="answer">
    <p><strong>Mark scheme answer (any one):</strong></p>
    <ul>
      <li>Symbols are used to represent the address</li>
      <li>The edges represent possible connections between addresses, not the actual physical routes</li>
    </ul>
  </div>
</div>

          <!-- Question 28(a) -->
<div class="rev-card qa-card">


  <p>
    8(a) Fig. 5 shows a graph data structure representing a small section of a parcel delivery network. Each node
    represents an address where deliveries need to be made. The edges show the possible routes and distances
    between these deliveries.
  </p>

 <img src="images/algorithms/fig5.png"  width="50%"/>

  <p>Give one reason why the graph is a visualisation of the problem. <strong>[1]</strong></p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>Mark scheme (any one):</strong></p>
    <ul>
      <li>Symbols are used to represent the address</li>
      <li>The edges represent possible connections between addresses not the actual physical routes</li>
    </ul>
  </div>
</div>

<!-- Question 28(b) -->
<div class="rev-card qa-card">
  <p>Question 8(b)</p>
  <p><strong>(i)</strong> Show how Dijkstra’s algorithm can be used on the graph shown in Fig. 5 to find the shortest path from the start node A and the end node H.</p>
  <p>You should state the nodes on the final path and the overall distance. Show your working.</p>
  <p>You may choose to use a table to give your answer. <strong>[6]</strong></p>

 <img src="images/algorithms/fig5.png"  width="50%"/>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>Mark scheme:</strong></p>

    <p><strong>(i) Dijkstra table (example full-mark working)</strong></p>
    <pre><code>Node  Distance travelled  Previous node
A     0 / -              N/A / -
B     3                  A
C     13                 E
D     10                 B
E     6                  B
F     9                  E
G     16                 F
H     21 then 19         D then G

Final Path = A, B, E, F, G, H
Distance = 19</code></pre>



    <p><strong>(ii)</strong> Give a similarity and difference between the performance of Dijkstra’s algorithm and the performance of A* algorithm. <strong>[2]</strong></p>
    <p><strong>Similarity (one):</strong></p>
    <ul>
      <li>Both always find the shortest route</li>
      <li>Both are pathfinding algorithms</li>
    </ul>

    <p><strong>Difference (one):</strong></p>
    <ul>
      <li>A* is (usually) more efficient / Dijkstra’s is (usually) slower</li>
      <li>A* uses heuristics to find a solution faster / Dijkstra’s does not use heuristics</li>
    </ul>
  </div>
</div>

  <div class="rev-card qa-card">


<p> 9. A computer program stores data in an array named
words
The data in the array needs to be searched for a value that the user inputs.</p>
<p>
i.   One example of a searching algorithm is a binary search.
     Identify the precondition for a binary search.   [1] </p>

 <p>ii.  A second example of a searching algorithm is a linear search.
    Describe how a linear search works.          </p>                               [4]</pre>



  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" style="display:none;">
    <p><strong>Mark scheme answer (from MS):</strong></p>

    <ul>
      <li>If the data is not in any order / binary search requires the data to be in order</li>
    </ul>

    <p><strong>29(ii)</strong> (1 mark per bullet)</p>
    <ul>
      <li>Start with the first element</li>
      <li>Compare it to the number input</li>
      <li>If it is equal, return the index / True</li>
      <li>If not equal, move to the next element and repeat</li>
      <li>Repeat until it is found, or the end of the array is reached</li>
      <li>If found, return the index where the data was found</li>
      <li>If the end of the list was reached, return -1 / False</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">


  <p>
    10(a) A veterinary surgery uses a two dimensional array to store bookings for customers to bring in their animal
    to see the vet. There are ten possible booking slots during each day.
  </p>




    <p>An example of the two dimensional array is shown in Fig. 1.</p>

      <img src="images/algorithms/fig1.png" height="351" width="497"/>
  <p>Fig. 1 (2D array bookings table)</p>
  <ul>
    <li>The first column stores the booking slot number, ranging between 1 and 10.</li>
    <li>The second column stores the time of the appointment.</li>
    <li>The third column stores the customerID of the customer who has booked that slot.</li>
  </ul>

  <p>
    If a customerID has been entered for a booking slot then the booking slot has been taken. If no customerID has
    been entered then the booking slot is available for booking.
  </p>

  <p>
    When customers make an appointment they often ask for the first available booking slot.
    <strong>Describe how a linear search could be used for this purpose.</strong> [3]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>Mark scheme answer (points to include):</strong></p>
    <ul>
      <li>Start from the beginning / first booking slot</li>
      <li>Search each slot in order / sequentially</li>
      <li>Stop when the first empty slot is found</li>
    </ul>
  </div>
</div>

<!-- =======================
     Q30(b)
     ======================= -->
<div class="rev-card qa-card">


  <p>
    10(b) A function <strong>findFirst</strong> is used to find the first available appointment.
    Write the function <strong>findFirst</strong> that will find the first available appointment and return the booking slot number.
    If no appointments are available then the function should return <strong>"-1"</strong>.
  </p>
  <p>You should write your function using pseudocode or program code. [7]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>Mark scheme (example solution):</strong></p>
    <pre><code>function findFirst()
  count = 0
  do
    found = false
    if customerID[2, count] == "" then
      found = true
    else
      count = count + 1
    endif
  until count == 10 or found == true

  if found == True
    return customerID[0, count]
  else
    return -1
  endif
endfunction</code></pre>

    <p><strong>Mark points (what the examiner is looking for):</strong></p>
    <ul>
      <li>Correctly define a <em>function</em> findFirst</li>
      <li>Logic to check the first slot, then the next slot(s)</li>
      <li>A suitable loop to check all slots</li>
      <li>Return the available booking slot number</li>
      <li>Return -1 if no slots are available</li>
      <li>Sensible variable names + indentation</li>
    </ul>
  </div>
</div>

          <!-- Question 31(a) -->
<div class="rev-card qa-card">


  <p>12(a).Trudi would like to sort an array of numbers into order.</p>
  <p>The numbers before they have been sorted can be seen here.</p>

  <table>
    <tr>
      <td>89</td>
      <td>25</td>
      <td>75</td>
      <td>37</td>
      <td>45</td>
    </tr>
  </table>

  <p>Trudi will use a bubble sort to put these numbers into order from smallest to largest.</p>
  <p>Show the first pass of the bubble sort. You should clearly show each comparison made.</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>Mark scheme answer (first pass):</strong></p>

    <!-- Each row shows the array after each comparison/swap in the first pass -->
    <table style="border-collapse:collapse; margin:10px 0;">
      <tr>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">89</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">25</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">75</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">37</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">45</td>
      </tr>
      <tr>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">25</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">89</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">75</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">37</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">45</td>
      </tr>
      <tr>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">25</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">75</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">89</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">37</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">45</td>
      </tr>
      <tr>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">25</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">75</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">37</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">89</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">45</td>
      </tr>
      <tr>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">25</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">75</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">37</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">45</td>
        <td style="border:1px solid #000; padding:6px 10px; text-align:center;">89</td>
      </tr>
    </table>
  </div>
</div>

<!-- Question 31(b) -->
<div class="rev-card qa-card">


  <p>12(b) Trudi has written a procedure, <code>bubbleSort</code>.</p>


  <pre><code>
01 procedure bubbleSort(numbers)
02   do
03     sorted = true
04     for count = 0 to numbers.length -2
05       if numbers[count] &gt; numbers[count+1] then
06         temp = numbers[count+1]
07         numbers[count+1] = numbers[count]
08         numbers[count] = temp
09         sorted = false
10       endif
11     next count
12   until sorted == true
13 endprocedure</code></pre>

  <p><strong>i.</strong> Identify a line in the procedure <code>bubbleSort</code> where a decision is taken.</p>
  <p><strong>ii.</strong> Identify the name of the parameter used in the procedure <code>bubbleSort</code>.</p>
  <p><strong>iii.</strong> Describe the purpose of the <code>temp</code> variable in the procedure <code>bubbleSort</code>.</p>
  <p><strong>iv.</strong> Describe the purpose of the <code>sorted</code> variable in the procedure <code>bubbleSort</code>.</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>Mark scheme answers:</strong></p>
    <p><strong>i.</strong> Line 5 (allow line 4 and 12).</p>
    <p><strong>ii.</strong> <code>numbers</code></p>
    <p><strong>iii.</strong> To temporarily hold data… / …to allow the contents of two variables to be swapped.</p>
    <p><strong>iv.</strong> Signifies whether or not any swaps have been made in a pass; if still set to true at the end of a pass, then the list is sorted.</p>
  </div>
</div>

    <!-- Question 35(a) -->
<div class="rev-card qa-card">


  <p>13(a) A one dimensional array holds data that needs to be sorted.</p>
  <p>Describe how a quicksort would sort data into ascending order.</p>
  <p>[5]</p>

  <textarea placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" hidden>
    <p><strong>Mark scheme answer (indicative):</strong></p>
    <ul>
      <li>Choose a pivot / identify start and end pointers</li>
      <li>Compare each element to the pivot… / compare start and end pointers</li>
      <li>Put items &lt; pivot in the left sublist</li>
      <li>Put items &gt; pivot in the right sublist</li>
      <li>Choose a pivot in each sublist</li>
      <li>If start pointer is larger than end pointer…</li>
      <li>…then swap data items around</li>
      <li>And repeat the process until each item becomes a pivot</li>
    </ul>
  </div>
</div>

<!-- Question 35(b) -->
<div class="rev-card qa-card">


  <p>13(b) Explain why a quicksort is known as a divide and conquer algorithm.</p>
  <p>[2]</p>

  <textarea placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer" hidden>
    <p><strong>Mark scheme answer (indicative):</strong></p>
    <ul>
      <li>decomposing data sets into smaller subsets</li>
      <li>and then sorting each split subset</li>
      <li>until each subset is sorted</li>
      <li>and then combining the subsets to provide a solution</li>
    </ul>
  </div>
</div>


<!-- Q37 -->
<div class="rev-card qa-card">

  <p>
    14(a)(i) The pseudocode function <code>binarySearch()</code> performs a binary search on the array
    <code>dataArray</code> that is passed as a parameter. The function returns the array index of
    <code>searchValue</code> within the array, and <code>-1</code> if it is not in the array.
  </p>
  <p>The pseudocode binary search algorithm is incomplete.</p>
  <p>Complete the algorithm by filling in the missing statements.</p>

  <pre><code>function binarySearch(dataArray:byref, upperbound, lowerbound, ....................)
  while true
    middle = lowerbound + ((upperbound - lowerbound) ....................)
    if upperbound &lt; lowerbound then
      return ............................
    else
      if dataArray[middle] &lt; searchValue then
        lowerbound = ............................
      elseif dataArray[middle] &gt; searchValue then
        upperbound = ............................
      else
        return ............................
      endif
    endif
  endwhile
endfunction</code></pre><p>[6]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Completed algorithm:</p>
    <pre><code>function binarySearch(dataArray:byref, upperbound, lowerbound, searchValue)
  while true
    middle = lowerbound + ((upperbound - lowerbound) DIV 2)
    if upperbound &lt; lowerbound then
      return -1
    else
      if dataArray[middle] &lt; searchValue then
        lowerbound = middle + 1
      elseif dataArray[middle] &gt; searchValue then
        upperbound = middle - 1
      else
        return middle
      endif
    endif
  endwhile
endfunction</code></pre>
  </div>
</div>

<div class="rev-card qa-card">


  <p>14(a)(ii) The algorithm uses a while loop.</p>
  <p>State a different type of loop that could be used instead of the while loop in the given algorithm.</p><p>[1]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>For example: a <strong>for</strong> loop (or repeat-until loop).</p>
  </div>
</div>


<!-- Q38 -->
<div class="rev-card qa-card">


  <p>
    15(i) Some of the characters in a game will move and interact independently. Taylor is going to use graphs to plan
    the movements that each character can take within the game.
  </p>
  <p>
    DancerGold is one character. The graph shown in Fig. 1 shows the possible movements that DancerGold can make.
  </p>


    <img src="images/algorithms/38.png" width="50%"/>
    <p>
    DancerGold’s starting state is represented by node A. DancerGold can take any of the paths to reach the end
    state represented by node G.
  </p>
  <p>The number on each path represents the number of seconds each movement takes.</p>
  <p>The number in bold below each node is the heuristic value from A.</p>

  <p><strong>Define the term heuristic in relation to the A* algorithm.</strong></p><p>[2]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Heuristic (A*):</p>
    <ul>
      <li>A rule of thumb / estimate / guess</li>
      <li>That estimates the distance / cost from each node to the destination node</li>
      <li>To speed up the process of finding a solution (by indicating which paths to follow first)</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">


  <p>
    15(ii). Perform an A* algorithm on the graph shown in Fig. 1 to find the shortest path from the starting node to the
    end node. Show your working, the nodes visited and the distance. You may choose to use the table below to
    give your answer.

          <img src="images/algorithms/38.png" width="50%"/>
  </p>

  <table>
    <thead>
      <tr>
        <th>Node</th>
        <th>Distance travelled</th>
        <th>Heuristic</th>
        <th>Distance travelled + Heuristic</th>
        <th>Previous node</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>&nbsp;</td><td></td><td></td><td></td><td></td></tr>
      <tr><td>&nbsp;</td><td></td><td></td><td></td><td></td></tr>
      <tr><td>&nbsp;</td><td></td><td></td><td></td><td></td></tr>
      <tr><td>&nbsp;</td><td></td><td></td><td></td><td></td></tr>
      <tr><td>&nbsp;</td><td></td><td></td><td></td><td></td></tr>
      <tr><td>&nbsp;</td><td></td><td></td><td></td><td></td></tr>
      <tr><td>&nbsp;</td><td></td><td></td><td></td><td></td></tr>
    </tbody>
  </table>

  <p>Final path: ________________________________</p>
  <p>Distance: _________________________________</p><p>[8]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Visited / working table (one valid marking version):</p>
    <table border="1" cellpadding="6" cellspacing="0">
      <thead>
        <tr>
          <th>Node</th>
          <th>Distance travelled</th>
          <th>Heuristic</th>
          <th>Distance travelled + Heuristic</th>
          <th>Previous node</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>A (✓)</td><td>0</td><td>90</td><td>90</td><td></td></tr>
        <tr><td>B (✓)</td><td>21</td><td>80</td><td>101</td><td>A</td></tr>
        <tr><td>C (✓)</td><td>42</td><td>65</td><td>107</td><td>A</td></tr>
        <tr><td>D (✓)</td><td>42 + 12 = 54</td><td>50</td><td>104</td><td>C</td></tr>
        <tr><td>E</td><td>21 + 40 = 61</td><td>50</td><td>111</td><td>B</td></tr>
        <tr><td>F (✓)</td><td>42 + 12 + 23 = 77</td><td>30</td><td>107</td><td>D</td></tr>
        <tr><td>G</td><td>42 + 12 + 23 + 33 = 110</td><td>0</td><td>110</td><td>F</td></tr>
      </tbody>
    </table>

    <p><strong>Final path:</strong> A, C, D, F, G</p>
    <p><strong>Distance:</strong> 110</p>
  </div>
</div>

<!-- Q39 -->
<div class="rev-card qa-card">

  <p>16(a) The following pseudocode procedure performs an insertion sort on the array parameter.</p>

  <pre><code>procedure insertionSort(dataArray:byRef)
  for i = 1 to dataArray.Length - 1
    temp = dataArray[i]
    tempPos = i - 1
    exit = false
    while tempPos &gt;= 0 and exit == false
      if dataArray[tempPos] &lt; temp then
        dataArray[tempPos + 1] = dataArray[tempPos]
        tempPos = tempPos - 1
      else
        exit = true
      endif
    endwhile
    dataArray[tempPos + 1] = temp
  next i
endprocedure</code></pre>

  <p>
    Two sorting algorithms are merge sort and quick sort.
    Compare the use of merge sort, quick sort and insertion sort on an array with a small number of elements,
    and on an array with a very large number of elements.
  </p>
  <p>You should make reference to the time complexities of each algorithm using the Big O notation in your answer.</p>
<p>[9]</p>
  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Indicative comparison (using Big O):</p>
    <ul>
      <li><strong>Insertion sort</strong>: time O(n²) average/worst; best-case O(n) if nearly sorted; space O(1).</li>
      <li><strong>Merge sort</strong>: time O(n log n) (best/avg/worst); space O(n) extra (needs additional memory).</li>
      <li><strong>Quick sort</strong>: avg time O(n log n); worst-case O(n²) (e.g. poor pivots); extra space grows due to recursion stack (often ~O(log n) average).</li>
    </ul>
    <p><strong>Small arrays:</strong> insertion can be acceptable (simple, low overhead); space usually not important.</p>
    <p><strong>Very large arrays:</strong> O(n log n) approaches (merge/quick) generally more appropriate; merge uses more memory, quick can degrade to O(n²) in worst case.</p>
  </div>
</div>

<div class="rev-card qa-card">


  <p>16(b) Describe how a bubble sort will sort an array of 10 elements.</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Compare each pair of adjacent elements</li>
      <li>If they are not in the correct order then swap the elements</li>
      <li>If they are in the correct order then do no swap elements</li>
      <li>When you reach the end of the array return to the start</li>
      <li>Repeat n elements time</li>
      <li>Set a flag to be false whenever a swap is made, and repeat the loop if the flag is not false</li>
    </ul>
  </div>
</div><p>[6]</p>

<!-- Q40 -->
<div class="rev-card qa-card">


  <p>
    17(a)(i) Kira is creating a computer game where the user can play against the computer.
    In each turn, each character can make one move from a selection of possible moves.
  </p>
  <p>
    Kira uses a tree data structure shown in Fig. 1 to identify the range of possible moves the computer can make
    from starting position A. Each connection is a move, with each node representing the result of the move.
  </p>


    <img src="images/algorithms/40.png" height="510" width="724"/>
    <p>Kira wants to make some changes to the data that is stored in the tree structure shown in Fig. 1.</p>

  <p><strong>The move represented by node ‘E’ needs to be deleted.</strong></p>
  <p>Describe the steps an algorithm will follow to delete node ‘E’ from the tree.</p><p>[3]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Search the tree to find the location of node E (by example of search)</li>
      <li>Replace the content of node E with blank/null/equivalent</li>
      <li>Make node A point to the node H</li>
      <li>Add node E to the empty node list</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">


  <p>17(a)(ii) <strong>The move represented by the node ‘K’ needs to be added. Node ‘K’ needs to be joined to node ‘G’.</strong></p>
  <p>Describe the steps the algorithm will follow to add node ‘K’ to the right of node ‘G’.</p><p>[3]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Search the tree to find the location of node G (by example of search)</li>
      <li>Create a new node with value K</li>
      <li>Add a pointer from node G to the new node</li>
      <li>Make node K point to null/equivalent</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">

  <p>17(b) Kira could have used a graph data structure to represent the moves in her game.</p>
  <p>Give two similarities and two differences between a tree and a graph data structure.</p><p>[4]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Similarities (any two):</strong></p>
    <ul>
      <li>Both consist of nodes</li>
      <li>Both are connected by edges/links</li>
      <li>Both are non-linear data structures</li>
      <li>Both are dynamic data structures</li>
    </ul>

    <p><strong>Differences (any two):</strong></p>
    <ul>
      <li>Tree is 1-directional whereas a graph is 2-directional</li>
      <li>Tree has a root node whereas a graph does not have a (clear) root node</li>
      <li>Tree will not have cycles whereas graphs can contain cycles</li>
      <li>Tree will not be weighted whereas edges in a graph can be weighted</li>
    </ul>
  </div>
</div>

<!-- Q41 -->
<div class="rev-card qa-card">

  <p>18(a) Hugh has written a recursive function called <code>thisFunction()</code> using pseudocode.</p>

  <pre><code>function thisFunction(theArray, num1, num2, num3)
  result = num1 + ((num2 - num1) DIV 2)
  if num2 &lt; num1 then
    return -1
  else
    if theArray[result] &lt; num3 then
      return thisFunction(theArray, result + 1, num2, num3)
    elseif theArray[result] &gt; num3 then
      return thisFunction(theArray, num1, result - 1, num3)
    else
      return result
    endif
  endif
endfunction</code></pre>

  <p>The function DIV calculates integer division, e.g. 5 DIV 3 = 1</p>

  <p>theArray has the following data:</p>
  <table>
    <tr><th>Index:</th><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
    <tr><th>Data:</th><td>5</td><td>10</td><td>15</td><td>20</td><td>25</td><td>30</td><td>35</td><td>40</td></tr>
  </table>

  <p>Trace the algorithm, and give the final return value, when it is called with the following statement:</p>
  <pre><code>thisFunction(theArray, 0, 7, 35)</code></pre><p>[5]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Trace (one marking version):</p>
    <table>
      <thead>
        <tr>
          <th>Function call</th><th>num1</th><th>num2</th><th>num3</th><th>result</th>
        </tr>
      </thead>
      <tbody>
        <tr><td>thisFunction(theArray,0,7,35)</td><td>0</td><td>7</td><td>35</td><td>3</td></tr>
        <tr><td>thisFunction(theArray,4,7,35)</td><td>4</td><td>7</td><td>35</td><td>5</td></tr>
        <tr><td>thisFunction(theArray,6,7,35)</td><td>6</td><td>7</td><td>35</td><td>6</td></tr>
      </tbody>
    </table>
    <p><strong>Final return value:</strong> 6</p>
  </div>
</div>

<div class="rev-card qa-card">


  <p>18(b) State the name of the standard algorithm <code>thisFunction()</code> performs.</p><p>[1]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Binary search</strong></p>
  </div>
</div>

<div class="rev-card qa-card">

  <p>18(c) Hugh could have written <code>thisFunction()</code> using iteration instead of recursion.</p>
  <p>Compare two differences between recursion and iteration.</p><p>[4]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Any two, for example:</p>
    <ul>
      <li>Recursion uses more memory; iteration uses less memory.</li>
      <li>Recursion adds stack frames (new variables/return addresses); iteration reuses the same variables.</li>
      <li>Recursion can run out of stack space; iteration will not run out of stack space in the same way.</li>
      <li>Recursion calls itself (self-referential); iteration uses loops instead.</li>
      <li>Recursion can be more elegant/fewer lines; iteration can be longer/harder to follow (or vice versa depending on solution).</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">

  <p>18(d) Rewrite the function <code>thisFunction()</code> so that it uses iteration instead of recursion.</p>
  <p>You should write your answer using pseudocode or program code.</p><p>[6]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Example iterative version:</p>
    <pre><code>function thisFunction(theArray, num1, num2, num3)
  while (true)
    result = num1 + ((num2 - num1) DIV 2)

    if num2 &lt; num1 then
      return -1
    else
      if theArray[result] &lt; num3 then
        num1 = result + 1
      elseif theArray[result] &gt; num3 then
        num2 = result - 1
      else
        return result
      endif
    endif
  endwhile
endfunction</code></pre>
  </div>
</div>

<!-- Q42 -->
<div class="rev-card qa-card">

  <p>19(a) State why the tree shown in Fig. 1 is not an example of a binary search tree.</p><p>[1]</p>

    <img src="images/algorithms/40.png" width="50%"/>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>For example:</p>
    <ul>
      <li>One node (node A) has more than 2 connections</li>
      <li>Nodes aren’t ordered (e.g. F is C’s left child)</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">

  <p>19(b) State what type of pointers are used to store nodes I, F, J and H so they do not point to any other nodes.</p>
<p>[1]</p>
  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Null pointers</strong></p>
  </div>
</div>

<div class="rev-card qa-card">

  <p>
    19(c) Kira wants the program to traverse the tree to evaluate the range of possible moves.
    Show how a breadth-first traversal would traverse the tree shown in Fig. 1.
  </p><p>[4]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Take A as starting node</li>
      <li>Visit B, C and E</li>
      <li>Visit D, F, G and H</li>
      <li>Visit I and J</li>
    </ul>
    <p>Order: <strong>A, B, C, E, D, F, G, H, I, J</strong></p>
    <p><em>(Reverse ordering from right to left may also be allowed.)</em></p>
  </div>
</div>

<!-- Q43 -->
<div class="rev-card qa-card">

  <p>20(a) Poppy would like to use a bubble sort to sort 250 000 numbers into order from lowest to highest.</p>
  <p>Currently the first five numbers before they have been sorted are:</p>
  <p>195 584 &nbsp;&nbsp; 167 147 &nbsp;&nbsp; 158 187 &nbsp;&nbsp; 160 125 &nbsp;&nbsp; 184 236</p>
  <p>Currently the last five numbers before they have been sorted are:</p>
  <p>1058 &nbsp;&nbsp; 19 558 &nbsp;&nbsp; 1915 &nbsp;&nbsp; 20 215 &nbsp;&nbsp; 15</p>

  <p>State the name of one other sorting algorithm that Poppy could have used.</p><p>[1]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Any valid sorting algorithm, e.g. <strong>merge sort</strong> or <strong>quick sort</strong>.</p>
  </div>
</div>

<div class="rev-card qa-card">

  <p>20(b)<strong>* Discuss</strong> how a bubble sort works and how efficient it will be when sorting these 250 000 items into order from lowest to highest.</p>
<p>[9]</p>
  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>Mark-scheme style points you could include:</p>
    <ul>
      <li>Bubble sort compares adjacent elements and swaps them if they are in the wrong order.</li>
      <li>It repeats passes through the list until no swaps are needed (sorted).</li>
      <li>Time complexity is O(n²) (very inefficient for large n like 250 000).</li>
      <li>It would require a huge number of comparisons/swaps, so it would take a very long time.</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">


  <p>20(c) State the number of comparisons that will need to be made in the first pass of the bubble sort.</p><p>[1]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>First pass comparisons = n − 1.</p>
    <p>For 250 000 items: <strong>249,999 comparisons</strong>.</p>
  </div>
</div>

<!-- Question 44(a) -->
<div class="rev-card qa-card">


  <div>
    <p>21(a) Oscar owns a taxi company. He would like a program to handle taxi bookings from customers.</p>
    <p>When a customer makes a booking, they are placed into a queue data structure until a taxi driver is available.</p>

    <p><strong>i.</strong> Explain why Oscar uses a queue data structure rather than a stack data structure. <strong>[4]</strong></p>

    <p><strong>ii.</strong> Oscar has written a procedure, <code>enqueue</code>, to be able to add a customer number to the queue. The queue is not circular.</p>

    <pre><code>01 procedure enqueue(custNumber)
02 maxElements = 10
03 if (tail + 1) &gt; maxElements then
04 print ("Error, queue is full")
05 else
06 head = head + 1
07 queue[head] = custNumber
08 endif
09 endprocedure</code></pre>

    <p>State the name of the parameter used in the procedure <code>enqueue</code>. <strong>[1]</strong></p>

    <p><strong>iii.</strong> The procedure <code>enqueue</code> contains an error on line 06 and line 07.</p>
    <p>Rewrite lines 06 and 07 of the procedure <code>enqueue</code> so that the queue works correctly. <strong>[2]</strong></p>

    <p><strong>iv.</strong> Identify the logical condition in the procedure <code>enqueue</code> that affects whether a new item can be added to the queue. <strong>[1]</strong></p>
  </div>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>i. (Mark scheme points)</strong></p>
    <ul>
      <li>A queue is <mark>First In First Out (FIFO)</mark>.</li>
      <li>Therefore bookings will be executed in the order they have been received.</li>
      <li>A stack is <mark>Last In First Out (LIFO)</mark>.</li>
      <li>Therefore the bookings would be executed from the most recent booking.</li>
    </ul>

    <p><strong>ii.</strong> <mark>custNumber</mark></p>

    <p><strong>iii. Corrected lines 06–07</strong></p>
    <pre><code>06 tail = tail + 1
07 queue[tail] = custNumber</code></pre>

    <p><strong>iv.</strong> The condition that controls whether a new item can be added is:</p>
    <ul>
      <li><mark>(tail + 1) &gt; maxElements</mark> (i.e. if the tail is greater than 10 / maxElements then the queue is full)</li>
    </ul>
    <p>Acceptable equivalent forms:</p>
    <ul>
      <li><mark>not((tail + 1) &gt; maxElements)</mark></li>
      <li><mark>(tail + 1) &lt;= maxElements</mark></li>
    </ul>
  </div>
</div>

<!-- Question 44(b) -->
<div class="rev-card qa-card">


  <div>
    <p>21(b) Some of Oscar’s customers are rated as gold. Customers who are rated as gold are given priority when they make a taxi booking.</p>
    <p>Some customers rated as gold are shown here:</p>
    <p>Arshad Betty Dave Freddie Harry Jimmy Kanwal Lynn Siad Tommy Will</p>

    <p>When a customer makes a booking, Oscar will make use of a binary search to check if they are gold rated.</p>
    <p>Oscar would like to know if ‘Tommy’ is gold rated.</p>

    <p><strong>i.</strong> State the three values that will be set as the midpoints and then checked against ‘Tommy’ on each iteration of the binary search. Show your working here. <strong>[3]</strong></p>

    <p><strong>ii.</strong> Oscar has 75 000 customers stored in his program. Describe the benefit to Oscar of using binary searches in his program. <strong>[2]</strong></p>

    <p><strong>iii.</strong> State one other search algorithm that Oscar could have used. <strong>[1]</strong></p>

    <p><strong>iv.</strong> State the pre-condition which has been met, which meant that Oscar did not need to use the search algorithm you stated in the part above. <strong>[1]</strong></p>
  </div>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>i. Midpoints checked (mark scheme)</strong></p>
    <ul>
      <li><mark>5</mark> (Jimmy)</li>
      <li><mark>8</mark> (Siad)</li>
      <li><mark>9</mark> (Tommy)</li>
    </ul>

    <p><strong>ii. Benefit (mark scheme examples)</strong></p>
    <ul>
      <li><mark>Efficient</mark></li>
      <li>Does not need to search every single element / uses <mark>divide and conquer</mark></li>
    </ul>

    <p><strong>iii.</strong> <mark>Linear search</mark> / <mark>Serial search</mark></p>

    <p><strong>iv.</strong> The items are in <mark>alphabetical order</mark> / the items are <mark>sorted</mark>.</p>
  </div>
</div>


<!-- Question 16(b) -->
<div class="rev-card qa-card">


  <p>22. Use Dijkstra’s algorithm to find the shortest path from node <strong>A</strong> to node <strong>G</strong> on the graph shown in <strong>Figure 4</strong>.</p>


    <img src="images/algorithms/16.png" width="50%"/>
    <p style="margin:0;"><strong>Image placeholder:</strong> Figure 4 (Graph for Dijkstra’s algorithm)</p>


  <p>Complete the table:</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea><p>[6]</p>

  <button class="secondary answer-toggle" type="button">Show answer</button>
  <div class="answer">
    <p><strong>Final path:</strong> A, D, G</p>
    <p><strong>Final distance:</strong> 14</p>

    <table style="width:100%; border-collapse:collapse; margin-top:10px;">
      <thead>
        <tr>
          <th style="text-align:left; border-bottom:1px solid #ccc; padding:6px;">Node</th>
          <th style="text-align:left; border-bottom:1px solid #ccc; padding:6px;">Distance travelled</th>
          <th style="text-align:left; border-bottom:1px solid #ccc; padding:6px;">Previous node</th>
        </tr>
      </thead>
      <tbody>
        <tr><td style="padding:6px; border-bottom:1px solid #eee;">A</td><td style="padding:6px; border-bottom:1px solid #eee;">0</td><td style="padding:6px; border-bottom:1px solid #eee;">- / N/A / blank / None</td></tr>
        <tr><td style="padding:6px; border-bottom:1px solid #eee;">B</td><td style="padding:6px; border-bottom:1px solid #eee;">5</td><td style="padding:6px; border-bottom:1px solid #eee;">A</td></tr>
        <tr><td style="padding:6px; border-bottom:1px solid #eee;">C</td><td style="padding:6px; border-bottom:1px solid #eee;">2</td><td style="padding:6px; border-bottom:1px solid #eee;">A</td></tr>
        <tr><td style="padding:6px; border-bottom:1px solid #eee;">D</td><td style="padding:6px; border-bottom:1px solid #eee;">10</td><td style="padding:6px; border-bottom:1px solid #eee;">A</td></tr>
        <tr><td style="padding:6px; border-bottom:1px solid #eee;">E</td><td style="padding:6px; border-bottom:1px solid #eee;">7</td><td style="padding:6px; border-bottom:1px solid #eee;">B</td></tr>
        <tr><td style="padding:6px; border-bottom:1px solid #eee;">F</td><td style="padding:6px; border-bottom:1px solid #eee;">15</td><td style="padding:6px; border-bottom:1px solid #eee;">E</td></tr>
        <tr>
          <td style="padding:6px;">G</td>
          <td style="padding:6px;">19 → 14</td>
          <td style="padding:6px;">E → D</td>
        </tr>
      </tbody>
    </table>

    <p style="margin-top:10px;">
      (Key marking point: show that <strong>G = 19 from E</strong> is later overwritten by <strong>G = 14 from D</strong>.)
    </p>
  </div>
</div>
    </div>
  </section>
    </div>
  </div>

</div>







     <button id="printBtn" type="button">
  Print this worksheet
</button>

</main>


<footer>
  &copy; 2025 StudyHubCS
</footer>
<script src="js/booklets.js"></script>

</body>
</html>