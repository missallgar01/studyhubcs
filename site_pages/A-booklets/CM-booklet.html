<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Software</title>
  <link rel="stylesheet" href="../../styles.css" />
</head>

<body>
<div class="back-container">
    <a href="../A-booklets.html">← Back</a>
  </div>
<header>
   <h1>Computational Methods – Revision Booklet</h1>
<p>
    Write your answers in the boxes provided.</p>
   <p> Click <strong>Show answer</strong> to reveal model answers.
  </p>
</header>

<main>

  <!-- =========================
       KNOWLEDGE SECTIONS (VERTICAL)
       (unchanged, but you can tweak)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Software & Operating Systems – Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">

        <div class="knowledge-card">
      <h3>Computational Methods</h3>
      <p>
        This topic covers computational approaches to problem solving, including problem recognition,
        decomposition, abstraction, divide and conquer, heuristics, backtracking, data mining,
        performance modelling, pipelining, and visualisation.
      </p>
    </div>


<div class="knowledge-card">

  <table>
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Exam Board Definition</th>
        <th>Meaning</th>
        <th>Positives / Negatives</th>
        <th>Simple Illustrations</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Problem Recognition</td>
        <td>Knowing what the problem is</td>
        <td>Identifying the key requirements of a solution</td>
        <td>− Not all problems are suitable for computers</td>
        <td>Identifying requirements of a mortgage calculator</td>
      </tr>

      <tr>
        <td>Backtracking</td>
        <td>Returning to a previous successful state</td>
        <td>Trying alternative solutions when one fails</td>
        <td>
          + Useful in AI and logic problems<br>
          − Only useful for sequential problems
        </td>
        <td>Checking Wi-Fi after email fails to send</td>
      </tr>

      <tr>
        <td>Data Mining</td>
        <td>Analysing large datasets to discover information</td>
        <td>Finding hidden patterns and trends</td>
        <td>
          + Detects anomalies<br>
          + Competitive advantage
        </td>
        <td>Placing beer next to nappies to increase sales</td>
      </tr>

      <tr>
        <td>Heuristics</td>
        <td>A best-guess approach to problem solving</td>
        <td>Accepting a good-enough solution to save time</td>
        <td>
          + Reduces computation time<br>
          − May not find the optimal solution
        </td>
        <td>Estimating congestion during route planning</td>
      </tr>

      <tr>
        <td>Performance Modelling</td>
        <td>Mathematical analysis to assess efficiency</td>
        <td>Predicting performance before implementation</td>
        <td>
          + Cost-effective and safe<br>
          − Requires accurate data
        </td>
        <td>Simulating exam systems or train networks</td>
      </tr>

      <tr>
        <td>Pipelining</td>
        <td>Output of one process becomes input to another</td>
        <td>Queuing processes in sequence</td>
        <td>
          + Faster execution<br>
          − Branching may reset pipeline
        </td>
        <td>Mixing, baking, cooling and icing a cake</td>
      </tr>

      <tr>
        <td>Visualisation</td>
        <td>Representing reality using diagrams and charts</td>
        <td>Making data easier to analyse</td>
        <td>
          + Easier to spot patterns and relationships
        </td>
        <td>Flowcharts, system diagrams, class diagrams</td>
      </tr>
    </tbody>
  </table>
</div>

</div>
      </div>
  </section>

    <section class="topic-section expanded">
  <div class="topic-header">
    <span class="topic-arrow">&#9656;</span>
    <h2>Notes</h2>
  </div>

  <div class="topic-body vertical-knowledge">



    <div class="knowledge-card">
      <h3>Features that make a problem solvable by computational methods</h3>
      <p>
        A problem is solvable by computational methods if it can be completed by an algorithm
        within a realistic and finite time. These problems usually involve calculations, data
        processing, and well-defined inputs and outputs.
        <br><br>
        Some problems are theoretically computable but may be impractical due to excessive
        processing power, memory requirements, or time constraints.
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Problem recognition</h3>
      <p>
        Once it is established that a problem is computable, the next step is to identify the problem clearly.
        Stakeholders define what they want the final system to achieve.
        <br><br>
        Problem recognition involves:
        <ul>
          <li>Understanding user requirements</li>
          <li>Analysing strengths and weaknesses of existing solutions</li>
          <li>Considering types of data involved, including inputs, outputs, and stored data</li>
        </ul>
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Problem decomposition</h3>
      <p>
        Decomposition involves breaking a complex problem into smaller, manageable sub-problems.
        Each sub-problem can be developed as a self-contained subroutine.
        <br><br>
        Benefits include:
        <ul>
          <li>Reduced complexity</li>
          <li>Reuse of existing modules and libraries</li>
          <li>Parallel development by multiple programmers</li>
          <li>Simpler testing and debugging</li>
        </ul>
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Divide and conquer</h3>
      <p>
        Divide and conquer is a problem-solving strategy that repeatedly breaks a problem into smaller parts.
        It consists of three stages:
        <ul>
          <li><strong>Divide</strong> – split the problem into smaller sub-problems</li>
          <li><strong>Conquer</strong> – solve each sub-problem, often recursively</li>
          <li><strong>Merge</strong> – combine solutions to form the final result</li>
        </ul>
        Examples include binary search, merge sort, and quick sort.
        <br><br>
        Dividing the problem in half at each stage can lead to logarithmic time complexity (O(log n)),
        but recursive approaches can risk stack overflow and make debugging more difficult.
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Abstraction</h3>
      <p>
        Abstraction removes unnecessary detail so the programmer can focus on the core problem.
        This simplifies problem solving and improves clarity.
        <br><br>
        Types of abstraction include:
        <ul>
          <li><strong>Representational abstraction</strong> – simplifies data representation</li>
          <li><strong>Abstraction by generalisation</strong> – groups similar components together</li>
          <li><strong>Layered abstraction</strong> – divides systems into layers with hidden details</li>
        </ul>
        Abstraction allows reuse of code and libraries and enables large projects to be split across teams.
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Backtracking</h3>
      <p>
        Backtracking is a recursive, depth-first technique used to explore all possible solutions.
        When a path leads to an invalid solution, the algorithm backtracks to the last valid decision
        point and tries an alternative.
        <br><br>
        Common examples include maze solving and constraint satisfaction problems.
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Data mining</h3>
      <p>
        Data mining involves analysing large datasets to identify patterns, trends, correlations,
        or anomalies. Data is often collected from multiple sources.
        <br><br>
        Uses include:
        <ul>
          <li>Predicting customer behaviour</li>
          <li>Identifying seasonal trends</li>
          <li>Supporting business and marketing decisions</li>
        </ul>
        Data mining must comply with data protection legislation such as GDPR.
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Heuristics</h3>
      <p>
        Heuristics are “rule-of-thumb” methods that produce approximate solutions when exact solutions
        are impractical due to time or resource constraints.
        <br><br>
        They do not guarantee optimal solutions but aim to produce good-enough answers quickly.
        Heuristics are used in artificial intelligence, A* search, machine learning,
        and solving NP-hard problems such as the Travelling Salesman Problem.
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Performance modelling</h3>
      <p>
        Performance modelling uses mathematical models to predict how a system will behave under
        different conditions.
        <br><br>
        Advantages include:
        <ul>
          <li>Lower cost than real-world testing</li>
          <li>Faster evaluation</li>
          <li>Improved safety in critical systems (e.g. aviation)</li>
        </ul>
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Pipelining</h3>
      <p>
        Pipelining divides a process into stages so that multiple tasks can be processed simultaneously.
        Each stage passes its output to the next, similar to a production line.
        <br><br>
        This improves efficiency and speeds up overall processing.
      </p>
    </div>

    <div class="knowledge-card">
      <h3>Visualisation</h3>
      <p>
        Visualisation presents data in graphical or structured formats such as graphs, charts,
        trees, or tables.
        <br><br>
        This makes patterns, trends, and anomalies easier to identify, particularly in statistical
        or large datasets. It is widely used in business decision-making.
      </p>
    </div>

  </div>
</section>



  <!-- =========================
       QUESTIONS & ANSWERS (BY TOPIC)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Check Your Understanding – Questions</h2>
    </div>
    <div class="topic-body">
      <div class="vertical-qa">

       <!-- =========================
STAGE 1: QUESTION 1
2.2.2 Computational Methods
========================= -->


  <!-- Question 1(a)(i) -->
  <div class="rev-card qa-card">
    <h3>1(a)(i). Question</h3>

    <div class="question">
      <p>
        A group of students are designing a racing car game.
        The game will allow players to enter their name and then a choice of vehicle.
        They will then race against other vehicles that will be controlled by the program.
        Players will use the arrow keys to control their vehicle.
      </p>

      <p>
        The students use <strong>abstraction</strong> during the design process.
      </p>

      <p>
        <strong>i.</strong> State what is meant by abstraction and describe how it can be used
        to design the racing car game. [3]
      </p>

      <p>
        <em>Definition</em><br>
        <em>Use</em>
      </p>
    </div>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>
    <div class="answer" hidden>
      <p><strong>Answer:</strong></p>

      <p><strong>Definition:</strong></p>
      <ul>
        <li>Removal of unnecessary detail.</li>
      </ul>

      <p><strong>Use (examples in this scenario):</strong></p>
      <ul>
        <li>Simplifying scenery so only essential objects are shown.</li>
        <li>Removing internal features of vehicles that are not needed.</li>
        <li>Simplifying the physics used for vehicle movement.</li>
        <li>Vehicles may not be drawn to scale.</li>
      </ul>
    </div>
  </div>

  <!-- Question 1(a)(ii) -->
  <div class="rev-card qa-card">
    <h3>1(a)(ii). Question</h3>

    <div class="question">
      <p>
        <strong>ii.</strong> Explain why it is beneficial to use abstraction when designing
        a computer program such as a game. [3]
      </p>
    </div>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>
    <div class="answer" hidden>
      <p><strong>Answer (any two explained):</strong></p>
      <ul>
        <li>Simplifies the problem, algorithm, and programming code.</li>
        <li>Faster to create the program.</li>
        <li>The final program uses less memory and processor time.</li>
        <li>The programmer can focus on the core aspects of the game.</li>
        <li>The completed game is simpler for end users to understand and play.</li>
      </ul>
    </div>
  </div>

  <!-- Question 1(b)(i) -->
  <div class="rev-card qa-card">
    <h3>1(b)(i). Question</h3>

      <p>
        The group of students use <strong>decomposition</strong>.
      </p>
      <p>
        <strong>i.</strong> State what is meant by decomposition. [1]
      </p>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>
    <div class="answer" hidden>
      <p><strong>Answer:</strong></p>
      <ul>
        <li>Splitting a problem down into smaller sub-problems.</li>
      </ul>
    </div>


  <!-- Question 1(b)(ii) -->
  <div class="rev-card qa-card">
    <h3>1(b)(ii). Question</h3>


      <p>
        <strong>ii.</strong> Describe one benefit of using decomposition when designing
        a computer program such as a game. [2]
      </p>


    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>
    <div class="answer" hidden>
      <p><strong>Answer (one benefit explained):</strong></p>
      <ul>
        <li>Breaks the problem into smaller, more manageable parts, making the program easier to design and test.</li>
        <li>Allows tasks to be split between programmers so development is faster.</li>
        <li>Makes it easier to identify reusable code and subroutines.</li>
      </ul>
    </div>


<div class="rev-card qa-card" id="q2">
  <h3>Stage 2 — Question 2</h3>


   2. A company runs a Virtual Learning Environment (VLE). Schools can register students to use the VLE. The
students get their own account and the school can view and monitor their students who are registered. There are
currently over 10 000 schools registered, each with up to 1000 students.
The students can watch videos, take quizzes and communicate using forums and online chat tools.
The company gathers a large amount of data and wants to use data mining to help them decide how to improve
the VLE in the future.
Discuss how the company can use data mining to decide how to improve the VLE.
You should include the following in your answer:

• the characteristics of data mining
• the benefits of data mining in this scenario
• the drawbacks of data mining in this scenario.
[12]


    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>
    <div class="answer" hidden>
    <p><strong>Answer (12 marks)</strong></p>

    <p><strong>Characteristics of data mining</strong></p>
    <ul>
      <li>Data mining involves analysing very large datasets to find <strong>patterns, trends, relationships, or anomalies</strong> that are not obvious by simply reading the data.</li>
      <li>It turns large quantities of raw activity data into <strong>useful information</strong> that can support predictions and decisions (e.g., service improvements, targeting, increasing revenue).</li>
      <li>It may use techniques such as pattern matching and anomaly detection to highlight unusual or important behaviour.</li>
    </ul>

    <p><strong>Benefits in this VLE scenario</strong></p>
    <ul>
      <li>The company can identify <strong>when</strong> the system is used most/least (days/times), helping plan maintenance windows and server scaling.</li>
      <li>They can identify <strong>which features</strong> are used most/least (videos, quizzes, forums, chat), so they can prioritise development and improve the most valuable tools.</li>
      <li>They can find quiz questions/topics that students consistently get wrong, revealing <strong>difficult content</strong> and where to improve explanations, videos, or question design.</li>
      <li>They can compare behaviour across schools/regions to spot which approaches correlate with higher engagement or better outcomes, then replicate successful features.</li>
      <li>They can use findings to improve retention/engagement (e.g., improving popular tools, redesigning confusing areas), which can support business goals.</li>
    </ul>

    <p><strong>Drawbacks in this scenario</strong></p>
    <ul>
      <li>Data mining can reveal patterns but may <strong>not explain why</strong> they occur; the company may still need surveys/experiments to confirm causes.</li>
      <li>There are <strong>privacy and ethical concerns</strong> because student activity is being logged; they must ensure collection is lawful and clearly covered by terms/consent.</li>
      <li>Processing huge amounts of data may require <strong>powerful computing resources</strong> and specialist skills, increasing cost (possibly needing external analysts).</li>
      <li>Security is critical: the collected data must be protected because a breach could expose sensitive student/school information.</li>
    </ul>

    <p><strong>Conclusion</strong></p>
    <p>Overall, data mining is suitable because the VLE generates large-scale usage data; it can guide what to improve or remove and where to invest development effort, but it must be balanced with privacy, cost, and security requirements.</p>
  </div>


          <div class="rev-card qa-card" id="q3">
  <h3>Stage 3 — Question 3</h3>


3. A computer game has a building containing 7 rooms. There are secret passages between each room. Fig. 3
shows the rooms and the passages between the rooms represented as a graph data structure.

Fig. 3


The final game will involve multiple computer-controlled characters and interactive elements that make use of
artificial intelligence to determine the moves they will make.
The artificial intelligence will use heuristics to determine where the computer-controlled characters will move in
the game.

Discuss how heuristics can be used in algorithms.
You should include the following in your answer:

• the purpose of heuristics
• the benefits and drawbacks of heuristics
• the suitability of heuristics in algorithms within a computer game.
[9]


              <img src="images/CM/graph.png" width="50%"/>

              <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>
    <div class="answer" hidden>
    <p><strong>Answer (9 marks)</strong></p>

    <p><strong>Purpose of heuristics</strong></p>
    <ul>
      <li>A heuristic is a general <strong>rule of thumb</strong> / educated guess used to guide decision-making.</li>
      <li>Its main purpose is to <strong>reduce the time taken</strong> to find a solution by prioritising promising choices rather than exploring every possibility.</li>
      <li>It aims for a solution that is <strong>good enough</strong> / close to the best, rather than guaranteed optimal.</li>
      <li>In graph/pathfinding problems, a heuristic can be a <strong>weight/estimate</strong> added to nodes (e.g., estimated distance to a destination as used in algorithms like A*).</li>
    </ul>

    <p><strong>Benefits</strong></p>
    <ul>
      <li>Heuristics can reduce time complexity because the algorithm does not need to examine every possible route or move in the game.</li>
      <li>They are useful where decisions cannot be fully pre-programmed and AI needs to choose actions dynamically.</li>
      <li>They help prevent the AI from taking too long (or effectively running indefinitely) when there are many possibilities.</li>
    </ul>

    <p><strong>Drawbacks</strong></p>
    <ul>
      <li>Because heuristics trade accuracy for speed, they may not always produce the optimal result (e.g., the “shortest” or “best” path might be missed).</li>
      <li>Good heuristics can be difficult to design and require skill; a poor heuristic can lead to weak or unrealistic AI decisions.</li>
    </ul>

    <p><strong>Suitability in a computer game</strong></p>
    <ul>
      <li>Games are usually time-sensitive (decisions must be made quickly), and they are not life-critical, so a “good enough” decision is often acceptable.</li>
      <li>If the game world scales up (more rooms, more characters, more interactions), heuristics become more valuable to keep AI responsive.</li>
      <li>In a small/simple graph (like 7 rooms), exact searching may be feasible, so heuristics may be less necessary; however, multiple AI agents and interactive elements can still make the decision space large enough that heuristics help.</li>
    </ul>

    <p><strong>Conclusion</strong></p>
    <p>Heuristics are suitable for game AI because they produce fast, reasonable moves and keep gameplay responsive, but they can sacrifice optimality and depend heavily on the quality of the heuristic used.</p>
  </div>



<div class="rev-card qa-card" id="q4">
  <h3>Stage 4 — Question 4</h3>
    4. A company needs a new computer program that will create schedules for delivery drivers. It will need to
identify a possible order that the drivers can deliver items and possible routes they could take.
Discuss how programmers could make use of problem recognition and problem decomposition when designing
this system.
You should include the following in your answer:

• a description of both problem recognition and decomposition
• how each method can be used when designing the solution
• the benefits of using each method when designing the solution.
[9]

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>
    <div class="answer" hidden>
    <p><strong>Answer (9 marks)</strong></p>

    <p><strong>Problem recognition (description + use)</strong></p>
    <ul>
      <li>Problem recognition is identifying that there is a problem to be solved and determining <strong>exactly what the problem is</strong> from the scenario.</li>
      <li>It includes deciding whether the problem can be solved using computational methods and clarifying <strong>inputs, outputs, constraints, and success criteria</strong>.</li>
      <li>For this system, programmers would recognise it as a scheduling/routing problem: inputs could include delivery locations, time windows, driver availability, vehicle limits, and road/route data; outputs are driver schedules and ordered route plans.</li>
    </ul>

    <p><strong>Benefits of problem recognition</strong></p>
    <ul>
      <li>Clarifies the real requirements before coding begins (reduces rework and missing features).</li>
      <li>Helps identify key challenges and what extra information is needed (e.g., traffic data, distance metrics, constraints like legal driving hours).</li>
      <li>Ensures developers focus on the important features (efficient routes, feasible schedules, constraints) rather than unnecessary details.</li>
    </ul>

    <p><strong>Problem decomposition (description + use)</strong></p>
    <ul>
      <li>Decomposition is splitting a large problem into smaller <strong>subproblems</strong> that can be solved independently.</li>
      <li>For this system, subproblems could include: collecting/validating inputs; generating possible routes; evaluating/scoring routes; assigning deliveries to drivers; producing the final schedule output (and possibly handling updates/re-optimisation).</li>
    </ul>

    <p><strong>Benefits of decomposition</strong></p>
    <ul>
      <li>Makes the task more manageable and allows different parts to be designed and tested separately.</li>
      <li>Allows multiple programmers/teams to work in parallel (e.g., one team on route generation, another on scheduling rules, another on UI/output).</li>
      <li>Supports efficient design because each module can be optimised (better overall performance and clearer structure).</li>
    </ul>

    <p><strong>Conclusion</strong></p>
    <p>Using problem recognition ensures the system requirements are correctly understood (inputs, outputs, constraints), while decomposition breaks the work into practical modules so the scheduling and routing solution can be developed efficiently and reliably.</p>
  </div>

<!-- ===================== -->
<!-- Q5(a)(i) -->
<div class="rev-card qa-card">
  <h3>5(a)(i)</h3>
  <div class="meta"><b>Command word:</b> Complete • <b>Marks:</b> [3]</div>

    <img src="images/CM/nanogram.png" width="50%"/>

   5(a). A Nonogram is a logic puzzle where a player needs to colour in boxes. The puzzle is laid out as a grid and each square needs to be either coloured black or left white.
The numbers at the side of each row and column tells the player how many of the boxes are coloured in consecutively. Where a row has two or more numbers, there must be a white square between the coloured squares.


In this example:
• the first column has 1 1, this means there must be two single coloured boxes in this column. There must be at least 1 white box between them.
• the first row has 2, this means there must be two consecutively coloured boxes in the row.

Juan is creating a program that will store a series of Nonograms for a user to play. The game will randomly select a puzzle and display the blank grid with the numbers for each row and column to the user.
The user plays the game by selecting a box to change its colour. If the box is white it will change to black and if it is black it will change to white. The user can choose to check the answer at any point, and the game will compare the grid to the answers and tell the user if they have got it correct or not.
Juan is creating a structure diagram to design the game.

(i) <b>Complete</b> the structure diagram by adding another layer for New game, Play game and Check answer.


    <img src="images/CM/decomp.png" width="50%"/>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>Mark-scheme points (any 3, placed under the correct parent box):

Under <span class="kw">New game</span>:
• <span class="kw">Select puzzle and display blank grid</span>

Under <span class="kw">Play game</span>:
• <span class="kw">Select box and change colour of boxes</span>

Under <span class="kw">Check answer</span>:
• <span class="kw">Compare to answer and display correct/incorrect</span></pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(a)(ii) -->
<div class="rev-card qa-card">
  <h3>5(a)(ii)</h3>
  <div class="meta"><b>Command word:</b> Explain • <b>Marks:</b> [2]</div>

  5(a)(ii). A structure diagram is one method of showing the decomposition of a problem.
<b>Explain</b> why decomposing a problem can help a developer design a solution.

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>Mark-scheme points (any 2):
• <span class="kw">Splits the problem into smaller chunks</span>
• <span class="kw">Smaller problems are more manageable</span>
• <span class="kw">Smaller problems are easier to solve</span>
• <span class="kw">To see where code can be reused in the solution</span>
• <span class="kw">To split tasks between different programmers</span></pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(a)(iii) -->
<div class="rev-card qa-card" >
  <h3>5(a)(iii)</h3>
  <div class="meta"><b>Command word:</b> Identify • <b>Marks:</b> [3]</div>

  5(a)(iii). <b>Identify</b> one input, one process and one output required for the game.

Input
Process
Output

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>Example MS answers (1 mark each for Input / Process / Output):

Input:
• <span class="kw">Clicking a box</span>

Process (any valid example):
• <span class="kw">Generating new puzzle</span>
• <span class="kw">Checking if block is black</span>
• <span class="kw">Changing block to white</span> (or equivalent toggle)

Output:
• <span class="kw">Grid with coloured squares</span></pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(b)(i) -->
<div class="rev-card qa-card">
  <h3>5(b)(i)</h3>
  <div class="meta"><b>Command word:</b> Complete • <b>Marks:</b> [5]</div>

  (b). Juan uses the structure diagram to create a modular program with a number of subroutines.
The program will use two integer 2-dimensional arrays to store the puzzles:
• puzzle(5,5) stores the solution
• answerGrid(5,5) stores the user’s current grid.
A 0 represents a white box and a 1 represents a black box.

(i) Juan creates a function, countRow(), to count the number of coloured boxes in one row and return the number of consecutive coloured boxes in that row. If there is more than one set of coloured boxes in the row, these are joined together and the string is returned. For example, in the following grid countRow for row 0 will return "2" as a string, and countRow for row 2 will return "1 1" as a string. If there are no 1s in a row, then "0" is returned as a string.
<b>Complete</b> the pseudocode algorithm countRow().


    <img src="images/CM/puzzle.png"  width="50%"/>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre><span class="kw">Completed pseudocode</span> (mark-scheme completion):

01 function countRow(puzzle:byref, rowNum:byval)
02 count = 0
03 output = " "
04 for i = 0 To <span class="kw">4</span>
05 if puzzle[rowNum, i] == <span class="kw">1</span> then
06 count = count + 1
07 elseif count >= 1 then
08 output = output + str(<span class="kw">count</span>) + " "
09 count = 0
10 endif
11 next i
12 if count>= 1 then
13 output=output+str(count)
14 elseif output == "" then
15 output = "<span class="kw">0</span>"
16 endif
17 return <span class="kw">output</span>
18 endfunction</pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(b)(ii) -->
<div class="rev-card qa-card" >
  <h3>5(b)(ii)</h3>
  <div class="meta"><b>Command word:</b> Explain • <b>Marks:</b> [2]</div>

 5(b)(ii). <b>Explain</b> the purpose of line 03 in the function countRow.

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>Mark-scheme points (any 2):
• <span class="kw">Initialise the variable output</span> …
• … <span class="kw">with a space</span>
• … <span class="kw">for use later on in the code</span> …
• … so it can be used for <span class="kw">concatenation later</span> …
• … to <span class="kw">avoid an error being generated</span></pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(b)(iii) -->
<div class="rev-card qa-card" >
  <h3>5(b)(iii)</h3>
  <div class="meta"><b>Command word:</b> Describe • <b>Marks:</b> [3]</div>

 5(b)(iii). <b>Describe</b> the purpose of branching and iteration in the function countRow.

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>Mark-scheme points (any 3):
• <span class="kw">check the value stored in each index</span>
• <span class="kw">check whether it is at the end of a row</span>
• <span class="kw">check whether each row has been given an output or not</span></pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(b)(iv) -->
<div class="rev-card qa-card" data-q="5b-iv">
  <h3>5(b)(iv)</h3>
  <div class="meta"><b>Command word:</b> Write • <b>Marks:</b> [6]</div>

 5(b)(iv). The procedure displayRowAnswer() takes puzzle as a parameter and outputs the value in each box.
Each box in a row is separated by a space. At the end of each row there are two spaces and (by calling the function countRow from part (i)) the clue values for that row.
Write pseudocode or program code for the procedure displayRowAnswer().


    <img src="images/CM/example.png"  width="60%"/>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre><span class="kw">Example</span> (as given in the mark scheme):

procedure displayRowAnswer(puzzle)
  for i = 0 To 4
    for j = 0 To 4
      print(puzzle[i, j] + " ")
    next j
    print(" " + countRow(puzzle, i))
  next i
endprocedure</pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(b)(v) -->
<div class="rev-card qa-card" data-q="5b-v">
  <h3>5(b)(v)</h3>
  <div class="meta"><b>Command word:</b> State • <b>Marks:</b> [3]</div>

  5(b)(v). The function checkWon() takes answerGrid and puzzle as parameters and compares each element in the grids. If they are identical, it returns true, otherwise returns false.

There are three logic errors in the function checkWon
<b>State</b> the line number of each error and give the corrected line.


    <img src="images/CM/function.png" height="528" width="1418"/>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>Mark-scheme corrections:

• <span class="kw">Line 01</span> needs <span class="kw">answerGrid</span> as parameter.
• <span class="kw">Line 04</span> == should be <span class="kw">!=</span>
• <span class="kw">Line 08</span> should be <span class="kw">next row</span>

(Allow: instead of changing line 04, change line 05 to true and line 09 to false.)</pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(c) -->
<div class="rev-card qa-card">
  <h3>5(c)</h3>
  <div class="meta"><b>Command word:</b> Compare • <b>Marks:</b> [9]</div>

5(c). Juan passed the two arrays as parameters, but he did consider making them globally accessible.
<b>Compare</b> the use of global and local variables and data structures in this program.
    Include the use of parameters and program efficiency in your answer.

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre><span class="kw">Indicative content</span> (mark-scheme keywords / points):

Local variables:
• <span class="kw">Scope within the module defined within</span>
• <span class="kw">Cannot access externally unless passed as parameter</span>, or returned
• <span class="kw">When module is exited, memory of variable is freed</span>

Global variables:
• <span class="kw">Scope within the entire program</span>
• <span class="kw">Can access from anywhere</span>
• <span class="kw">Retained in memory permanently</span>

Parameters / passing:
• If global, arrays can be <span class="kw">accessed from all modules by direct reference</span>
• If local, arrays need to be passed as parameters <span class="kw">byref</span>
• <span class="kw">ByRef</span> points to location of variable; <span class="kw">ByVal</span> sends the value

Efficiency / evaluation points:
• +ve Local = <span class="kw">memory efficient</span>
• +ve Global = <span class="kw">easier programming</span> / simpler to follow / easier to debug
• -ve Global = <span class="kw">memory inefficient</span>, not good technique
• -ve Local = more difficult to trace/debug/follow where values are passed
• For a relatively small program, global may not waste significant resources (context dependent)</pre>
  </div>
</div>

<!-- ===================== -->
<!-- Q5(d) -->
<div class="rev-card qa-card" >
  <h3>5(d)</h3>
  <div class="meta"><b>Command word:</b> Describe • <b>Marks:</b> [4]</div>

5(d). Juan wants to create a program that will generate new Nonograms with different grid sizes. For example a Nonogram with a 10 × 10 grid or a 5 × 20 grid.
<b>Describe</b> how the program could be written to automatically generate a new Nonogram.

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>Mark-scheme bullet points (any 4):

• <span class="kw">Make use of random numbers</span>
• <span class="kw">Generate an x/horizontal size for the grid</span>
• <span class="kw">Generate a y/vertical size for the grid</span>
• <span class="kw">Loop through each row/column</span>
• …generate a number between 0 and the number of rows/columns
• <span class="kw">Loop through each box</span>
• …generate a <span class="kw">1 or 0</span> to store in it</pre>
  </div>
</div>




          <div class="rev-card qa-card">
    <p><strong>Question 6(a).</strong></p>

    <p>
      Amy’s processor makes use of pipelining during the fetch-decode-execute cycle.
      The processor’s pipeline consists of the following stages:
    </p>

    <p>
      • Fetching the instruction from memory<br>
      • Decoding the instruction<br>
      • Executing the instruction.
    </p>

    <p>
      Instructions A, B, C and D need to be processed.
    </p>

    <p>
      Identify the stage(s) and instruction(s) run during each pipeline below.
    </p>

    <p>
      Pipeline 1<br>
      Pipeline 2<br>
      Pipeline 3<br>
      Pipeline 4
    </p>


  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>

  <div class="answer">

    <p><strong>Answer 6(a):</strong></p>

    <p>
      <strong>Pipeline 1:</strong><br>
      • Instruction A is fetched.
    </p>

    <p>
      <strong>Pipeline 2:</strong><br>
      • Instruction A is decoded.<br>
      • Instruction B is fetched.
    </p>

    <p>
      <strong>Pipeline 3:</strong><br>
      • Instruction A is executed.<br>
      • Instruction B is decoded.<br>
      • Instruction C is fetched.
    </p>

    <p>
      <strong>Pipeline 4:</strong><br>
      • Instruction B is executed.<br>
      • Instruction C is decoded.<br>
      • Instruction D is fetched.
    </p>

    <p><strong>Question 6(b).</strong></p>

    <p>
      Explain why pipelining can improve the performance of the processor.
    </p>

    <p><strong>Answer 6(b):</strong></p>

    <p>
      Pipelining improves processor performance because multiple instructions are
      processed at the same time at different stages of the fetch-decode-execute cycle.
      This means the CPU is not idle while waiting for one instruction to finish before
      starting the next.
    </p>

    <p>
      As a result, more instructions can be completed in a shorter period of time,
      increasing overall throughput and making better use of the processor’s components.
    </p>
  </div>
</div>

   <div class="rev-card qa-card">
  <h3>Question 7</h3>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">

    <p>Lucas writes a program that makes use of a circular queue.<br>
    The queue stores the data entered into the program.<br>
    An array is used to represent the queue.</p>

    <p>The program needs two pointers to access and manipulate the data in the queue.</p>

    <p><strong>State the purpose of the two pointers and give an appropriate identifier for each.</strong></p>

    <p><strong>Pointer 1 purpose</strong></p>
    <ul>
      <li>Points to the first element in the queue (the front of the queue)</li>
    </ul>

    <p><strong>Pointer 1 identifier</strong></p>
    <ul>
      <li>front</li>
    </ul>

    <p><strong>Pointer 2 purpose</strong></p>
    <ul>
      <li>Points to the last element in the queue or the next free position</li>
    </ul>

    <p><strong>Pointer 2 identifier</strong></p>
    <ul>
      <li>rear</li>
    </ul>

  </div>
</div>

        <div class="rev-card qa-card">
  <h3>Question 8</h3>

  <p>
    Explain why a quicksort is known as a divide and conquer algorithm.
    <br>[2]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>
      Quicksort divides the dataset into smaller subsets using a pivot value.
      Each subset is sorted independently and then combined to produce a fully
      sorted list.
    </p>
  </div>
</div>

      <div class="rev-card qa-card">
  <h3>Question 9</h3>

  <p>
    <strong>9(a).</strong> The game will have thousands of users. Taylor will
    store data about the users and their actions while playing the game in a
    large database.
    <br><br>
    Evaluate how Taylor can use data mining to inform future changes to improve
    his circus game.
    <br>[9]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>
      Taylor can use data mining to analyse large amounts of data generated by
      users while playing the game. Data mining searches for patterns,
      relationships, and anomalies that may not be obvious.
    </p>
    <p>
      By analysing player behaviour, Taylor could identify which features are
      used most or least, such as which characters are purchased most frequently
      or which activities users spend the most time on. This allows him to
      prioritise development of popular features and remove or redesign
      unpopular ones.
    </p>
    <p>
      Data mining could also be used to identify trends, such as when players
      stop playing or what actions successful players take, enabling
      improvements to user engagement and retention.
    </p>
    <p>
      However, data mining requires powerful hardware and processing power, which
      may be expensive. There are also privacy concerns, as users may not want
      their actions tracked. Taylor must ensure data is collected legally and
      securely.
    </p>
    <p>
      Overall, data mining is useful for improving the game but must be balanced
      against cost, privacy, and security concerns.
    </p>
  </div>
</div>

          <div class="rev-card qa-card">
  <h3>Question 10</h3>

  <p>
    OCR-Tickets wants to sell tickets for their concerts, plays and other events
    online.
    <br><br>
    Explain why decomposition can help the development of the program.
    <br>[4]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p>
      Decomposition splits the problem into smaller sub-problems. Each
      sub-problem can be solved independently. This allows the program to be
      developed as separate modules or subroutines. Work can be shared between
      developers, reducing development time.
    </p>
  </div>
</div>

          <div class="rev-card qa-card">
  <h3>Question 11</h3>

  <p>
    Sally is a classroom teacher. She would like a program to be able to organise
    where students will sit in her classroom.
    <br><br>
    <strong>(i)</strong> State three ways that Sally has made use of abstraction
    in Fig. 1.
    <br>[3]
    <br><br>
    <strong>(ii)</strong> Explain two benefits to Sally of using abstraction
    before creating the programming code.
    <br>[4]
  </p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>(i)</strong></p>
    <ul>
      <li>Classroom displays have been removed.</li>
      <li>People are represented using simple symbols.</li>
      <li>Colours and unnecessary details have been removed.</li>
    </ul>

    <p><strong>(ii)</strong></p>
    <ul>
      <li>
        Reduces development time by ignoring unnecessary details.
      </li>
      <li>
        Makes the program easier to design and ensures focus on the main problem.
      </li>
    </ul>
  </div>
</div>


      </div>
    </div>
  </section>

</main>


<footer>
  &copy; 2025 StudyHubCS
</footer>

<script>
  // Toggle topic sections open/closed
  document.querySelectorAll('.topic-header').forEach(header => {
    header.addEventListener('click', () => {
      const section = header.parentElement;
      section.classList.toggle('collapsed');
      section.classList.toggle('expanded');
    });
  });

  // Show / hide individual answers
  document.querySelectorAll('.answer-toggle').forEach(btn => {
    const answer = btn.nextElementSibling;
    if (!answer) return;

    // ensure hidden initially (CSS also sets .answer display:none)
    answer.style.display = 'none';

    btn.addEventListener('click', () => {
      const open = answer.style.display === 'block';
      answer.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Show answer' : 'Hide answer';
    });
  });

  /* -----------------------------
     Print button
  ------------------------------ */
  const printBtn = document.getElementById("printBtn");
  if (printBtn) {
    printBtn.addEventListener("click", () => {
      window.print();
    });
  }

</script>

</body>
</html>