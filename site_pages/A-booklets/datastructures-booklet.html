<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Software</title>
  <link rel="stylesheet" href="../../styles.css" />
</head>

<body>
<div class="back-container">
    <a href="../A-booklets.html">← Back</a>
  </div>
<header>
 <h1>Data Structures – Revision Booklet</h1>
<p>
    Write your answers in the boxes provided.</p>
   <p> Click <strong>Show answer</strong> to reveal model answers.
  </p>
</header>

<main>

  <!-- =========================
       KNOWLEDGE SECTIONS (VERTICAL)
       (unchanged, but you can tweak)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Software & Operating Systems – Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">

<div class="knowledge-card">
  <h3>Static vs Dynamic Data Structures</h3>

  <table border="1" cellpadding="8" cellspacing="0" style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Static Data Structure</th>
        <th>Dynamic Data Structure</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Definition</strong></td>
        <td>
          A static data structure has a fixed size that is determined at the time of creation and
          cannot change during execution.
        </td>
        <td>
          A dynamic data structure can grow or shrink at runtime, allocating and deallocating
          memory as needed.
        </td>
      </tr>

      <tr>
        <td><strong>Examples</strong></td>
        <td>
          Array (mutable – can be changed)<br>
          Tuple (immutable – cannot be changed)
        </td>
        <td>
          List, Linked List, Stack, Queue, Binary Tree, Graph
        </td>
      </tr>

      <tr>
        <td><strong>Advantages</strong></td>
        <td>
          • Fixed memory allocation at compile time<br>
          • No overhead for resizing<br>
          • Faster access via index
        </td>
        <td>
          • Flexible size<br>
          • Efficient memory usage<br>
          • Easy insertion, deletion, and merging
        </td>
      </tr>

      <tr>
        <td><strong>Disadvantages</strong></td>
        <td>
          • Fixed size may waste memory<br>
          • Cannot grow or shrink during runtime
        </td>
        <td>
          • More complex to implement<br>
          • Slower access (no direct indexing)<br>
          • Extra memory overhead for pointers
        </td>
      </tr>
    </tbody>
  </table>
</div>
<div class="knowledge-card">
  <h3>No Overhead for Resizing</h3>
  <p>
    This means that with <strong>static data structures</strong>, since the size is fixed and
    determined at <strong>compile time</strong>, the program does not need to perform any extra
    operations to change the size during runtime.
  </p>
</div>

<div class="knowledge-card">
  <h3>Array</h3>

  <p>
    An <strong>array</strong> is a data structure that stores multiple values of the same data type
    under a single identifier. Each element is accessed using an index.
  </p>

  <h4>Key Features:</h4>
  <ul>
    <li>Allows multiple items of data to be stored under one identifier</li>
    <li>Can store data in a table (indexed) structure</li>
    <li>Reduces the need for multiple variables</li>
  </ul>

  <h4>Example Representation:</h4>
  <p>
    Array Elements: <code>[12, 43, 5, 10, 69]</code><br>
    Array Indexes: <code>[0, 1, 2, 3, 4]</code>
  </p>
</div>

        <div class="knowledge-card">
  <h3>Array vs List vs Tuple</h3>

  <table border="1" cellpadding="8" cellspacing="0" style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Array</th>
        <th>List</th>
        <th>Tuple</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Size</strong></td>
        <td>Static (fixed size)</td>
        <td>Dynamic (can grow and shrink)</td>
        <td>Fixed (cannot change at runtime)</td>
      </tr>

      <tr>
        <td><strong>Data Types</strong></td>
        <td>Same data type for all elements</td>
        <td>Can store different data types</td>
        <td>Can store different data types</td>
      </tr>

      <tr>
        <td><strong>Mutability</strong></td>
        <td>Mutable (values can be changed)</td>
        <td>Mutable (elements can be changed, added, removed)</td>
        <td>Immutable (cannot be modified)</td>
      </tr>

      <tr>
        <td><strong>Memory Allocation</strong></td>
        <td>Allocated at compile time</td>
        <td>Allocated at runtime</td>
        <td>Allocated at runtime</td>
      </tr>

      <tr>
        <td><strong>Memory Storage</strong></td>
        <td>Stored in contiguous memory locations</td>
        <td>Stored in non-contiguous memory locations</td>
        <td>Stored in contiguous memory locations</td>
      </tr>

      <tr>
        <td><strong>Access Speed</strong></td>
        <td>Fast sequential and indexed access</td>
        <td>Slower than arrays</td>
        <td>Fast indexed access</td>
      </tr>

      <tr>
        <td><strong>Example</strong></td>
        <td>
          <pre>
Array birdName(4)
birdName[0] = "pigeon"
birdName[1] = "robin"
birdName[2] = "blackbird"

Result:
["pigeon","robin","blackbird",""]
          </pre>
        </td>
        <td>
          <pre>
numbers = []
numbers.append(12)
numbers.append(8)
numbers.append(5)

Result:
[12, 8, 5]

numbers.pop()
Result: [12, 8]
          </pre>
        </td>
        <td>
          <pre>
colour = (255, 0, 0)
# Red colour
          </pre>
        </td>
      </tr>

      <tr>
        <td><strong>Special Notes</strong></td>
        <td>
          Supports multi-dimensional arrays (e.g., 2D arrays with rows and columns)
        </td>
        <td>
          Efficient for frequent insertions and deletions
        </td>
        <td>
          No adding, removing, or changing elements
        </td>
      </tr>
    </tbody>
  </table>
</div>


        <div class="knowledge-card">
  <h3>Records and Arrays of Records</h3>

  <h4>Record</h4>
  <ul>
    <li>A record is a data structure that groups together related items of data</li>
    <li>Can store more than one data type together</li>
    <li>A record is an unordered data structure</li>
    <li>Can have multiple instances</li>
  </ul>

  <h4>Example: Player Records</h4>
  <table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;">
    <tr>
      <th>Player</th>
      <th>Name</th>
      <th>Score</th>
    </tr>
    <tr>
      <td>Player 1</td>
      <td>Olivia</td>
      <td>35</td>
    </tr>
    <tr>
      <td>Player 2</td>
      <td>Luke</td>
      <td>40</td>
    </tr>
  </table>

  <h4>Creating a Record Structure (Pseudocode)</h4>
  <pre>
RECORD player
  name : String
  score : int
REARRECORD
  </pre>

  <h4>Adding Data to a Record (Pseudocode)</h4>
  <pre>
Player1 : player
Player1.name = "Olivia"
Player1.score = 35
  </pre>

  <hr>

  <h3>Array of Records</h3>
  <p>
    Records are treated as data types, so they can be held within a single array.
    This allows storage of multiple records within the same structure.
  </p>

  <ul>
    <li>Records can be stored in a 1D array</li>
    <li>Allows easy access, indexing, and manipulation of each record</li>
    <li>1D array can hold multiple items of the same data type (record)</li>
    <li>Maximum number of array elements is known</li>
  </ul>

  <h4>Example: Array of Player Records</h4>
  <table border="1" cellpadding="6" cellspacing="0" style="border-collapse:collapse;">
    <tr>
      <th>Index</th>
      <th>Name</th>
      <th>Score</th>
    </tr>
    <tr>
      <td>0</td>
      <td>Olivia</td>
      <td>35</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Luke</td>
      <td>40</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Adam</td>
      <td>25</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Alex</td>
      <td>35</td>
    </tr>
  </table>

  <h4>Array of Records Pseudocode</h4>
  <pre>
Players(100) AS player
Players(3).name = "Jane"
  </pre>

  <hr>

  <h3>Record vs Class</h3>

  <table border="1" cellpadding="8" cellspacing="0" style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Record</th>
        <th>Class</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Data</strong></td>
        <td>
          A record is a data structure that stores data together, organised by attributes.
        </td>
        <td>
          A class is a record with associated methods. Each object stores attributes together.
        </td>
      </tr>

      <tr>
        <td><strong>Set up in advance</strong></td>
        <td>
          Attributes and structure are defined by the programmer for a specific purpose.
        </td>
        <td>
          Constructor method defines the class object.
        </td>
      </tr>

      <tr>
        <td><strong>Store different data types</strong></td>
        <td>
          Yes (e.g. name, type, age)
        </td>
        <td>
          Yes
        </td>
      </tr>

      <tr>
        <td><strong>Multiple instances</strong></td>
        <td>Yes</td>
        <td>Yes</td>
      </tr>

      <tr>
        <td><strong>Accessed by name</strong></td>
        <td>Yes</td>
        <td>Yes</td>
      </tr>

      <tr>
        <td><strong>Differences</strong></td>
        <td>
          Does not include methods
        </td>
        <td>
          Includes methods and can control visibility (e.g. private properties)
        </td>
      </tr>
    </tbody>
  </table>
</div>

      </div>
  </section>

  <!-- =========================
       QUESTIONS & ANSWERS (BY TOPIC)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Check Your Understanding – Questions</h2>
    </div>
    <div class="topic-body">
      <div class="vertical-qa">




      </div>
    </div>
  </section>


    <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2> Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">

     <div class="knowledge-card">
  <h3>Stacks &amp; Queues</h3>

  <h4>General Characteristics</h4>
  <ul>
    <li>Linear data structures represented by a sequential collection of elements in a fixed order</li>
    <li>Dynamic size</li>
    <li>Can contain elements of different data types</li>
    <li>Random access of elements is not allowed</li>
    <li>Implemented using a list or linked list</li>
  </ul>

  <table border="1" cellpadding="8" cellspacing="0" style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th>Stack</th>
        <th>Queue</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>LIFO</strong> – Last In, First Out</td>
        <td><strong>FIFO</strong> – First In, First Out</td>
      </tr>

      <tr>
        <td>Only the <strong>top</strong> element can be accessed</td>
        <td>Only the <strong>front</strong> element can be accessed</td>
      </tr>

      <tr>
        <td>
          One pointer: <strong>stack pointer</strong><br>
          Points to the topmost (last inserted) element
        </td>
        <td>
          Two pointers: <strong>front</strong> and <strong>rear</strong>
        </td>
      </tr>

      <tr>
        <td>
          <strong>push(data)</strong> – Add element to stack<br>
          <strong>pop()</strong> – Remove element from stack<br>
          <strong>peek()</strong> – View top element without removing<br>
          <strong>isFull()</strong> – Check if stack is full<br>
          <strong>isEmpty()</strong> – Check if stack is empty
        </td>
        <td>
          <strong>enqueue(data)</strong> – Add element to the rear<br>
          <strong>dequeue()</strong> – Remove element from the front<br>
          <strong>isFull()</strong> – Check if queue is full<br>
          <strong>isEmpty()</strong> – Check if queue is empty
        </td>
      </tr>

      <tr>
        <td>
          <strong>Uses:</strong><br>
          • Browser history (Back button)<br>
          • Undo operations in text editors<br>
          • Function call stack (program execution)
        </td>
        <td>
          <strong>Uses:</strong><br>
          • Printer queue (print jobs in order)<br>
          • Customer service queue<br>
          • Task scheduling (e.g. CPU process queue)
        </td>
      </tr>
    </tbody>
  </table>
</div>



      </div>
      </div>
      </section>


<section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2> Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">

<div class="knowledge-card">
  <h3>Stack Pointer, Push &amp; Pop Algorithms</h3>

  <h4>Stack Pointer</h4>
  <p>
    The <strong>stack pointer</strong> points to the <strong>top element</strong> in the stack.
    In some representations (especially in exams), it may instead point to the
    <strong>next available free space</strong>.
  </p>

  <hr>

  <h4>Stack PUSH Algorithm</h4>
  <ol>
    <li>Check if the stack is full.</li>
    <li>If the stack is full, generate an error and exit.</li>
    <li>If the stack is not full, increment <code>top</code> to point to the next empty space.</li>
    <li>Add the data element where <code>top</code> is pointing.</li>
  </ol>

  <h5>Pseudocode: PUSH</h5>
  <pre>
if isFull() then
  print "stack overflow"
else
  top = top + 1
  stack[top] = item
end if
  </pre>

  <h5>isFull() Condition</h5>
  <pre>
if stack.length == MAX
  </pre>

  <hr>

  <h4>Stack POP Algorithm</h4>
  <ol>
    <li>Check if the stack is empty.</li>
    <li>If the stack is empty, generate an error and exit.</li>
    <li>If the stack is not empty, access the data at <code>top</code>.</li>
    <li>Decrease <code>top</code> by 1.</li>
    <li>Return the item.</li>
  </ol>

  <h5>Pseudocode: POP</h5>
  <pre>
if isEmpty() then
  print "stack underflow"
else
  item = stack[top]
  top = top - 1
  return item
end if
  </pre>

  <h5>isEmpty() Condition</h5>
  <pre>
if top == -1
if stack.length == 0
  </pre>

  <hr>

  <h4>Display Items in Stack Algorithm</h4>
  <pre>
if isEmpty() then
  print "stack empty"
else
  for i = top to 0
    print stack[i]
  next i
end if
  </pre>

  <hr>

  <h4>Alternative Stack Representation</h4>
  <p>
    In some exam questions, the <strong>stack pointer</strong> points to the
    <strong>next available free space</strong> instead of the top item.
  </p>

  <h5>PUSH (Alternative Representation)</h5>
  <pre>
if stackPointer > 9 then
  print "stack overflow"
else
  stack[top] = item
  top = top + 1
end if
  </pre>

  <h5>POP (Alternative Representation)</h5>
  <pre>
if stackPointer == 0 then
  print "stack underflow"
else
  top = top - 1
  item = stack[top]
  return item
end if
  </pre>

  <hr>

  <h4>Exam Notes</h4>
  <ol>
    <li>
      Check whether the stack pointer refers to the <strong>top item</strong>
      or the <strong>next empty space</strong>.
    </li>
    <li>Use the identifiers exactly as given in the question.</li>
    <li>
      Think carefully when determining <code>isEmpty()</code> and
      <code>isFull()</code> conditions.
    </li>
  </ol>

  <h4>Example</h4>
  <p>
    <code>theStack.push("H")</code> places the character <strong>H</strong> onto the stack.
  </p>

  <h5>Procedure Example: pushToStack</h5>
  <pre>
procedure pushToStack(message)
  for x = 0 to message.length - 1
    messageStack.push(message.substring(x,1))
  next x
endprocedure
  </pre>
</div>

<div class="knowledge-card">
  <h3>Queue Algorithms (Linear Queue)</h3>

  <h4>Enqueue Algorithm</h4>
  <p>
    <strong>enqueue(item)</strong> inserts the given data item at the
    <strong>rear</strong> of the queue.
  </p>

  <ol>
    <li>Check if the queue is full.</li>
    <li>If full, output an error and stop.</li>
    <li>Otherwise, increment the rear pointer.</li>
    <li>Insert the new data item at the rear position.</li>
  </ol>

  <h5>Pseudocode: Enqueue</h5>
  <pre>
if isFull() then
  print "overflow"
else
  rear = rear + 1
  queue[rear] = data
end if
  </pre>

  <h5>Working out isFull()</h5>
  <pre>
if rear == maxSize - 1
# OR
if size == MAX
  </pre>

  <hr>

  <h4>Dequeue Algorithm</h4>
  <p>
    <strong>dequeue()</strong> removes and returns the item at the
    <strong>front</strong> of the queue.
  </p>

  <ol>
    <li>Check if the queue is empty.</li>
    <li>If empty, output an error and stop.</li>
    <li>Otherwise, copy the data at the front pointer.</li>
    <li>Increment the front pointer.</li>
    <li>Return the data.</li>
  </ol>

  <h5>Pseudocode: Dequeue</h5>
  <pre>
if isEmpty() then
  print "queue is empty"
else
  data = queue[front]
  front = front + 1
  return data
end if
  </pre>

  <h5>Working out isEmpty()</h5>
  <pre>
if front > rear
# OR
front = 0
rear = -1

# OR using size counter
if size == 0
  </pre>

  <hr>

  <h4>Displaying a Linear Queue</h4>
  <pre>
for i = front to rear
  print queue[i]
next i
  </pre>

  <hr>

  <h4>Exam Notes</h4>
  <ul>
    <li>
      Front and rear pointers may be defined either way around —
      always follow the exam question’s definition.
    </li>
    <li>
      Pointers may be referred to as <strong>front/rear</strong> or
      <strong>head/tail</strong>.
    </li>
    <li>
      The queue may be <strong>linear</strong> or <strong>circular</strong>;
      this will be stated in the question.
    </li>
  </ul>
</div>

    <div class="knowledge-card">
  <h3>Circular Queue Algorithms</h3>

  <p>
    In a <strong>circular queue</strong>, when items are removed from the front,
    new data can be added at the rear using the spaces vacated at the front.
  </p>

  <hr>

  <h4>Enqueue Algorithm (Circular Queue)</h4>
  <ol>
    <li>Check if the queue is full.</li>
    <li>If full, output an error and stop.</li>
    <li>If the rear pointer equals <code>maxSize - 1</code>, reset rear to <code>0</code>.</li>
    <li>Otherwise, increment the rear pointer by 1.</li>
    <li>Insert the new data item at the rear position.</li>
    <li>Increment <code>size</code> by 1.</li>
  </ol>

  <h5>Pseudocode: Enqueue (Circular)</h5>
  <pre>
if isFull() then
  print "overflow"
else
  if rear == maxSize - 1 then
    rear = 0
  else
    rear = rear + 1
  end if
  queue[rear] = data
  size = size + 1
end if
  </pre>

  <h5>isFull() Condition</h5>
  <pre>
if size == maxSize
  return True
  </pre>

  <hr>

  <h4>Dequeue Algorithm (Circular Queue)</h4>
  <ol>
    <li>Check if the queue is empty.</li>
    <li>If empty, output an error and stop (reset front and rear pointers).</li>
    <li>Otherwise, copy data from the front pointer position.</li>
    <li>If front equals <code>maxSize - 1</code>, reset front to <code>0</code>.</li>
    <li>Otherwise, increment the front pointer by 1.</li>
    <li>Decrement <code>size</code> by 1.</li>
    <li>Return the data.</li>
  </ol>

  <h5>Pseudocode: Dequeue (Circular)</h5>
  <pre>
if isEmpty() then
  print "empty"
  front = 0
  rear = -1
else
  data = queue[front]
  if front == maxSize - 1 then
    front = 0
  else
    front = front + 1
  end if
  size = size - 1
  return data
end if
  </pre>

  <h5>isEmpty() Condition</h5>
  <pre>
if size == 0
  </pre>

  <hr>

  <h4>Displaying a Circular Queue</h4>
  <p>
    Displaying a circular queue requires wrapping around the array
    when the end is reached.
  </p>

  <pre>
if isEmpty() then
  print "Queue is empty"
else
  temp = front
  for i = 0 to size - 1
    print queue[temp]
    temp = temp + 1
    if temp == maxSize then
      temp = 0
    end if
  next i
end if
  </pre>

  <hr>

  <h4>Exam Notes</h4>
  <ul>
    <li>
      Front and rear pointers may be defined either way around —
      follow the exam question carefully.
    </li>
    <li>
      Pointers may be referred to as <strong>head/tail</strong> or
      <strong>front/rear</strong>.
    </li>
    <li>
      The queue type (linear or circular) will be specified in the exam question.
    </li>
  </ul>
</div>


<div class="knowledge-card">
  <h3>Priority Queue</h3>

  <p>
    A <strong>priority queue</strong> is a type of abstract data structure where each element
    has an associated <strong>priority</strong>. Instead of being processed in the order they
    were added (as in a normal queue), elements are processed based on their priority.
  </p>

  <h4>Key Features</h4>
  <ul>
    <li>Each item in the queue has:
      <ul>
        <li>A value</li>
        <li>A priority level</li>
      </ul>
    </li>
    <li>The element with the <strong>highest priority</strong> is removed first</li>
    <li>If two elements have the same priority, they are processed in
      <strong>FIFO (First In, First Out)</strong> order</li>
  </ul>

  <h4>Operations</h4>
  <ul>
    <li><strong>Insert (enqueue)</strong> – Add an element with a priority</li>
    <li><strong>Remove (dequeue)</strong> – Remove the element with the highest priority</li>
  </ul>

  <h4>Implementation</h4>
  <ul>
    <li>Arrays / Lists (less efficient)</li>
    <li>Heaps (more efficient, e.g. binary heap)</li>
  </ul>

  <h4>Example Use Cases</h4>
  <ul>
    <li>Task scheduling (e.g. CPU processes)</li>
    <li>Dijkstra’s algorithm (shortest path in graphs)</li>
    <li>Emergency room triage systems</li>
  </ul>

  <h4>Concept Illustration</h4>
  <p>
    In a priority queue, the element with the <strong>highest priority</strong>
    (e.g. <code>2</code>) is dequeued first, while the element with the
    <strong>lowest priority</strong> (e.g. <code>10</code>) remains until later.
  </p>
</div>

    <div class="knowledge-card">
  <h3>Linear Stack Implementation</h3>

  <table border="1" cellpadding="10" cellspacing="0" style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th>Procedural Linear Stack Implementation</th>
        <th>OOP Linear Stack Implementation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
<pre>
# Initialize
maxsize = 5
stack = [None, None, None, None, None]
top = -1

procedure push(stack, data, top, maxsize)
  if isfull(top, maxsize) then
    print("Error: stack is full")
  else
    top = top + 1
    stack[top] = data
  endif
  return stack, top
endprocedure

function pop(stack, top)
  if isempty(top) then
    print("Error: stack is empty")
    return None, top
  else
    item = stack[top]
    top = top - 1
    return item, top
  endif
endfunction

procedure displaystack(stack, top)
  if isempty(top) then
    print("Error: stack is empty")
  else
    print("Stack contents:")
    for i = 0 to top
      print(stack[i])
    next i
  endif
endprocedure

function isfull(top, maxsize)
  if top == maxsize - 1 then
    return True
  else
    return False
  endif
endfunction

function isempty(top)
  if top == -1 then
    return True
  else
    return False
  endif
endfunction

function peek(stack, top)
  if isempty(top) then
    return "Error: stack is empty"
  else
    return stack[top]
  endif
endfunction

# Main program
stack, top = push(stack, "cat", top, maxsize)
displaystack(stack, top)
item, top = pop(stack, top)
print("popped item: " + item)
</pre>
        </td>

        <td>
<pre>
class stack

  # constructor
  public procedure new()
    maxsize = 5
    s = [None, None, None, None, None]
    top = -1
  endprocedure

  procedure push(data)
    if isfull() then
      print("error: stack is full")
    else
      top = top + 1
      s[top] = data
    endif
  endprocedure

  function pop()
    if isempty() then
      print("error: stack is empty")
    else
      item = s[top]
      top = top - 1
      return item
    endif
  endfunction

  procedure displaystack()
    if isempty() then
      print("error: stack is empty")
    else
      print("stack contents:")
      for i = 0 to top
        print(s[i])
      next i
    endif
  endprocedure

  function isfull()
    if top == maxsize - 1 then
      return True
    else
      return False
    endif
  endfunction

  function isempty()
    if top == -1 then
      return True
    else
      return False
    endif
  endfunction

  function peek()
    if isempty() then
      return "error: stack is empty"
    else
      return s[top]
    endif
  endfunction

endclass

# Main program
s = new stack()
s.push("cat")
s.displaystack()
print("popped item: " + s.pop())
</pre>
        </td>
      </tr>
    </tbody>
  </table>

  <h4>Key Differences</h4>
  <ul>
    <li><strong>Procedural:</strong> Data and functions are separate; stack and top must be passed between procedures.</li>
    <li><strong>OOP:</strong> Data and methods are bundled together inside a class.</li>
    <li><strong>OOP approach</strong> improves encapsulation, readability, and reusability.</li>
  </ul>
</div>
    <div class="knowledge-card">
  <h3>Linear Queue Implementation</h3>

  <table border="1" cellpadding="10" cellspacing="0" style="width:100%; border-collapse:collapse;">
    <thead>
      <tr>
        <th>Procedural Linear Queue Implementation</th>
        <th>OOP Linear Queue Implementation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
<pre>
# Initialize an empty queue
maxsize = 5
q = [None, None, None, None, None]
front = 0
rear = -1

# Enqueue operation
function enqueue(q, item, rear, maxsize)
  if isFull(rear, maxsize) then
    print("Queue is Full")
  else
    rear = rear + 1
    q[rear] = item
  endif
  return q, rear
endfunction

function isFull(rear, maxsize)
  if rear == maxsize - 1 then
    return True
  else
    return False
  endif
endfunction

# Dequeue operation
function dequeue(q, front, rear)
  if isEmpty(front, rear) then
    front = 0
    rear = -1
    print("Queue is empty")
  else
    data = q[front]
    front = front + 1
  endif
  return q, front, rear, data
endfunction

function isEmpty(front, rear)
  if front > rear then
    return True
  else
    return False
  endif
endfunction

# Peek operation
function peek(q, front)
  return q[front]
endfunction

# Display queue
function displayQueue(q, front, rear)
  for i = front to rear
    print q[i]
  next i
endfunction

# Main program
q, rear = enqueue(q, "cat", rear, maxsize)
displayQueue(q, front, rear)
q, front, rear, data = dequeue(q, front, rear)
</pre>
        </td>

        <td>
<pre>
class Queue

  # Constructor
  public procedure new()
    maxsize = 5
    q = [None, None, None, None, None]
    front = 0
    rear = -1
  endprocedure

  public procedure enqueue(data)
    if isFull() then
      print("Queue is Full")
    else
      rear = rear + 1
      q[rear] = data
    endif
  endprocedure

  public function isFull()
    if rear == maxsize - 1 then
      return True
    else
      return False
    endif
  endfunction

  public function dequeue()
    if isEmpty() then
      print("Queue is empty")
    else
      data = q[front]
      front = front + 1
      return data
    endif
  endfunction

  public function isEmpty()
    if front > rear then
      front = 0
      rear = -1
      return True
    else
      return False
    endif
  endfunction

  public function peek()
    return q[front]
  endfunction

  public procedure displayQueue()
    if isEmpty() then
      print("Queue is empty")
    else
      for i = front to rear
        print q[i]
      next i
    endif
  endprocedure

endclass

# Main program
q = new Queue()
q.enqueue("cat")
q.displayQueue()
q.dequeue()
</pre>
        </td>
      </tr>
    </tbody>
  </table>

  <h4>Key Differences</h4>
  <ul>
    <li><strong>Procedural approach:</strong> Queue data and pointers are passed between functions.</li>
    <li><strong>OOP approach:</strong> Queue data and operations are encapsulated within a class.</li>
    <li><strong>OOP queues</strong> improve modularity, readability, and reuse of code.</li>
  </ul>
</div>

    </div>
    </div>
    </section>



      <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2> Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">






           </div>
      </div>
      </section>

<section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2> Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">

      <div class="knowledge-card">
        <h3>Title</h3>
        <p></p>
      </div>
<div class="knowledge-card">
  <h3>Linked Lists – Full Extracted Content</h3>

  <h4>Linked Lists</h4>
  <ul>
    <li>A linked list is a <strong>dynamic data structure</strong> – it can grow and shrink during runtime.</li>
    <li>A linked list can be <strong>unordered</strong> or <strong>ordered</strong> (alphabetical or numerical order).</li>
    <li>A linked list uses <strong>pointers</strong> to order the data.</li>
    <li>The items are <strong>not necessarily held in contiguous memory locations</strong>.</li>
    <li>The physical order in memory may not match the logical order of the list.</li>
    <li>Items can be added and removed <strong>without shifting</strong> any other items.</li>
    <li>Traversing a linked list always begins at the <strong>start / head node</strong>.</li>
  </ul>

  <hr>

  <h4>Difference Between a Linked List and an Array</h4>
  <p><strong>Pros of linked lists:</strong></p>
  <ul>
    <li>Flexible – elements can be inserted or deleted at any position efficiently.</li>
    <li>Uses dynamic allocation, so the size does not need to be known in advance.</li>
  </ul>

  <p><strong>Cons of linked lists:</strong></p>
  <ul>
    <li>More complex to use and access than arrays.</li>
    <li>Pointers require extra memory.</li>
    <li>Random access is not allowed.</li>
  </ul>

  <hr>

  <h4>Requirements to Implement a Linked List</h4>
  <ul>
    <li><strong>Node object</strong> – stores the data and a pointer to the next item.</li>
    <li><strong>Start pointer</strong> – used to store the first item.</li>
    <li><strong>Null pointer (Ø)</strong> – specifies the end of the list.</li>
    <li><strong>Free node</strong> – specifies the next free node in the list.</li>
  </ul>

  <hr>

  <h4>Node Object</h4>
  <pre>
class Node
  public procedure new(pData)
    data = pData          // instance variable to store the data
    next = None           // instance variable storing address of next node
  endprocedure
endclass
  </pre>

  <h4>Using Getter and Setter Methods</h4>
  <pre>
class node

  public function getData()
    return data
  endfunction

  public function getNext()
    return next
  endfunction

  public procedure setNext(pNext)
    next = pNext
  endprocedure

  public procedure setData(pData)
    data = pData
  endprocedure

endclass
  </pre>

  <p>Example usage:</p>
  <pre>
data = input()
new_node = new node(data)
new_node.getData()
new_node.getNext()
new_node.setNext(next)
new_node.setData(data)
  </pre>

  <hr>

  <h4>Linked List Class</h4>
  <pre>
class linkedlist
  private head : node

  public procedure newLinkedList()   // constructor
    head = null
  endprocedure
endclass

my_list = new linkedlist()   // instantiate empty linked list
  </pre>

  <hr>

  <h4>Inserting a Node (Ordered Linked List)</h4>
  <p>If the list is ordered, the new element must be inserted in the correct position.</p>

  <ol>
    <li>Store the data in the free node.</li>
    <li>Identify where the item should be inserted.</li>
    <li>Update the pointer of the previous item.</li>
    <li>Set the new item’s pointer to the next node.</li>
    <li>Update the free node pointer.</li>
  </ol>

  <pre>
procedure insert_in_order(data)
  new_node = new node(data)
  current = head

  // Case 1: empty list
  if current == null then
    head = new_node

  // Case 2: insert before head
  else if new_node.getData() < current.getData() then
    new_node.setNext(current)
    head = new_node

  // Case 3: insert in middle or end
  else
    while current.getNext() != null AND
          current.getNext().getData() < new_node.getData()
      current = current.getNext()
    endwhile

    new_node.setNext(current.getNext())
    current.setNext(new_node)
  endif
endprocedure
  </pre>

  <hr>

  <h4>Unordered Linked List Insertion</h4>

  <p><strong>Insert at Head (fastest method)</strong></p>
  <pre>
procedure insert_unordered(data)
  new_node = new node(data)
  new_node.setNext(head)
  head = new_node
endprocedure
  </pre>

  <p><strong>Insert at End</strong></p>
  <pre>
procedure insert_end(data)
  new_node = new node(data)

  if head == null then
    head = new_node
  else
    current = head
    while current.getNext() != null
      current = current.getNext()
    endwhile
    current.setNext(new_node)
  endif
endprocedure
  </pre>

  <p>
    Used when order does not matter (e.g. stack insertion at head,
    queue insertion at end).
  </p>

  <hr>

  <h4>Removing a Node (Delete Algorithm)</h4>
  <ol>
    <li>Traverse the list from the head.</li>
    <li>If the list is empty, stop.</li>
    <li>If the head contains the target data, update the head pointer.</li>
    <li>Otherwise, find the node before the one to delete.</li>
    <li>Update pointers to skip the deleted node.</li>
  </ol>

  <pre>
procedure delete(data)
  current = head

  // Case 1: empty list
  if current == null then
    return

  // Case 2: delete head
  else if current.getData() == data then
    head = current.getNext()

  // Case 3: delete elsewhere
  else
    while current.getNext() != null AND
          current.getNext().getData() != data
      current = current.getNext()
    endwhile

    if current.getNext() != null then
      current.setNext(current.getNext().getNext())
    endif
  endif
endprocedure
  </pre>

  <p><strong>Note:</strong> Nodes do not move in memory; only pointers are updated.</p>

  <hr>

  <h4>Traversing a Linked List</h4>
  <p>
    Example task: count how many times a particular name occurs in a linked list.
  </p>

  <ol>
    <li>Initialise a counter.</li>
    <li>Set current node to the head.</li>
    <li>If pointer is NULL, list is empty.</li>
    <li>Compare data and update counter if matched.</li>
    <li>Move to next node.</li>
    <li>Repeat until NULL is reached.</li>
  </ol>

  <pre>
procedure traverse()
  current = head
  while current != null
    print(current.getData())
    current = current.getNext()
  endwhile
endprocedure
  </pre>

  <hr>

  <h4>Searching a Linked List</h4>
  <p>Searching must use a <strong>linear search</strong>.</p>

  <pre>
function search(item)
  current = head
  found = false

  while current != null AND not found
    if current.getData() == item then
      found = true
    else
      current = current.getNext()
    endif
  endwhile

  return found
endfunction
  </pre>

</div>
      </div>
      </div>
      </section>



      <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2> Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">



        <div class="rev-card qa-card">
          <p>Question</p>

          <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

          <button class="secondary answer-toggle">Show answer</button>
          <div class="answer">
            <p></p>
          </div>
        </div>


           </div>
      </div>
      </section>





</main>

<footer>
  <p>&copy; 2025 </p>
</footer>

<script>
  // Toggle topic sections open/closed
  document.querySelectorAll('.topic-header').forEach(header => {
    header.addEventListener('click', () => {
      const section = header.parentElement;
      section.classList.toggle('collapsed');
      section.classList.toggle('expanded');
    });
  });

  // Show / hide individual answers
  document.querySelectorAll('.answer-toggle').forEach(btn => {
    const answer = btn.nextElementSibling;
    if (!answer) return;

    // ensure hidden initially (CSS also sets .answer display:none)
    answer.style.display = 'none';

    btn.addEventListener('click', () => {
      const open = answer.style.display === 'block';
      answer.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Show answer' : 'Hide answer';
    });
  });

  /* -----------------------------
     Print button
  ------------------------------ */
  const printBtn = document.getElementById("printBtn");
  if (printBtn) {
    printBtn.addEventListener("click", () => {
      window.print();
    });
  }

</script>

</body>
</html>