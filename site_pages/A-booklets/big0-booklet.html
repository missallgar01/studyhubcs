<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Big O</title>
  <link rel="stylesheet" href="../../css/main.css" />
</head>

<body>
<div class="back-container">
    <a href="../A-booklets.html">← Back</a>
  </div>
<header>
   <h1>BigO – Revision Booklet</h1>
<p>
    Write your answers in the boxes provided.</p>
   <p> Click <strong>Show answer</strong> to reveal model answers.
  </p>
</header>

<main>
<button class="cmd-btn" onclick="openTip()">Exam Marking Tip</button>

<!-- Wrap the whole tabs+panels block in this -->
<div class="booklet panels" data-tabs>

  <!-- Tab list -->
  <div role="tablist" aria-label="Algorithms tabs">
    <button
      id="tabbtn-revision"
      type="button"
      role="tab"
      aria-controls="tab-revision"
      aria-selected="true"
      tabindex="0">
      Revision Notes
    </button>

    <button
      id="tabbtn-KC"
      type="button"
      role="tab"
      aria-controls="tab-KC"
      aria-selected="false"
      tabindex="-1">
      Knowledge Check
    </button>
  </div>

  <!-- Panels -->
  <div class="panels">
    <div
      id="tab-revision"
      role="tabpanel"
      aria-labelledby="tabbtn-revision">
      <!-- =========================
       KNOWLEDGE SECTIONS (VERTICAL)
       (unchanged, but you can tweak)
       ========================= -->
  <div class = "vertical-knowledge">
 <h2>Big O – Notes</h2>

<div class="knowledge-card">
  <h3>Big O Notation</h3>

  <h4>What is Big O?</h4>
  <p>
    Big O notation is used to evaluate the complexity of an algorithm.
    It shows how the time, memory, or resources required by an algorithm
    increase as the size of the data set increases.
  </p>

  <p>
    Big O notation usually describes the <strong>worst-case scenario</strong>
    for an algorithm.
  </p>

  <p>
    <strong>Time complexity</strong> – how the execution time scales as data size increases<br>
    <strong>Space complexity</strong> – how much memory is required
  </p>
</div>

<div class="knowledge-card">
  <h3>Common Big O Notations</h3>

  <table>
    <thead>
      <tr>
        <th>Notation</th>
        <th>Description</th>
        <th>Example Code</th>
        <th>Example Use</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>O(1)</code></td>
        <td>
          <strong>Constant.</strong>
          Always executes in the same time regardless of data size.
          Very efficient.
        </td>
        <td>
          <code>value = data_set[x]</code>
        </td>
        <td>
          Accessing an element in an array.<br>
          Hashing algorithms.
        </td>
      </tr>

      <tr>
        <td><code>O(log N)</code></td>
        <td>
          <strong>Logarithmic.</strong>
          The problem size is halved each step.
          Common in divide-and-conquer algorithms.
        </td>
        <td>
          <pre>
WHILE found == False AND low <= high
  mid = (low + high) DIV 2
  IF data[mid] == target THEN
    found = True
  ELSEIF data[mid] < target THEN
    low = mid + 1
  ELSE
    high = mid - 1
  ENDIF
ENDWHILE
          </pre>
        </td>
        <td>Binary search.</td>
      </tr>

      <tr>
        <td><code>O(N)</code></td>
        <td>
          <strong>Linear.</strong>
          Performance decreases proportionally as data size grows.
        </td>
        <td>
          <pre>
FOR x = 1 TO N
  total = total + data[x]
NEXT x
          </pre>
        </td>
        <td>
          Looping through an array.<br>
          Linear search.
        </td>
      </tr>

      <tr>
        <td><code>O(N log N)</code></td>
        <td>
          <strong>Linearithmic.</strong><br>
          The algorithm processes every item and repeatedly divides the problem.
        </td>
        <td>
         Merge sort’s time comes from two separate actions:
              <ul>
<li>Splitting → log n (You keep dividing the list in half)</li>
<li>Merging → n At each level of splitting, you merge all elements back together.
    Every element is looked at once per level </li>
        </ul>
        </td>
        <td>
          Quick sort.<br>
          Merge sort.
        </td>
      </tr>

      <tr>
        <td><code>O(N²)</code></td>
        <td>
          <strong>Polynomial.</strong>
          Performance proportional to the square of the data size.
          Often caused by nested loops.
        </td>
        <td>
          <pre>
FOR x = 1 TO N
  FOR y = 1 TO N
    total = total + 1
  NEXT y
NEXT x
          </pre>
        </td>
        <td>
          Nested loops.<br>
          Bubble sort.
        </td>
      </tr>
      <tr>
        <td><code>O(2ⁿ)</code></td>
        <td>
          <strong>Exponential.</strong>
          Time doubles with each additional data item.
          Extremely inefficient.
        </td>
        <td>
          <pre>
FUNCTION fib(x)
  IF x <= 1 THEN
    RETURN x
  ELSE
    RETURN fib(x - 1) + fib(x - 2)
  ENDIF
ENDFUNCTION
          </pre>
        </td>
        <td>
          Recursive Fibonacci calculation.
        </td>
      </tr>
    </tbody>
  </table>
</div>

        <div class="knowledge-card">
  <h3>Big O Growth Comparison Diagram</h3>

  <p>
    This diagram compares how common complexity classes grow as input size <code>N</code> increases
    (y-values are scaled/capped to fit on one chart).
  </p>


            <img src="images/algorithms/comparison.jpg" height="375" width="616"/>
            <p>
    Key idea: as <code>N</code> grows, <code>O(N²)</code> and especially <code>O(2ⁿ)</code>
    become impractical much faster than <code>O(N log N)</code> or <code>O(log N)</code>.
  </p>
</div>

      <div class="knowledge-card">
  <h3>Big O Notation – Searching Algorithms</h3>

  <table>
    <thead>
      <tr>
        <th rowspan="2">Searching Algorithm</th>
        <th colspan="3">Time Complexity</th>
      </tr>
      <tr>
        <th>Best</th>
        <th>Average</th>
        <th>Worst</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Linear Search</td>
        <td>O(1)</td>
        <td>O(n)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Binary Search (Array)</td>
        <td>O(1)</td>
        <td>O(log n)</td>
        <td>O(log n)</td>
      </tr>
      <tr>
        <td>Binary Search Tree</td>
        <td>O(1)</td>
        <td>O(log n)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Hashing</td>
        <td>O(1)</td>
        <td>O(1)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Breadth / Depth First Search (Graph)</td>
        <td>O(1)</td>
        <td>O(V + E)</td>
        <td>O(V²)</td>
      </tr>
    </tbody>
  </table>

  <p>
    Where <strong>V</strong> is the number of vertices and
    <strong>E</strong> is the number of edges.
  </p>
</div>

        <div class="knowledge-card">
  <h3>Big O Notation – Sorting Algorithms</h3>

  <table>
    <thead>
      <tr>
        <th rowspan="2">Sorting Algorithm</th>
        <th colspan="3">Time Complexity</th>
        <th rowspan="2">Space Complexity</th>
      </tr>
      <tr>
        <th>Best</th>
        <th>Average</th>
        <th>Worst</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Bubble Sort</td>
        <td>O(n)</td>
        <td>O(n²)</td>
        <td>O(n²)</td>
        <td>O(1)</td>
      </tr>
      <tr>
        <td>Insertion Sort</td>
        <td>O(n)</td>
        <td>O(n²)</td>
        <td>O(n²)</td>
        <td>O(1)</td>
      </tr>
      <tr>
        <td>Merge Sort</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>O(n)</td>
      </tr>
      <tr>
        <td>Quick Sort</td>
        <td>O(n log n)</td>
        <td>O(n log n)</td>
        <td>O(n²)</td>
        <td>O(log n)</td>
      </tr>
    </tbody>
  </table>
</div>

        <div class="knowledge-card">
  <h3>Growth Rate Comparison</h3>

  <table>
    <thead>
      <tr>
        <th>n</th>
        <th>n² (Polynomial)</th>
        <th>2ⁿ (Exponential)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>1</td>
        <td>1</td>
        <td>2</td>
      </tr>
      <tr>
        <td>10</td>
        <td>100</td>
        <td>1,024</td>
      </tr>
      <tr>
        <td>20</td>
        <td>400</td>
        <td>1,048,576</td>
      </tr>
      <tr>
        <td>30</td>
        <td>900</td>
        <td>1,073,741,824</td>
      </tr>
    </tbody>
  </table>

  <p>
    Exponential algorithms become impractical extremely quickly compared
    to polynomial algorithms.
  </p>
</div>
</div>
    </div>

    <div
      id="tab-KC"
      role="tabpanel"
      aria-labelledby="tabbtn-KC"
      hidden>
      <!-- =========================
       QUESTIONS & ANSWERS (BY TOPIC)
       ========================= -->
<div class = "vertical-knowledge">
      <h2>Check Your Understanding – Questions</h2>


        <!-- =======================
             TOPIC A – Question and answer
             ======================= -->
       <div class="rev-card qa-card">
  <h3> Question 1</h3>

  <p>
    The tables below show possible Big O complexities for the worst-case space, best-case space and average
    time for search algorithms.
  </p>

  <p><strong>Tick the worst-case space complexity for a binary and linear search.</strong></p>
  <table>
    <thead>
      <tr>
        <th></th>
        <th>Binary search</th>
        <th>Linear search</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>O(log(n))</td><td></td><td></td></tr>
      <tr><td>O(1)</td><td></td><td></td></tr>
      <tr><td>O(n)</td><td></td><td></td></tr>
    </tbody>
  </table>

  <p><strong>Tick the best-case space complexity for a binary and linear search.</strong></p>
  <table>
    <thead>
      <tr>
        <th></th>
        <th>Binary search</th>
        <th>Linear search</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>O(log(n))</td><td></td><td></td></tr>
      <tr><td>O(1)</td><td></td><td></td></tr>
      <tr><td>O(n)</td><td></td><td></td></tr>
    </tbody>
  </table>

  <p><strong>Tick the average time complexity for a binary and linear search.</strong></p>
  <table>
    <thead>
      <tr>
        <th></th>
        <th>Binary search</th>
        <th>Linear search</th>
      </tr>
    </thead>
    <tbody>
      <tr><td>O(log(n))</td><td></td><td></td></tr>
      <tr><td>O(1)</td><td></td><td></td></tr>
      <tr><td>O(n)</td><td></td><td></td></tr>
    </tbody>
  </table><p>[6]</p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <p><strong>Worst-case space complexity:</strong> Binary = O(1), Linear = O(1)</p>
    <p><strong>Best-case space complexity:</strong> Binary = O(1), Linear = O(1)</p>
    <p><strong>Average time complexity:</strong> Binary = O(log(n)), Linear = O(n)</p>

    <p>Ticked tables:</p>

    <p><strong>Worst-case space complexity</strong></p>
    <table>
      <thead>
        <tr><th></th><th>Binary search</th><th>Linear search</th></tr>
      </thead>
      <tbody>
        <tr><td>O(log(n))</td><td></td><td></td></tr>
        <tr><td>O(1)</td><td>✓</td><td>✓</td></tr>
        <tr><td>O(n)</td><td></td><td></td></tr>
      </tbody>
    </table>

    <p><strong>Best-case space complexity</strong></p>
    <table>
      <thead>
        <tr><th></th><th>Binary search</th><th>Linear search</th></tr>
      </thead>
      <tbody>
        <tr><td>O(log(n))</td><td></td><td></td></tr>
        <tr><td>O(1)</td><td>✓</td><td>✓</td></tr>
        <tr><td>O(n)</td><td></td><td></td></tr>
      </tbody>
    </table>

    <p><strong>Average time complexity</strong></p>
    <table>
      <thead>
        <tr><th></th><th>Binary search</th><th>Linear search</th></tr>
      </thead>
      <tbody>
        <tr><td>O(log(n))</td><td>✓</td><td></td></tr>
        <tr><td>O(1)</td><td></td><td></td></tr>
        <tr><td>O(n)</td><td></td><td>✓</td></tr>
      </tbody>
    </table>
  </div>
</div>


<div class="rev-card qa-card">
  <h3>Question 2</h3>

  <p>
    A program designer needs to decide on an algorithm to use from a choice of three.
    The table shows the worst-case Big O complexities for each algorithm.
  </p>

  <p>
    The program will be used to analyse data that can range from 2 items to 2 billion items.
  </p>

  <p>
    Compare the use of all three algorithms and suggest which the programmer should use.
    You should include:
  </p>

  <ul>
    <li>the meaning of constant, logarithmic, linear and exponential complexity</li>
    <li>how well each algorithm scales as the amount of data increases</li>
    <li>which algorithm is the most suitable for the given task</li>
  </ul><p>[9]</p>

<textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">

    <p>
      <strong>Constant complexity (O(1))</strong> means the time or space used does not
      change as the size of the data increases.
    </p>

    <p>
      <strong>Logarithmic complexity (O(log n))</strong> means performance improves in
      proportion to the logarithm of the data size, so increases in data size have a
      relatively small impact.
    </p>

    <p>
      <strong>Linear complexity (O(n))</strong> means the time or space required increases
      directly in proportion to the number of items.
    </p>

    <p>
      <strong>Exponential complexity (O(2ⁿ))</strong> means the time or space required
      doubles for each additional item, making it unsuitable for large data sets.
    </p>

    <p>
      Algorithm 1 has linear time and exponential space complexity, so while it scales
      reasonably in time, it would quickly become impractical due to excessive memory
      usage.
    </p>

    <p>
      Algorithm 2 has exponential time complexity, meaning performance would rapidly
      degrade as the data size increases, making it unsuitable for very large data sets.
    </p>

    <p>
      Algorithm 3 has logarithmic time and space complexity, which scales very efficiently
      even with billions of items.
    </p>

    <p>
      Therefore, <strong>Algorithm 3</strong> is the most suitable choice as it offers the
      best scalability in both time and space for very large data sets.
    </p>
  </div>
</div>
</div>
</div>


        <button id="printBtn" type="button">
  Print this worksheet
</button>

</main>


<footer>
    © <span id="year"></span> StudyHub CS
  </footer>

<script src="../js/booklets.js"></script>
<div id="command-words"></div>

</body>
</html>