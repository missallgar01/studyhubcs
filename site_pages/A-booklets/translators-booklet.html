<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Software</title>
  <link rel="stylesheet" href="../../styles.css" />
</head>

<body>
<div class="back-container">
    <a href="../A-booklets.html">← Back</a>
  </div>
<header>
   <h1>Types of programming languages and Translators– Revision Booklet</h1>
<p>
    Write your answers in the boxes provided.</p>
   <p> Click <strong>Show answer</strong> to reveal model answers.
  </p>
</header>

<main>

  <!-- =========================
       KNOWLEDGE SECTIONS (VERTICAL)
       (unchanged, but you can tweak)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Software & Operating Systems – Notes</h2>
    </div>
    <div class="topic-body vertical-knowledge">

      <div class="knowledge-card">
<table>
  <thead>
    <tr>
      <th>Term</th>
      <th>Definition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Source Code</td>
      <td>A program written by the programmer in a high-level language. It is easy for humans to read but must be translated before execution.</td>
    </tr>
    <tr>
      <td>Object Code</td>
      <td>Low-level or machine code produced by a translator. It is understood by the computer.</td>
    </tr>
    <tr>
      <td>Executable Code</td>
      <td>A complete machine-code program that can be run directly by the computer.</td>
    </tr>
    <tr>
      <td>Intermediate Code</td>
      <td>Machine-independent code produced by a compiler that requires further translation by an interpreter or virtual machine.</td>
    </tr>
    <tr>
      <td>Translator</td>
      <td>Software that converts high-level or assembly code into machine code.</td>
    </tr>
    <tr>
      <td>Compiler</td>
      <td>Translates the entire source code at once and produces an executable file. Errors are reported after compilation.</td>
    </tr>
    <tr>
      <td>Interpreter</td>
      <td>Translates and executes source code line by line at runtime, reporting errors as they occur.</td>
    </tr>
    <tr>
      <td>Assembler</td>
      <td>Translates assembly language into machine code using mnemonics and symbolic addresses.</td>
    </tr>
    <tr>
      <td>High-Level Language (HLL)</td>
      <td>A programming language that uses English-like statements and is portable across different platforms.</td>
    </tr>
    <tr>
      <td>Low-Level Language</td>
      <td>A machine-specific language that uses mnemonics and opcodes and maps closely to hardware.</td>
    </tr>
    <tr>
      <td>Opcode</td>
      <td>The part of an instruction that tells the CPU what operation to perform.</td>
    </tr>
    <tr>
      <td>Operand</td>
      <td>The part of an instruction that specifies the data or memory location to be used.</td>
    </tr>
    <tr>
      <td>Mnemonic</td>
      <td>A short, human-readable instruction used in assembly language, such as ADD or SUB.</td>
    </tr>
    <tr>
      <td>Immediate Addressing</td>
      <td>The operand contains the actual value to be used.</td>
    </tr>
    <tr>
      <td>Direct Addressing</td>
      <td>The operand contains the memory address where the required data is stored.</td>
    </tr>
    <tr>
      <td>Indirect Addressing</td>
      <td>The operand contains the address of another memory location that holds the required address.</td>
    </tr>
    <tr>
      <td>Indexed Addressing</td>
      <td>The operand address is combined with an index register, commonly used for arrays.</td>
    </tr>
    <tr>
      <td>Lexical Analysis</td>
      <td>The first stage of compilation where comments and whitespace are removed and tokens are identified.</td>
    </tr>
    <tr>
      <td>Syntax Analysis</td>
      <td>Checks tokens against grammar rules, builds an abstract syntax tree, and reports syntax errors.</td>
    </tr>
    <tr>
      <td>Code Generation</td>
      <td>Produces object code from the analysed program.</td>
    </tr>
    <tr>
      <td>Code Optimisation</td>
      <td>Improves program efficiency by reducing execution time and memory usage.</td>
    </tr>
    <tr>
      <td>Symbol Table</td>
      <td>A data structure that stores information about identifiers, including type and memory address.</td>
    </tr>
    <tr>
      <td>Linker</td>
      <td>Combines object code files and libraries into a single executable file.</td>
    </tr>
    <tr>
      <td>Loader</td>
      <td>Loads the executable program and required libraries into memory for execution.</td>
    </tr>
    <tr>
      <td>Library Routines</td>
      <td>Pre-written, tested code that saves development time and reduces errors.</td>
    </tr>
  </tbody>
</table>
</div>



      </div>
  </section>

  <!-- =========================
       QUESTIONS & ANSWERS (BY TOPIC)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Types of programming languages</h2>
    </div>
    <div class="topic-body">
      <div class="vertical-qa">


          <div class="knowledge-card">

              <img src="images/translators/translator-workflow-diagram.jpeg" width="70%"/>
              <table>
    <thead>
      <tr>
        <th>High-Level</th>
        <th>Low-Level</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <ul>
            <li>Uses English-like statements which can be easily read by programmers</li>
            <li>Designed for quick programming</li>
            <li>Can be translated for multiple machine architectures</li>
            <li>Need to rely on a compiler to optimise the code</li>
            <li>May produce multiple lines of machine code per line of code (one-to-many)</li>
          </ul>
        </td>
        <td>
          <ul>
            <li>Microprocessor/CPU/machine specific and can control the hardware directly</li>
            <li>Can be highly optimised to make efficient use of the hardware and execute more quickly</li>
            <li>Each line of code is one instruction only</li>
            <li>Hard to read and learn</li>
            <li>Only works for one type of machine architecture</li>
            <li>Uses mnemonics – sequences of letters easy for a person to remember (ADD, LOAD, SUB, INP etc.)</li>


          </ul>
        </td>
      </tr>
    </tbody>
  </table>

</div>

          <div class="knowledge-card">
  <p>
    One line of Python code results in many lines of machine code due to the steps
    necessary to perform the operation in hardware.
  </p>

  <p><strong>Python code:</strong></p>
  <pre>
a = 5 + 10
  </pre>

  <p><strong>Resulting Assembly Code:</strong></p>
  <pre>
1. MOV R1, #5     ; Move constant 5 into register R1
2. MOV R2, #10    ; Move constant 10 into register R2
3. ADD R3, R1, R2 ; Add R1 and R2, store result in R3
4. MOV [a], R3    ; Store the result from R3 into the memory location of a
  </pre>
</div>

          <div class="knowledge-card">
  <h3>How an Assembler Works</h3>

  <ul>
    <li>Reserves storage for instructions and data</li>
    <li>Replaces mnemonic opcodes with machine codes</li>
    <li>Replaces symbolic addresses with numeric addresses</li>
    <li>Creates a symbol table to map symbolic labels to numeric memory addresses</li>
    <li>Checks syntax</li>
    <li>Provides error diagnostics</li>
  </ul>

  <p><strong>Example Assembly Code (using symbols):</strong></p>
  <pre>
INP         ; Read input into the accumulator
ADD DATA    ; Add the value stored at DATA
STA DATA    ; Store the result back in DATA
HLT         ; Halt execution
DATA DAT 10 ; Store initial value 10
  </pre>

  <p><strong>After Assembly (symbols replaced with addresses):</strong></p>
  <pre>
INP
ADD 00010000 ; Add the value stored at address 00010000
STA 00010000 ; Store the result back at address 00010000
HLT
  </pre>

  <p><strong>Symbol Table:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Symbol</th>
        <th>Address</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>DATA</td>
        <td>00010000</td>
      </tr>
    </tbody>
  </table>
</div>

          <div class="knowledge-card">
  <table>
    <thead>
      <tr>
        <th>Compilers</th>
        <th>Interpreters</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Translate the entire source code in one go into machine code and create an executable file (exe)</td>
        <td>Translate and execute source code line by line</td>
      </tr>
      <tr>
        <td>Object code results in faster processing</td>
        <td>Slower processing</td>
      </tr>
      <tr>
        <td>Reports all errors at the end of compilation</td>
        <td>Reports errors as they occur</td>
      </tr>
      <tr>
        <td>Whole program must be loaded into memory</td>
        <td>Memory is only needed as each line of code is run</td>
      </tr>
      <tr>
        <td>Used at the end of development (ready for shipping)</td>
        <td>Used during development (aids debugging)</td>
      </tr>
      <tr>
        <td>Source code is hidden, protecting it from being copied</td>
        <td>Source code must be accessible</td>
      </tr>
      <tr>
        <td>Machine dependent – only runs on computers with a specific architecture</td>
        <td>Platform independent – requires a suitable interpreter</td>
      </tr>
    </tbody>
  </table>
</div>
<div class="knowledge-card">
  <h3>High-Level Languages and Intermediate Code</h3>

  <p>
    Intermediate code is a type of code that sits between high-level source code
    (such as Python, Java, or C#) and machine code (binary code executed by the CPU).
    It is not specific to any machine, but it is more structured and lower-level than
    the original source code.
  </p>


    <img src="images/translators/intermediate-code-vm-flow.jpeg" height="199" width="655"/>
    <p>
    An interpreter or virtual machine handles machine-specific execution.
  </p>

  <ul>
    <li>Portable – can be used on any machine (write once, run anywhere)</li>
    <li>The same intermediate code can run on different systems using the appropriate interpreter or virtual machine</li>
    <li>Intermediate code is machine-independent</li>
    <li>Protects the source code from being copied</li>
  </ul>

  <h4>Execution Process</h4>
  <pre>
Source Code → Compiled → Intermediate Code → Runs in Virtual Machine
  </pre>
</div>

          <div class="knowledge-card">
  <h3>Opcode and Operand</h3>

  <p>
    An instruction is split into an <strong>opcode</strong> and an <strong>operand</strong>.
  </p>
  <ul>
    <li><strong>Opcode</strong> specifies which operation to carry out</li>
    <li><strong>Operand</strong> specifies the data that needs to be acted on</li>
  </ul>

  <h4>Common LMC Mnemonics</h4>
  <table>
    <thead>
      <tr>
        <th>Mnemonic</th>
        <th>Instruction</th>
        <th>Alternative Mnemonics Accepted</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>ADD</td>
        <td>Add</td>
        <td></td>
      </tr>
      <tr>
        <td>SUB</td>
        <td>Subtract</td>
        <td></td>
      </tr>
      <tr>
        <td>STA</td>
        <td>Store</td>
        <td>STO</td>
      </tr>
      <tr>
        <td>LDA</td>
        <td>Load</td>
        <td>LOAD</td>
      </tr>
      <tr>
        <td>BRA</td>
        <td>Branch always</td>
        <td>BR</td>
      </tr>
      <tr>
        <td>BRZ</td>
        <td>Branch if zero</td>
        <td>BZ</td>
      </tr>
      <tr>
        <td>BRP</td>
        <td>Branch if positive</td>
        <td>BP</td>
      </tr>
      <tr>
        <td>INP</td>
        <td>Input</td>
        <td>IN, INPUT</td>
      </tr>
      <tr>
        <td>OUT</td>
        <td>Output</td>
        <td></td>
      </tr>
      <tr>
        <td>HLT</td>
        <td>End program</td>
        <td>COB, END</td>
      </tr>
      <tr>
        <td>DAT</td>
        <td>Data location</td>
        <td></td>
      </tr>
    </tbody>
  </table>

  <h4>Example: Add Two Numbers (LMC)</h4>
  <pre>
INP        // Input the first number
STA 90     // Store the first number in memory location 90
INP        // Input the second number
ADD 90     // Add the number in memory location 90 to the accumulator
OUT        // Output the result
HLT        // End the program
DAT        // Memory location 90 for storing data
  </pre>
</div>

          <div class="knowledge-card">
  <h3>Addressing modes</h3>

  <h4>Immediate Addressing (#)</h4>
  <p><strong>#</strong> before a number means to use the <strong>value itself</strong>, not the address.</p>
  <p>
    Example: <code>ADD #4</code> means “Load the value 4 directly into the accumulator.”
  </p>

  <h4>Direct Addressing (default, no symbol)</h4>
  <p>The operand refers directly to a memory address.</p>
  <p>
    Example: <code>LDA 10</code> means “Load the value at memory address 10.”
  </p>

  <h4>Indirect Addressing (&amp;)</h4>
  <p>
    <strong>&amp;</strong> means the operand is the <strong>address of a memory location that contains another address</strong>.
  </p>
  <p>Example: <code>LDA &amp;7</code> means:</p>
  <ol>
    <li>Go to memory address 7, read the number there (15).</li>
    <li>Then go to memory address 15 and load that value.</li>
  </ol>

  <figure>
    <figcaption><strong>Fig. 3.1</strong></figcaption>
    <pre style="white-space: pre; overflow:auto; margin-top:.5rem;">
0  LDA &amp;7
1  ADD #4
2  OUT
3  HLT
4  6
5  2
6  10
7  15
8  16
9  17
    </pre>
  </figure>

  <hr />

  <h4>Indexed addressing</h4>
  <p>
    Indexed addressing uses a <strong>base address + the value in an index register</strong> to compute the final memory address.
    This allows for <strong>array-like access</strong> or <strong>looping through data</strong>.
  </p>

  <p><strong>For example:</strong></p>
  <ul>
    <li>The instruction is <code>LDA 20,X</code></li>
    <li>The index register <strong>X</strong> contains the value <code>0</code></li>
  </ul>

  <p>
    Then: The LMC loads the value from address <code>20 + 0 = 20</code>, so it accesses <strong>memory address 20</strong>.
  </p>
  <p>After the operation, the index register <strong>X increments by 1</strong>.</p>
</div>



          <div class="knowledge-card">
  <h3>Stage 1: Lexical Analysis</h3>

  <ol>
    <li>Lexer scans the source code letter by letter</li>
    <li>Words (lexemes) are identified when there is whitespace, an operator symbol, or a special symbol</li>
    <li>Comments are stripped out and unnecessary spaces are removed</li>
    <li>Each lexeme is checked to see if it is a valid token</li>
    <li>The lexeme is stored along with its token and added to the symbol table</li>
  </ol>

  <p><strong>Example:</strong></p>
  <pre>
[keyword: if][Separator: (][Identifier: x][Operator: >]
  </pre>

  <p>
    All keywords, constants, and identifiers (e.g. variable names) used in the
    source code are replaced by <strong>tokens</strong>.
  </p>

  <h4>Token Classes</h4>
  <table>
    <thead>
      <tr>
        <th>Token Class</th>
        <th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Identifier</td>
        <td>Any function or variable name</td>
      </tr>
      <tr>
        <td>Keyword</td>
        <td>As, If, Else, EndIf, Function, EndFunction, Return</td>
      </tr>
      <tr>
        <td>Separator</td>
        <td>( ) , &amp;</td>
      </tr>
      <tr>
        <td>Operator</td>
        <td>+ - * / % ^ DIV MOD &lt; &gt; =</td>
      </tr>
      <tr>
        <td>Literal</td>
        <td>"Hello world"</td>
      </tr>
      <tr>
        <td>Number</td>
        <td>-4, 0, 3.4</td>
      </tr>
      <tr>
        <td>Quote</td>
        <td>"</td>
      </tr>
      <tr>
        <td>Boolean</td>
        <td>True, False</td>
      </tr>
      <tr>
        <td>Datatype</td>
        <td>Integer, Decimal, String, Boolean</td>
      </tr>
    </tbody>
  </table>
</div>

          <div class="knowledge-card">
  <h3>The Symbol Table</h3>

  <p>
    The symbol table plays a central role in the compilation process.
    It contains an entry for every keyword (reserved word) and identifier
    in the program.
  </p>

  <h4>The table will show:</h4>
  <ul>
    <li>Identifier or keyword</li>
    <li>Kind of item (variable, array, procedure, keyword, etc.)</li>
    <li>Type of item (integer, real, char, etc.) – added during the syntax stage</li>
  </ul>

  <h4>It will also store:</h4>
  <ul>
    <li>Run-time address of the item, or its value if it is a constant</li>
    <li>
      Pointer to accessing information
      (e.g. array bounds, or procedure parameter information)
    </li>
  </ul>

  <h4>Example Source Code</h4>
  <pre>
Function checkScore(score As Integer)
  If score > 75 Then
    Return "Pass"
  Else
    Return "Fail"
  EndIf
EndFunction
  </pre>

  <h4>Example Symbol Table</h4>

              <img src="images/translators/symbol-table-function-checkscore.jpeg" height="352"
                                    width="761"/>


              <img src="images/translators/symbol-table-token-list.jpeg" height="755" width="696"/>
              <p><em>
    Note: Data types and additional details are added during the syntax analysis stage.
  </em></p>
</div>

<div class="knowledge-card">
  <h3>Stage 2: Syntax Analysis</h3>

  <ul>
    <li>This stage analyses the syntax of statements to ensure they conform to the grammar rules of the programming language</li>
    <li>The purpose of syntax analysis (parsing) is to check that there is a valid sequence of tokens</li>
    <li>Tokens represent symbols, keywords, identifiers, literals, etc.</li>
  </ul>

  <h4>Process</h4>
  <ol>
    <li>Token stream is sent to the syntax analyser</li>
    <li>The analyser checks that the token stream follows the grammar rules of the language</li>
    <li>Stacks are used to check structures such as correctly paired brackets</li>
    <li>If errors are found, they are reported</li>
    <li>Error diagnostics are produced</li>
    <li>An abstract syntax tree (AST) is created</li>
    <li>Identifiers in the symbol table are updated (e.g. data type, scope)</li>
  </ol>


    <img src="images/translators/compiler-lexical-syntax-flow.png" width="50%"/>
    <hr>

  <h3>Stage 3: Code Generation and Optimisation</h3>

  <p>
    This is the final phase of compilation and produces <strong>object code</strong>.
  </p>

  <ul>
    <li>Makes the program run faster / code more efficient</li>
    <li>Makes the program use fewer resources / less memory</li>
  </ul>

  <h4>Disadvantages of Code Optimisation</h4>
  <ul>
    <li>Increases compilation time, sometimes considerably</li>
    <li>May sometimes produce unexpected results</li>
  </ul>

  <h4>Examples of Optimisation</h4>
  <ul>
    <li>Removes variables and subprograms that are not used</li>
    <li>Removes lines of code that are never accessed</li>
  </ul>
</div>

          <div class="knowledge-card">
  <h3>What is a Linker?</h3>

  <ul>
    <li>Combines/links code and programs to files or software libraries</li>
    <li>Forms a single executable file</li>
    <li>Static linkers combine code and libraries into one file</li>
    <li>Dynamic linkers add addresses to external libraries</li>
  </ul>

  <h3>What is a Loader?</h3>

  <ul>
    <li>Part of the operating system</li>
    <li>Loads an executable file into memory</li>
    <li>Loads the program from secondary storage</li>
    <li>Loads the required software libraries</li>
  </ul>

  <h3>Libraries</h3>

  <p>
    Library programs are ready-compiled programs grouped into software libraries,
    which can be loaded and run when required. In Windows, these often have a
    <code>.dll</code> extension.
  </p>

  <p>
    Most compiled languages have their own libraries of pre-written functions
    which can be invoked in a defined manner from within the user's program.
  </p>

  <h4>Advantages of Library Routines</h4>
  <ul>
    <li>Tested and error-free</li>
    <li>Save programmer time by avoiding re-inventing the wheel</li>
    <li>Provide ready-made solutions for common tasks</li>
  </ul>
</div>

      </div>
    </div>
  </section>
<!-- =========================
       QUESTIONS & ANSWERS (BY TOPIC)
       ========================= -->
  <section class="topic-section expanded">
    <div class="topic-header">
      <span class="topic-arrow">&#9656;</span>
      <h2>Check Your Understanding – Questions</h2>
    </div>
    <div class="topic-body">
      <div class="vertical-qa">

<!-- =======================
     TOPIC A – Opcodes & Mnemonics
     ======================= -->
<h2>Topic A: Opcodes & Mnemonics</h2>

<div class="rev-card qa-card">
  <p>1. Low-level languages have features which include opcodes and mnemonics. (i) Explain the term opcode.<span class="marks">[0/2]</span></p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Part of an instruction or code</li>
      <li>Indicates what operation the processor should carry out</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>2. Low-level languages have features which include opcodes and mnemonics. (ii) Explain the term mnemonic, giving an example.<span class="marks">[0/3]</span></p>

  <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>A short sequence of letters representing an instruction</li>
      <li>Easy for humans to remember</li>
      <li>Example: <strong>ADD</strong> for addition</li>
    </ul>
  </div>
</div>

<!-- =======================
     TOPIC B – Assembly, HLL, Translators
     ======================= -->
<h2>Topic B: Assembly, High-Level Languages & Translators</h2>

<div class="rev-card qa-card">
  <p>3. What is the difference between Assembly language and a High-Level Language (HLL)?<span class="marks">[0/4]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Assembly uses mnemonics; HLL uses English-like statements</li>
      <li>Assembly uses an assembler; HLL uses a compiler or interpreter</li>
      <li>Assembly is one-to-one with machine code; HLL is one-to-many</li>
      <li>Assembly is machine dependent; HLL is portable</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>4(a). A programmer creates this function using a high-level language. Before the code can be executed, a translator must be used. State the purpose of a translator.<span class="marks">[0/1]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>To convert high-level or assembly code into machine code</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>4(b). A programmer creates this function using a high-level language. Before the code can be executed, a translator must be used. Explain two differences between a compiler and an interpreter.<span class="marks">[0/4]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Compiler translates the whole program; interpreter translates line by line</li>
      <li>Compiler produces an executable; interpreter does not</li>
      <li>Compiler reports errors at the end; interpreter reports errors immediately</li>
      <li>Compiled programs hide source code; interpreted programs expose it</li>
    </ul>
  </div>
</div>

<!-- =======================
     TOPIC C – Little Man Computer (LMC)
     ======================= -->
<h2>Topic C: Little Man Computer (LMC)</h2>

          <h3>Example</h3>
<div class="knowledge-card">
  <p>LMC — Example 2: Find the smallest of three numbers</p>

  <p>
    This program inputs three numbers and determines the smallest of the three, outputting the result.
  </p>

  <pre><code>INP                 // Input the first number
STA 91              // Store the first number in memory location 91
INP                 // Input the second number
STA 92              // Store the second number in memory location 92
INP                 // Input the third number
STA 93              // Store the third number in memory location 93
LDA 91              // Load the first number
SUB 92              // Subtract the second number
BRP CHECK_THIRD_FROM_FIRST   // If result is positive, then first number &gt; second number

LDA 92              // Load the second number
SUB 93              // Subtract the third number
BRP OUTPUT_SECOND   // If result is positive, then second number &gt; third number
LDA 93
OUT                 // Output the third number
HLT

CHECK_THIRD_FROM_FIRST:
  LDA 91
  SUB 93
  BRP OUTPUT_FIRST
  LDA 93
  OUT
  HLT

OUTPUT_FIRST:
  LDA 91
  OUT
  HLT

OUTPUT_SECOND:
  LDA 92
  OUT
  HLT

DAT                 // Memory locations for data storage
DAT
DAT</code></pre>
</div>



<div class="rev-card qa-card">
  <p>5(a). Fig. 3 shows assembly code written using the LMC instruction set.
      Indicate the programming construct that is not used in Fig. 3.

      <span class="marks">[0/1]</span></p>

    <img src="images/translators/lmc-fig3-program.png" height="365" width="232"/><textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul><li>Iteration</li></ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>5(b). Fig. 3 shows assembly code written using the LMC instruction set. When the program is run, 7 is input by the user. State the value that will be in the memory location Z when the program has run with this input.<span class="marks">[0/1]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul><li>5</li></ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>5(c). Fig. 3 shows assembly code written using the LMC instruction set.
      Write an equivalent version of the LMC assembly code shown in Fig. 3 for a
      procedural programming language. You should write your code using pseudocode or program code.<span class="marks">[0/4]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <pre>
X = input()
Y = 5
if X >= Y then
  Z = Y
else
  Z = X
endif
    </pre>
  </div>
</div>

<div class="rev-card qa-card">
  <p>6(b). Fig. 1 shows assembly code written using the Little Man Computer (LMC). The program calculates and outputs the total amount that is donated to a charity in any particular day. Depending on the amount, an additional bonus may be added to each amount donated.
The program shown in Fig. 1 is run once using three different inputs. Therefore, while the program is running once, it will output the updated total three times. Give the total values that are output when the values 10, 50 and 120 are input into this program.<span class="marks">[0/3]</span></p>

    <img src="images/translators/lmc-charity-donations-program.png" height="506" width="317"/>

    <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">

       <ul>
      <li>10 → 10</li>
      <li>50 → 60</li>
      <li>120 → 200</li>
    </ul>

  </div>
</div>

          <div class="rev-card qa-card">
  <p>6(ii).Write LMC code that will reset the value of the memory location labelled total to zero and then stop the program.<span class="marks">[0/3]</span></p>


    <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
      <ul>
      <li>Establishes a zero value (by use of DAT / SUB)</li>
      <li>Stores a zero value into total</li>
      <li>Program stops</li>
  </ul>
    <pre>
LDA ZERO
STA total
HLT
ZERO DAT 0
total DAT
    </pre>
    </pre>
  </div>
</div>



  <div class="rev-card qa-card">
    <h3>Question</h3>

    <div class="question">
      <p>
        The pseudocode algorithm here will take in two numbers from the user,
        multiply them together using addition and output the result.
      </p>

      <p>
        For example, 4 multiplied by 3 would be
        <code>4 + 4 + 4 = 12</code>.
      </p>

      <p>You can assume the function input takes in a value as an integer.</p>

      <pre class="code-block"><code>numA = input("Enter first number")
numB = input("Enter second number")
answer = 0
while (numB &gt; 0)
  answer = answer + numA
 contribute = numB - 1
endwhile
print(answer)</code></pre>

      <p>
        Write this algorithm in assembly language using the
        <strong>Little Man Computer (LMC)</strong> instruction set. [6]
      </p>
    </div>

    <textarea class="student-answer" placeholder="Write your answer here..."></textarea>

    <button class="secondary answer-toggle" type="button">Show answer</button>

    <div class="answer" hidden>
      <pre class="code-block"><code>        INP
        STA NUMA
        INP
        STA NUMB
LOOP    LDA NUMB
        BRZ END
        SUB ONE
        STA NUMB
        LDA ANSWER
        ADD NUMA
        STA ANSWER
        BRA LOOP
END     LDA ANSWER
        OUT
        HLT
ANSWER  DAT 0
NUMA    DAT 0
NUMB    DAT 0
ONE     DAT 1</code></pre>
    </div>
  </div>



<!-- =======================
     TOPIC D – Addressing Modes
     ======================= -->
<p>Topic D: Addressing Modes</p>

<div class="rev-card qa-card">
  <h3>7(a). In Orla&#39;s LMC code, she used direct memory addressing. Give three other modes of memory addressing.<span class="marks">[0/3]</span></h3>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Immediate</li>
      <li>Indirect</li>
      <li>Indexed</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>7(b). A Little Man Computer (LMC) assembly language program is stored in memory as shown in Fig. 3.1.
      In this variant of LMC the symbols &amp; and # are used to denote different modes of addressing.
      Given that the output is 17, state the addressing mode represented by each symbol: (i) &amp; (ii) #.<span class="marks">[0/2]</span></p>

    <img src="images/translators/lmc-addressing-modes-fig3-1.png" height="319" width="152"/>

    <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>&amp; → Immediate addressing</li>
      <li># → Indirect addressing</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>8. In assembly language, different modes of addressing memory can be used. Discuss the different modes used. You should include: how the operand value is determined; what an operand of 27 would refer to in that mode; the reasons for requiring multiple modes of addressing.<span class="marks">[0/12]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Immediate: operand is the value itself</li>
      <li>Direct: operand is the memory address</li>
      <li>Indirect: operand points to another address</li>
      <li>Indexed: operand + index register used</li>
      <li>Multiple modes improve flexibility and efficiency</li>
    </ul>
  </div>
</div>

<!-- =======================
     TOPIC E – Compilation Process
     ======================= -->
<h2>Topic E: Compilation Process</h2>

<div class="rev-card qa-card">
  <p>9(a). The following source code is written in Python.
      It contains errors. Using lines of code from the program to illustrate your answer,
      state two things that would be done during lexical analysis.<span class="marks">[0/2]</span></p>


    <img src="images/translators/python-code-with-errors.png" height="404" width="658"/>
    <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Removes comments</li>
      <li>Removes unnecessary whitespace</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>9(b). The following source code is written in Python. It contains errors. Using lines of code from the program to illustrate your answer, state two things that would be done during syntax analysis.<span class="marks">[0/2]</span></p>

    <img src="images/translators/python-code-with-errors.png" height="404" width="658"/><textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Variable used before initialisation</li>
      <li>Misspelt keyword</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>10. The process of compilation involves a number of stages. Name the stage at which each of the following would be detected: (a) an illegal identifier; (b) an arithmetic operator is applied to an operand of the data type Boolean; (c) an operand is omitted from an arithmetic expression.<span class="marks">[0/3]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Illegal identifier → Lexical analysis</li>
      <li>Boolean arithmetic → Syntax analysis</li>
      <li>Missing operand → Syntax analysis</li>
    </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>11. Describe what happens during syntax analysis when code is compiled.<span class="marks">[0/5]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">

  <h3>Mark Scheme Points</h3>

  <h4>2 Marks from this section</h4>
  <ul>
    <li>Statements / tokens are checked…</li>
    <li>… against the rules / grammar of the language</li>
    <li>valid example given</li>
  </ul>

  <h4>3 Marks from this section</h4>
  <ul>
    <li>Errors reported as a list</li>
    <li>Error diagnostics given</li>
    <li>Detail added to symbol table…</li>
    <li>…eg data type / scope / address</li>
    <li>Receives output from lexical analysis / passes code to code generation</li>
  </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>12(b). Describe the purpose of code optimisation.<span class="marks">[0/2]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
    <ul>
      <li>Makes programs run faster</li>
      <li>Reduces memory and resource usage</li>
    </ul>
  </div>
</div>

<!-- =======================
     TOPIC F – Linkers, Loaders & Libraries
     ======================= -->
<h2>Topic F: Linkers, Loaders & Libraries</h2>

<div class="rev-card qa-card">
  <p>13(a). What is a linker? (From: “What is a linker and what is a loader?”)<span class="marks">[0/2]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
   <h4>1 mark per bullet (maximum 2)</h4>
  <ul>
    <li>Combines / links code / programs to files / software libraries…</li>
    <li>…to form a single executable file</li>
    <li>Static linkers combine code and libraries into one file</li>
    <li>Dynamic linkers link – add addresses to libraries</li>
  </ul>
  </div>
</div>

<div class="rev-card qa-card">
  <p>13(b). What is a loader? (From: “What is a linker and what is a loader?”)<span class="marks">[0/2]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">
     <h4>1 mark per bullet (maximum 2)</h4>
  <ul>
    <li>It is part of the operating system</li>
    <li>Loads an <strong>executable file</strong> (into memory)…</li>
    <li>…from secondary storage</li>
    <li>Loads the required <strong>software libraries</strong></li>
  </ul>
  </div>
</div>


<div class="rev-card qa-card">
  <p>13(c). State three benefits of using library routines when a program is written.<span class="marks">[0/3]</span></p>

  <textarea class="student-answer"></textarea>

  <button class="secondary answer-toggle">Show answer</button>
  <div class="answer">

  <ul>
    <li>Relatively error free / has already been tested</li>
    <li>Ready to use / saves time / already been written</li>
    <li>Used multiple times / common tasks / reduces repeated code</li>
    <li>Programmer expertise</li>
  </ul>

  </div>
</div>

      </div>
    </div>
  </section>



</main>

<footer>
  &copy; 2025 StudyHubCS
</footer>

<script>
  // Toggle topic sections open/closed
  document.querySelectorAll('.topic-header').forEach(header => {
    header.addEventListener('click', () => {
      const section = header.parentElement;
      section.classList.toggle('collapsed');
      section.classList.toggle('expanded');
    });
  });

  // Show / hide individual answers
  document.querySelectorAll('.answer-toggle').forEach(btn => {
    const answer = btn.nextElementSibling;
    if (!answer) return;

    // ensure hidden initially (CSS also sets .answer display:none)
    answer.style.display = 'none';

    btn.addEventListener('click', () => {
      const open = answer.style.display === 'block';
      answer.style.display = open ? 'none' : 'block';
      btn.textContent = open ? 'Show answer' : 'Hide answer';
    });
  });

  /* -----------------------------
     Print button
  ------------------------------ */
  const printBtn = document.getElementById("printBtn");
  if (printBtn) {
    printBtn.addEventListener("click", () => {
      window.print();
    });
  }

</script>

</body>
</html>